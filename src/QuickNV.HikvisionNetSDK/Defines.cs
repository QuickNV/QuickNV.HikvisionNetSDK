using System;
using System.Runtime.InteropServices;

namespace QuickNV.HikvisionNetSDK
{
    /// <summary>
    /// CHCNetSDK 的摘要说明。
    /// </summary>
    public partial class Defines
    {
        public Defines()
        {
            //
            // TODO: 在此处添加构造函数逻辑
            //
        
        }

        /// <summary>
        /// SDK类型
        /// </summary>
        public const int SDK_PLAYMPEG4 = 1;
        /// <summary>
        /// 网络库
        /// </summary>
        public const int SDK_HCNETSDK = 2;
        /// <summary>
        /// 用户名长度
        /// </summary>
        public const int NAME_LEN = 32;
        /// <summary>
        /// 密码长度
        /// </summary>
        public const int PASSWD_LEN = 16;
        /// <summary>
        /// GUID长度
        /// </summary>
        public const int GUID_LEN = 16;
        /// <summary>
        /// 设备类型名称长度
        /// </summary>
        public const int DEV_TYPE_NAME_LEN = 24;
        /// <summary>
        /// DVR本地登陆名
        /// </summary>
        public const int MAX_NAMELEN = 16;
        /// <summary>
        /// 设备支持的权限（1-12表示本地权限，13-32表示远程权限）
        /// </summary>
        public const int MAX_RIGHT = 32;
        /// <summary>
        /// 序列号长度
        /// </summary>
        public const int SERIALNO_LEN = 48;
        /// <summary>
        /// mac地址长度
        /// </summary>
        public const int MACADDR_LEN = 6;
        /// <summary>
        /// 设备可配以太网络
        /// </summary>
        public const int MAX_ETHERNET = 2;
        /// <summary>
        /// 设备可配最大网卡数目
        /// </summary>
        public const int MAX_NETWORK_CARD = 4;
        /// <summary>
        /// 路径长度
        /// </summary>
        public const int PATHNAME_LEN = 128;
        /// <summary>
        /// 号码最大长度
        /// </summary>
        public const int MAX_NUMBER_LEN = 32;
        /// <summary>
        /// 设备名称最大长度
        /// </summary>
        public const int MAX_NAME_LEN = 128;
        /// <summary>
        /// 8000设备最大时间段数
        /// </summary>
        public const int MAX_TIMESEGMENT = 4;
        /// <summary>
        /// 抓拍机红外滤光片预置点数
        /// </summary>
        public const int MAX_ICR_NUM = 8;
        /// <summary>
        /// 8000设备最大遮挡区域数
        /// </summary>
        public const int MAX_SHELTERNUM = 4;
        /// <summary>
        /// pppoe拨号号码最大长度
        /// </summary>
        public const int PHONENUMBER_LEN = 32;
        /// <summary>
        /// 8000设备最大硬盘数
        /// </summary>
        public const int MAX_DISKNUM = 16;
        /// <summary>
        /// 1.2版本之前版本
        /// </summary>
        public const int MAX_DISKNUM_V10 = 8;
        /// <summary>
        /// 9000设备本地显示最大播放窗口数
        /// </summary>
        public const int MAX_WINDOW_V30 = 32;
        /// <summary>
        /// 8000设备最大硬盘数
        /// </summary>
        public const int MAX_WINDOW = 16;
        /// <summary>
        /// 9000设备最大可接VGA数
        /// </summary>
        public const int MAX_VGA_V30 = 4;
        /// <summary>
        /// 8000设备最大可接VGA数
        /// </summary>
        public const int MAX_VGA = 1;
        /// <summary>
        /// 9000设备最大用户数
        /// </summary>
        public const int MAX_USERNUM_V30 = 32;
        /// <summary>
        /// 8000设备最大用户数
        /// </summary>
        public const int MAX_USERNUM = 16;
        /// <summary>
        /// 9000设备最大异常处理数
        /// </summary>
        public const int MAX_EXCEPTIONNUM_V30 = 32;
        /// <summary>
        /// 8000设备最大异常处理数
        /// </summary>
        public const int MAX_EXCEPTIONNUM = 16;
        /// <summary>
        /// 8000设备单通道最大视频流连接数
        /// </summary>
        public const int MAX_LINK = 6;
        /// <summary>
        /// 抓拍机最大报警输出
        /// </summary>
        public const int MAX_ITC_EXCEPTIONOUT = 32;
        /// <summary>
        /// 单路解码器每个解码通道最大可循环解码数
        /// </summary>
        public const int MAX_DECPOOLNUM = 4;
        /// <summary>
        /// 单路解码器的最大解码通道数（实际只有一个，其他三个保留）
        /// </summary>
        public const int MAX_DECNUM = 4;
        /// <summary>
        /// 单路解码器可配置最大透明通道数
        /// </summary>
        public const int MAX_TRANSPARENTNUM = 2;
        /// <summary>
        /// 单路解码器最大轮循通道数
        /// </summary>
        public const int MAX_CYCLE_CHAN = 16;
        /// <summary>
        /// 最大轮询通道数（扩展）
        /// </summary>
        public const int MAX_CYCLE_CHAN_V30 = 64;
        /// <summary>
        /// 最大目录长度
        /// </summary>
        public const int MAX_DIRNAME_LENGTH = 80;
        /// <summary>
        /// 9000设备最大OSD字符行数数
        /// </summary>
        public const int MAX_STRINGNUM_V30 = 8;
        /// <summary>
        /// 8000设备最大OSD字符行数数
        /// </summary>
        public const int MAX_STRINGNUM = 4;
        /// <summary>
        /// 8000定制扩展
        /// </summary>
        public const int MAX_STRINGNUM_EX = 8;
        /// <summary>
        /// 9000设备最大辅助输出数
        /// </summary>
        public const int MAX_AUXOUT_V30 = 16;
        /// <summary>
        /// 8000设备最大辅助输出数
        /// </summary>
        public const int MAX_AUXOUT = 4;
        /// <summary>
        /// 9000设备最大硬盘组数
        /// </summary>
        public const int MAX_HD_GROUP = 16;
        /// <summary>
        /// 8000设备最大NFS硬盘数
        /// </summary>
        public const int MAX_NFS_DISK = 8;
        /// <summary>
        /// WIFI的SSID号长度
        /// </summary>
        public const int IW_ESSID_MAX_SIZE = 32;
        /// <summary>
        /// WIFI密锁最大字节数
        /// </summary>
        public const int IW_ENCODING_TOKEN_MAX = 32;
        public const int WIFI_WEP_MAX_KEY_COUNT = 4;
        public const int WIFI_WEP_MAX_KEY_LENGTH = 33;
        public const int WIFI_WPA_PSK_MAX_KEY_LENGTH = 63;
        public const int WIFI_WPA_PSK_MIN_KEY_LENGTH = 8;
        public const int WIFI_MAX_AP_COUNT = 20;
        /// <summary>
        /// 最多支持的透明通道路数
        /// </summary>
        public const int MAX_SERIAL_NUM = 64;
        /// <summary>
        /// 9000设备最大可配ddns数
        /// </summary>
        public const int MAX_DDNS_NUMS = 10;
        /// <summary>
        /// 最大email地址长度
        /// </summary>
        public const int MAX_EMAIL_ADDR_LEN = 48;
        /// <summary>
        /// 最大email密码长度
        /// </summary>
        public const int MAX_EMAIL_PWD_LEN = 32;
        /// <summary>
        /// 回放时的最大百分率
        /// </summary>
        public const int MAXPROGRESS = 100;
        /// <summary>
        /// 8000设备支持的串口数 1-232， 2-485
        /// </summary>
        public const int MAX_SERIALNUM = 2;
        /// <summary>
        /// 卡号长度
        /// </summary>
        public const int CARDNUM_LEN = 20;
        /// <summary>
        /// 外部结构体卡号长度
        /// </summary>
        public const int CARDNUM_LEN_OUT = 32;
        /// <summary>
        /// 9000设备的视频输出数
        /// </summary>
        public const int MAX_VIDEOOUT_V30 = 4;
        /// <summary>
        /// 8000设备的视频输出数
        /// </summary>
        public const int MAX_VIDEOOUT = 2;
        /// <summary>
        /// 9000设备支持的云台预置点数
        /// </summary>
        public const int MAX_PRESET_V30 = 256;
        /// <summary>
        /// 9000设备支持的花样扫描数
        /// </summary>
        public const int MAX_TRACK_V30 = 256;
        /// <summary>
        /// 9000设备支持的云台巡航数
        /// </summary>
        public const int MAX_CRUISE_V30 = 256;
        /// <summary>
        /// 8000设备支持的云台预置点数
        /// </summary>
        public const int MAX_PRESET = 128;
        /// <summary>
        /// 8000设备支持的花样扫描数
        /// </summary>
        public const int MAX_TRACK = 128;
        /// <summary>
        /// 8000设备支持的云台巡航数
        /// </summary>
        public const int MAX_CRUISE = 128;
        /// <summary>
        /// 一条巡航最多的巡航点
        /// </summary>
        public const int CRUISE_MAX_PRESET_NUMS = 32;
        /// <summary>
        /// 9000设备支持232串口数
        /// </summary>
        public const int MAX_SERIAL_PORT = 8;
        /// <summary>
        /// 设备支持最大预览模式数目 1画面,4画面,9画面,16画面....
        /// </summary>
        public const int MAX_PREVIEW_MODE = 8;
        /// <summary>
        /// 最大模拟矩阵输出个数
        /// </summary>
        public const int MAX_MATRIXOUT = 16;
        /// <summary>
        /// 日志附加信息
        /// </summary>
        public const int LOG_INFO_LEN = 11840;
        /// <summary>
        /// 云台描述字符串长度
        /// </summary>
        public const int DESC_LEN = 16;
        /// <summary>
        /// 9000最大支持的云台协议数
        /// </summary>
        public const int PTZ_PROTOCOL_NUM = 200;
        /// <summary>
        /// 8000语音对讲通道数
        /// </summary>
        public const int MAX_AUDIO = 1;
        /// <summary>
        /// 9000语音对讲通道数
        /// </summary>
        public const int MAX_AUDIO_V30 = 2;
        /// <summary>
        /// 8000设备最大通道数
        /// </summary>
        public const int MAX_CHANNUM = 16;
        /// <summary>
        /// 8000设备最大报警输入数
        /// </summary>
        public const int MAX_ALARMIN = 16;
        /// <summary>
        /// 8000设备最大报警输出数
        /// </summary>
        public const int MAX_ALARMOUT = 4;
        /// <summary>
        /// 9000 IPC接入
        /// </summary>
        public const int MAX_ANALOG_CHANNUM = 32;
        /// <summary>
        /// 最大32路模拟报警输出
        /// </summary>
        public const int MAX_ANALOG_ALARMOUT = 32;
        /// <summary>
        /// 最大32路模拟报警输入
        /// </summary>
        public const int MAX_ANALOG_ALARMIN = 32;
        /// <summary>
        /// 允许接入的最大IP设备数
        /// </summary>
        public const int MAX_IP_DEVICE = 32;
        /// <summary>
        /// 允许接入的最大IP设备数
        /// </summary>
        public const int MAX_IP_DEVICE_V40 = 64;
        /// <summary>
        /// 允许加入的最多IP通道数
        /// </summary>
        public const int MAX_IP_CHANNEL = 32;
        /// <summary>
        /// 允许加入的最多报警输入数
        /// </summary>
        public const int MAX_IP_ALARMIN = 128;
        /// <summary>
        /// 允许加入的最多报警输出数
        /// </summary>
        public const int MAX_IP_ALARMOUT = 64;
        /// <summary>
        /// 允许加入的最多报警输入数
        /// </summary>
        public const int MAX_IP_ALARMIN_V40 = 4096;
        /// <summary>
        /// 允许加入的最多报警输出数
        /// </summary>
        public const int MAX_IP_ALARMOUT_V40 = 4096;
        /// <summary>
        /// 每次删除或者刻录的最大文件数
        /// </summary>
        public const int MAX_RECORD_FILE_NUM = 20;
        /// <summary>
        /// SDK_V31 ATM
        /// </summary>
        public const int MAX_ATM_NUM = 1;
        public const int MAX_ACTION_TYPE = 12;
        public const int ATM_FRAMETYPE_NUM = 4;
        public const int MAX_ATM_PROTOCOL_NUM = 1025;
        public const int ATM_PROTOCOL_SORT = 4;
        public const int ATM_DESC_LEN = 32;
        /// <summary>
        /// SDK_V31 ATM
        /// 最大支持的通道数 最大模拟加上最大IP支持
        /// </summary>
        public const int MAX_CHANNUM_V30 = MAX_ANALOG_CHANNUM + MAX_IP_CHANNEL;
        /// <summary>
        /// 96
        /// </summary>
        public const int MAX_ALARMOUT_V30 = MAX_ANALOG_ALARMOUT + MAX_IP_ALARMOUT;
        /// <summary>
        /// 160
        /// </summary>
        public const int MAX_ALARMIN_V30 = MAX_ANALOG_ALARMIN + MAX_IP_ALARMIN;
        public const int MAX_CHANNUM_V40 = 512;
        /// <summary>
        /// 4128
        /// </summary>
        public const int MAX_ALARMOUT_V40 = MAX_IP_ALARMOUT_V40 + MAX_ANALOG_ALARMOUT;
        /// <summary>
        /// 4128
        /// </summary>
        public const int MAX_ALARMIN_V40 = MAX_IP_ALARMIN_V40 + MAX_ANALOG_ALARMOUT;
        public const int MAX_MULTI_AREA_NUM = 24;
        /// <summary>
        /// 最大照片数
        /// </summary>
        public const int MAX_HUMAN_PICTURE_NUM = 10;
        public const int MAX_HUMAN_BIRTHDATE_LEN = 10;
        public const int MAX_LAYERNUMS = 32;
        /// <summary>
        /// 支持的ROI区域数
        /// </summary>
        public const int MAX_ROIDETECT_NUM = 8;
        /// <summary>
        /// 最大车牌识别区域数
        /// </summary>
        public const int MAX_LANERECT_NUM = 5;
        /// <summary>
        /// 最大布防个数
        /// </summary>
        public const int MAX_FORTIFY_NUM = 10;
        /// <summary>
        /// 最大时间间隔个数
        /// </summary>
        public const int MAX_INTERVAL_NUM = 4;
        /// <summary>
        /// 最大车辆省份简称字符个数
        /// </summary>
        public const int MAX_CHJC_NUM = 3;
        /// <summary>
        /// 最大虚拟线圈个数
        /// </summary>
        public const int MAX_VL_NUM = 5;
        /// <summary>
        /// 最大车道数
        /// </summary>
        public const int MAX_DRIVECHAN_NUM = 16;
        /// <summary>
        /// 最大线圈个数
        /// </summary>
        public const int MAX_COIL_NUM = 3;
        /// <summary>
        /// 最大信号灯个数
        /// </summary>
        public const int MAX_SIGNALLIGHT_NUM = 6;
        public const int LEN_32 = 32;
        public const int LEN_31 = 31;
        /// <summary>
        /// 最大支持机柜数量
        /// </summary>
        public const int MAX_CABINET_COUNT = 8;
        public const int MAX_ID_LEN = 48;
        public const int MAX_PARKNO_LEN = 16;
        public const int MAX_ALARMREASON_LEN = 32;
        /// <summary>
        /// 获取升级文件匹配信息(模糊升级)
        /// </summary>
        public const int MAX_UPGRADE_INFO_LEN = 48;
        /// <summary>
        /// 自定义目录长度
        /// </summary>
        public const int MAX_CUSTOMDIR_LEN = 32;
        /// <summary>
        /// 每个串口允许建立的最大透明通道数
        /// </summary>
        public const int MAX_TRANSPARENT_CHAN_NUM = 4;
        /// <summary>
        /// 每个监听端口允许接入的最大主机数
        /// </summary>
        public const int MAX_TRANSPARENT_ACCESS_NUM = 4;
        /// <summary>
        /// ITS
        /// </summary>
        public const int MAX_PARKING_STATUS = 8;
        /// <summary>
        /// 一个通道最大4个车位 (从左到右车位 数组0～3)
        /// </summary>
        public const int MAX_PARKING_NUM = 4;
        /// <summary>
        /// 最大场景数量
        /// </summary>
        public const int MAX_ITS_SCENE_NUM = 16;
        /// <summary>
        /// 最大场景时间段数量
        /// </summary>
        public const int MAX_SCENE_TIMESEG_NUM = 16;
        /// <summary>
        /// 最大IP通道数
        /// </summary>
        public const int MAX_IVMS_IP_CHANNEL = 128;
        /// <summary>
        /// 设备编号长度
        /// </summary>
        public const int DEVICE_ID_LEN = 48;
        /// <summary>
        /// 显示点编号长度
        /// </summary>
        public const int MONITORSITE_ID_LEN = 48;
        /// <summary>
        /// 辅助区域最大数目
        /// </summary>
        public const int MAX_AUXAREA_NUM = 16;
        /// <summary>
        /// 最大从通道数量
        /// </summary>
        public const int MAX_SLAVE_CHANNEL_NUM = 16;
        public const int MAX_SCH_TASKS_NUM = 10;
        /// <summary>
        /// 最大服务器ID的长度
        /// </summary>
        public const int MAX_SERVERID_LEN = 64;
        /// <summary>
        /// 服务器域名最大长度
        /// </summary>
        public const int MAX_SERVERDOMAIN_LEN = 128;
        /// <summary>
        /// 认证ID最大长度
        /// </summary>
        public const int MAX_AUTHENTICATEID_LEN = 64;
        /// <summary>
        /// 认证密码最大长度
        /// </summary>
        public const int MAX_AUTHENTICATEPASSWD_LEN = 32;
        /// <summary>
        /// 最大服务器用户名
        /// </summary>
        public const int MAX_SERVERNAME_LEN = 64;
        /// <summary>
        /// 编码ID的最大长度
        /// </summary>
        public const int MAX_COMPRESSIONID_LEN = 64;
        /// <summary>
        /// SIP服务器地址支持域名和IP地址
        /// </summary>
        public const int MAX_SIPSERVER_ADDRESS_LEN = 128;
        /// <summary>
        /// 压线报警
        /// </summary>
        public const int MAX_PlATE_NO_LEN = 32;
        /// <summary>
        /// upnp端口映射端口数目
        /// </summary>
        public const int UPNP_PORT_NUM = 12;
        /// <summary>
        /// SOCKS最大本地网段个数
        /// </summary>
        public const int MAX_LOCAL_ADDR_LEN = 96;
        /// <summary>
        /// 国家简写名称长度
        /// </summary>
        public const int MAX_COUNTRY_NAME_LEN = 4;
        /// <summary>
        /// 热成像报警规则数
        /// </summary>
        public const int THERMOMETRY_ALARMRULE_NUM = 40;
        /// <summary>
        /// 门禁卡号长度
        /// </summary>
        public const int ACS_CARD_NO_LEN = 32;
        /// <summary>
        /// 最大身份证号长度
        /// </summary>
        public const int MAX_ID_NUM_LEN = 32;
        /// <summary>
        /// 最大姓名长度
        /// </summary>
        public const int MAX_ID_NAME_LEN = 128;
        /// <summary>
        /// 最大住址长度
        /// </summary>
        public const int MAX_ID_ADDR_LEN = 280;
        /// <summary>
        /// 最大签发机关长度
        /// </summary>
        public const int MAX_ID_ISSUING_AUTHORITY_LEN = 128;
        /// <summary>
        /// 卡权限最大计划个数
        /// </summary>
        public const int MAX_CARD_RIGHT_PLAN_NUM = 4;
        /// <summary>
        /// 最大群组数
        /// </summary>
        public const int MAX_GROUP_NUM_128 = 128;
        /// <summary>
        /// 最大读卡器数
        /// </summary>
        public const int MAX_CARD_READER_NUM = 64;
        /// <summary>
        /// 最大后续读卡器数
        /// </summary>
        public const int MAX_SNEAK_PATH_NODE = 8;
        /// <summary>
        /// 最大多门互锁组数
        /// </summary>
        public const int MAX_MULTI_DOOR_INTERLOCK_GROUP = 8;
        /// <summary>
        /// 一个多门互锁组中最大互锁门数
        /// </summary>
        public const int MAX_INTER_LOCK_DOOR_NUM = 8;
        /// <summary>
        /// 最大case sensor触发器数
        /// </summary>
        public const int MAX_CASE_SENSOR_NUM = 8;
        /// <summary>
        /// 最大门数
        /// </summary>
        public const int MAX_DOOR_NUM_256 = 256;
        /// <summary>
        /// 最大刷卡循序路径
        /// </summary>
        public const int MAX_READER_ROUTE_NUM = 16;
        /// <summary>
        /// 最大指纹个数
        /// </summary>
        public const int MAX_FINGER_PRINT_NUM = 10;
        /// <summary>
        /// 最大读卡器数
        /// </summary>
        public const int MAX_CARD_READER_NUM_512 = 512;
        /// <summary>
        /// 单门最大多重卡组数
        /// </summary>
        public const int NET_SDK_MULTI_CARD_GROUP_NUM_20 = 20;
        /// <summary>
        /// 卡密码长度
        /// </summary>
        public const int CARD_PASSWORD_LEN = 8;
        /// <summary>
        /// 房间代码长度
        /// </summary>
        public const int MAX_DOOR_CODE_LEN = 8;
        /// <summary>
        /// 锁代码长度
        /// </summary>
        public const int MAX_LOCK_CODE_LEN = 8;
        /// <summary>
        /// 公告编号最大长度
        /// </summary>
        public const int MAX_NOTICE_NUMBER_LEN = 32;
        /// <summary>
        /// 公告主题最大长度
        /// </summary>
        public const int MAX_NOTICE_THEME_LEN = 64;
        /// <summary>
        /// 公告详情最大长度
        /// </summary>
        public const int MAX_NOTICE_DETAIL_LEN = 1024;
        /// <summary>
        /// 公告信息最大图片数量
        /// </summary>
        public const int MAX_NOTICE_PIC_NUM = 6;
        /// <summary>
        /// 设备编号最大长度
        /// </summary>
        public const int MAX_DEV_NUMBER_LEN = 32;
        /// <summary>
        /// 锁名称
        /// </summary>
        public const int LOCK_NAME_LEN = 32;
        /// <summary>
        /// 群组名称长度
        /// </summary>
        public const int GROUP_NAME_LEN = 32;
        /// <summary>
        /// 群组组合数
        /// </summary>
        public const int GROUP_COMBINATION_NUM = 8;
        /// <summary>
        /// 单门最大多重卡组数
        /// </summary>
        public const int MULTI_CARD_GROUP_NUM = 4;
        /// <summary>
        /// 工号长度
        /// </summary>
        public const int NET_SDK_EMPLOYEE_NO_LEN = 32;
        /// <summary>
        /// UUID长度
        /// </summary>
        public const int NET_SDK_UUID_LEN = 36;
        /// <summary>
        /// EHome Key长度
        /// </summary>
        public const int NET_SDK_EHOME_KEY_LEN = 32;
        /// <summary>
        /// 设备名称长度
        /// </summary>
        public const int NET_DEV_NAME_LEN = 64;
        /// <summary>
        /// 设备类型名称长度
        /// </summary>
        public const int NET_DEV_TYPE_NAME_LEN = 64;
        /// <summary>
        /// 检测区域最多支持10个点的多边形
        /// </summary>
        public const int VCA_MAX_POLYGON_POINT_NUM = 10;
        /// <summary>
        /// 最多规则条数
        /// </summary>
        public const int MAX_RULE_NUM = 8;
        /// <summary>
        /// 最多目标个数
        /// </summary>
        public const int MAX_TARGET_NUM = 30;
        /// <summary>
        /// 最大标定点个数
        /// </summary>
        public const int MAX_CALIB_PT = 6;
        /// <summary>
        /// 最小标定点个数
        /// </summary>
        public const int MIN_CALIB_PT = 4;
        /// <summary>
        /// 最大时间段数
        /// </summary>
        public const int MAX_TIMESEGMENT_2 = 2;
        /// <summary>
        /// 车牌号最大长度
        /// </summary>
        public const int MAX_LICENSE_LEN = 16;
        /// <summary>
        /// 车牌个数
        /// </summary>
        public const int MAX_PLATE_NUM = 3;
        /// <summary>
        /// 最多四个屏蔽区域
        /// </summary>
        public const int MAX_MASK_REGION_NUM = 4;
        /// <summary>
        /// 摄像机标定最大样本线数目
        /// </summary>
        public const int MAX_SEGMENT_NUM = 6;
        /// <summary>
        /// 摄像机标定最小样本线数目
        /// </summary>
        public const int MIN_SEGMENT_NUM = 3;
        /// <summary>
        /// 车牌附加信息最大字符
        /// </summary>
        public const int MAX_CATEGORY_LEN = 8;
        /// <summary>
        /// 泊车位编号
        /// </summary>
        public const int SERIAL_NO_LEN = 16;
        /// <summary>
        /// 违法代码长度
        /// </summary>
        public const int ILLEGAL_LEN = 32;
        /// <summary>
        /// 码流连接方式
        /// </summary>
        public const int NORMALCONNECT = 1;
        public const int MEDIACONNECT = 2;
        /// <summary>
        /// 设备型号(大类)
        /// </summary>
        public const int HCDVR = 1;
        public const int MEDVR = 2;
        public const int PCDVR = 3;
        public const int HC_9000 = 4;
        public const int HF_I = 5;
        public const int PCNVR = 6;
        public const int HC_76NVR = 8;
        /// <summary>
        /// NVR类型
        /// </summary>
        public const int DS8000HC_NVR = 0;
        public const int DS9000HC_NVR = 1;
        public const int DS8000ME_NVR = 2;
        /// <summary>
        /// **************************************
        /// ***********************************************
        /// NET_DVR_IsSupport()返回值
        /// 1－9位分别表示以下信息（位与是TRUE)表示支持；
        /// ************************************************
        /// </summary>
        public const int NET_DVR_SUPPORT_DDRAW = 1;
        /// <summary>
        /// 显卡支持BLT操作，如果不支持，则播放器不能工作
        /// </summary>
        public const int NET_DVR_SUPPORT_BLT = 2;
        /// <summary>
        /// 显卡BLT支持颜色转换，如果不支持，播放器会用软件方法作RGB转换
        /// </summary>
        public const int NET_DVR_SUPPORT_BLTFOURCC = 4;
        /// <summary>
        /// 显卡BLT支持X轴缩小；如果不支持，系统会用软件方法转换
        /// </summary>
        public const int NET_DVR_SUPPORT_BLTSHRINKX = 8;
        /// <summary>
        /// 显卡BLT支持Y轴缩小；如果不支持，系统会用软件方法转换
        /// </summary>
        public const int NET_DVR_SUPPORT_BLTSHRINKY = 16;
        /// <summary>
        /// 显卡BLT支持X轴放大；如果不支持，系统会用软件方法转换
        /// </summary>
        public const int NET_DVR_SUPPORT_BLTSTRETCHX = 32;
        /// <summary>
        /// 显卡BLT支持Y轴放大；如果不支持，系统会用软件方法转换
        /// </summary>
        public const int NET_DVR_SUPPORT_BLTSTRETCHY = 64;
        /// <summary>
        /// CPU支持SSE指令，Intel Pentium3以上支持SSE指令
        /// </summary>
        public const int NET_DVR_SUPPORT_SSE = 128;
        /// <summary>
        /// CPU支持MMX指令集，Intel Pentium3以上支持SSE指令
        /// </summary>
        public const int NET_DVR_SUPPORT_MMX = 256;
        /// <summary>
        /// ********************云台控制命令 begin************************
        /// </summary>
        public const int LIGHT_PWRON = 2;
        /// <summary>
        /// 接通雨刷开关
        /// </summary>
        public const int WIPER_PWRON = 3;
        /// <summary>
        /// 接通风扇开关
        /// </summary>
        public const int FAN_PWRON = 4;
        /// <summary>
        /// 接通加热器开关
        /// </summary>
        public const int HEATER_PWRON = 5;
        /// <summary>
        /// 接通辅助设备开关
        /// </summary>
        public const int AUX_PWRON1 = 6;
        /// <summary>
        /// 接通辅助设备开关
        /// </summary>
        public const int AUX_PWRON2 = 7;
        /// <summary>
        /// 设置预置点
        /// </summary>
        public const int SET_PRESET = 8;
        /// <summary>
        /// 清除预置点
        /// </summary>
        public const int CLE_PRESET = 9;
        /// <summary>
        /// 焦距以速度SS变大(倍率变大)
        /// </summary>
        public const int ZOOM_IN = 11;
        /// <summary>
        /// 焦距以速度SS变小(倍率变小)
        /// </summary>
        public const int ZOOM_OUT = 12;
        /// <summary>
        /// 焦点以速度SS前调
        /// </summary>
        public const int FOCUS_NEAR = 13;
        /// <summary>
        /// 焦点以速度SS后调
        /// </summary>
        public const int FOCUS_FAR = 14;
        /// <summary>
        /// 光圈以速度SS扩大
        /// </summary>
        public const int IRIS_OPEN = 15;
        /// <summary>
        /// 光圈以速度SS缩小
        /// </summary>
        public const int IRIS_CLOSE = 16;
        /// <summary>
        /// 云台以SS的速度上仰
        /// </summary>
        public const int TILT_UP = 21;
        /// <summary>
        /// 云台以SS的速度下俯
        /// </summary>
        public const int TILT_DOWN = 22;
        /// <summary>
        /// 云台以SS的速度左转
        /// </summary>
        public const int PAN_LEFT = 23;
        /// <summary>
        /// 云台以SS的速度右转
        /// </summary>
        public const int PAN_RIGHT = 24;
        /// <summary>
        /// 云台以SS的速度上仰和左转
        /// </summary>
        public const int UP_LEFT = 25;
        /// <summary>
        /// 云台以SS的速度上仰和右转
        /// </summary>
        public const int UP_RIGHT = 26;
        /// <summary>
        /// 云台以SS的速度下俯和左转
        /// </summary>
        public const int DOWN_LEFT = 27;
        /// <summary>
        /// 云台以SS的速度下俯和右转
        /// </summary>
        public const int DOWN_RIGHT = 28;
        /// <summary>
        /// 云台以SS的速度左右自动扫描
        /// </summary>
        public const int PAN_AUTO = 29;
        /// <summary>
        /// 将预置点加入巡航序列
        /// </summary>
        public const int FILL_PRE_SEQ = 30;
        /// <summary>
        /// 设置巡航点停顿时间
        /// </summary>
        public const int SET_SEQ_DWELL = 31;
        /// <summary>
        /// 设置巡航速度
        /// </summary>
        public const int SET_SEQ_SPEED = 32;
        /// <summary>
        /// 将预置点从巡航序列中删除
        /// </summary>
        public const int CLE_PRE_SEQ = 33;
        /// <summary>
        /// 开始记录
        /// </summary>
        public const int STA_MEM_CRUISE = 34;
        /// <summary>
        /// 停止记录
        /// </summary>
        public const int STO_MEM_CRUISE = 35;
        /// <summary>
        /// 开始
        /// </summary>
        public const int RUN_CRUISE = 36;
        /// <summary>
        /// 开始巡航
        /// </summary>
        public const int RUN_SEQ = 37;
        /// <summary>
        /// 停止巡航
        /// </summary>
        public const int STOP_SEQ = 38;
        /// <summary>
        /// 快球转到预置点
        /// </summary>
        public const int GOTO_PRESET = 39;
        /// <summary>
        /// ********************云台控制命令 end************************
        /// ***********************************************
        /// 回放时播放控制命令宏定义
        /// NET_DVR_PlayBackControl
        /// NET_DVR_PlayControlLocDisplay
        /// NET_DVR_DecPlayBackCtrl的宏定义
        /// 具体支持查看函数说明和代码
        /// ************************************************
        /// </summary>
        public const int NET_DVR_PLAYSTART = 1;
        /// <summary>
        /// 停止播放
        /// </summary>
        public const int NET_DVR_PLAYSTOP = 2;
        /// <summary>
        /// 暂停播放
        /// </summary>
        public const int NET_DVR_PLAYPAUSE = 3;
        /// <summary>
        /// 恢复播放
        /// </summary>
        public const int NET_DVR_PLAYRESTART = 4;
        /// <summary>
        /// 快放
        /// </summary>
        public const int NET_DVR_PLAYFAST = 5;
        /// <summary>
        /// 慢放
        /// </summary>
        public const int NET_DVR_PLAYSLOW = 6;
        /// <summary>
        /// 正常速度
        /// </summary>
        public const int NET_DVR_PLAYNORMAL = 7;
        /// <summary>
        /// 单帧放
        /// </summary>
        public const int NET_DVR_PLAYFRAME = 8;
        /// <summary>
        /// 打开声音
        /// </summary>
        public const int NET_DVR_PLAYSTARTAUDIO = 9;
        /// <summary>
        /// 关闭声音
        /// </summary>
        public const int NET_DVR_PLAYSTOPAUDIO = 10;
        /// <summary>
        /// 调节音量
        /// </summary>
        public const int NET_DVR_PLAYAUDIOVOLUME = 11;
        /// <summary>
        /// 改变文件回放的进度
        /// </summary>
        public const int NET_DVR_PLAYSETPOS = 12;
        /// <summary>
        /// 获取文件回放的进度
        /// </summary>
        public const int NET_DVR_PLAYGETPOS = 13;
        /// <summary>
        /// 获取当前已经播放的时间(按文件回放的时候有效)
        /// </summary>
        public const int NET_DVR_PLAYGETTIME = 14;
        /// <summary>
        /// 获取当前已经播放的帧数(按文件回放的时候有效)
        /// </summary>
        public const int NET_DVR_PLAYGETFRAME = 15;
        /// <summary>
        /// 获取当前播放文件总的帧数(按文件回放的时候有效)
        /// </summary>
        public const int NET_DVR_GETTOTALFRAMES = 16;
        /// <summary>
        /// 获取当前播放文件总的时间(按文件回放的时候有效)
        /// </summary>
        public const int NET_DVR_GETTOTALTIME = 17;
        /// <summary>
        /// 丢B帧
        /// </summary>
        public const int NET_DVR_THROWBFRAME = 20;
        /// <summary>
        /// 设置码流速度
        /// </summary>
        public const int NET_DVR_SETSPEED = 24;
        /// <summary>
        /// 保持与设备的心跳(如果回调阻塞，建议2秒发送一次)
        /// </summary>
        public const int NET_DVR_KEEPALIVE = 25;
        /// <summary>
        /// 按绝对时间定位
        /// </summary>
        public const int NET_DVR_PLAYSETTIME = 26;
        /// <summary>
        /// 获取按时间回放对应时间段内的所有文件的总长度
        /// </summary>
        public const int NET_DVR_PLAYGETTOTALLEN = 27;
        /// <summary>
        /// 倒放切换为正放
        /// </summary>
        public const int NET_DVR_PLAY_FORWARD = 29;
        /// <summary>
        /// 正放切换为倒放
        /// </summary>
        public const int NET_DVR_PLAY_REVERSE = 30;
        /// <summary>
        /// 设置转封装类型
        /// </summary>
        public const int NET_DVR_SET_TRANS_TYPE = 32;
        /// <summary>
        /// 正放切换为倒放
        /// </summary>
        public const int NET_DVR_PLAY_CONVERT = 33;
        /// <summary>
        /// 远程按键定义如下：
        /// key value send to CONFIG program
        /// </summary>
        public const int KEY_CODE_1 = 1;
        public const int KEY_CODE_2 = 2;
        public const int KEY_CODE_3 = 3;
        public const int KEY_CODE_4 = 4;
        public const int KEY_CODE_5 = 5;
        public const int KEY_CODE_6 = 6;
        public const int KEY_CODE_7 = 7;
        public const int KEY_CODE_8 = 8;
        public const int KEY_CODE_9 = 9;
        public const int KEY_CODE_0 = 10;
        public const int KEY_CODE_POWER = 11;
        public const int KEY_CODE_MENU = 12;
        public const int KEY_CODE_ENTER = 13;
        public const int KEY_CODE_CANCEL = 14;
        public const int KEY_CODE_UP = 15;
        public const int KEY_CODE_DOWN = 16;
        public const int KEY_CODE_LEFT = 17;
        public const int KEY_CODE_RIGHT = 18;
        public const int KEY_CODE_EDIT = 19;
        public const int KEY_CODE_ADD = 20;
        public const int KEY_CODE_MINUS = 21;
        public const int KEY_CODE_PLAY = 22;
        public const int KEY_CODE_REC = 23;
        public const int KEY_CODE_PAN = 24;
        public const int KEY_CODE_M = 25;
        public const int KEY_CODE_A = 26;
        public const int KEY_CODE_F1 = 27;
        public const int KEY_CODE_F2 = 28;
        /// <summary>
        /// for PTZ control
        /// </summary>
        public const int KEY_PTZ_UP_START = KEY_CODE_UP;
        public const int KEY_PTZ_UP_STOP = 32;
        public const int KEY_PTZ_DOWN_START = KEY_CODE_DOWN;
        public const int KEY_PTZ_DOWN_STOP = 33;
        public const int KEY_PTZ_LEFT_START = KEY_CODE_LEFT;
        public const int KEY_PTZ_LEFT_STOP = 34;
        public const int KEY_PTZ_RIGHT_START = KEY_CODE_RIGHT;
        public const int KEY_PTZ_RIGHT_STOP = 35;
        /// <summary>
        /// 光圈+
        /// </summary>
        public const int KEY_PTZ_AP1_START = KEY_CODE_EDIT;
        public const int KEY_PTZ_AP1_STOP = 36;
        /// <summary>
        /// 光圈-
        /// </summary>
        public const int KEY_PTZ_AP2_START = KEY_CODE_PAN;
        public const int KEY_PTZ_AP2_STOP = 37;
        /// <summary>
        /// 聚焦+
        /// </summary>
        public const int KEY_PTZ_FOCUS1_START = KEY_CODE_A;
        public const int KEY_PTZ_FOCUS1_STOP = 38;
        /// <summary>
        /// 聚焦-
        /// </summary>
        public const int KEY_PTZ_FOCUS2_START = KEY_CODE_M;
        public const int KEY_PTZ_FOCUS2_STOP = 39;
        /// <summary>
        /// 变倍+
        /// </summary>
        public const int KEY_PTZ_B1_START = 40;
        public const int KEY_PTZ_B1_STOP = 41;
        /// <summary>
        /// 变倍-
        /// </summary>
        public const int KEY_PTZ_B2_START = 42;
        public const int KEY_PTZ_B2_STOP = 43;
        /// <summary>
        /// 9000新增
        /// </summary>
        public const int KEY_CODE_11 = 44;
        public const int KEY_CODE_12 = 45;
        public const int KEY_CODE_13 = 46;
        public const int KEY_CODE_14 = 47;
        public const int KEY_CODE_15 = 48;
        public const int KEY_CODE_16 = 49;
        /// <summary>
        /// ***********************参数配置命令 begin******************************
        /// 用于NET_DVR_SetDVRConfig和NET_DVR_GetDVRConfig,注意其对应的配置结构
        /// </summary>
        public const int NET_DVR_GET_DEVICECFG = 100;
        /// <summary>
        /// 设置设备参数
        /// </summary>
        public const int NET_DVR_SET_DEVICECFG = 101;
        /// <summary>
        /// 获取网络参数
        /// </summary>
        public const int NET_DVR_GET_NETCFG = 102;
        /// <summary>
        /// 设置网络参数
        /// </summary>
        public const int NET_DVR_SET_NETCFG = 103;
        /// <summary>
        /// 获取图象参数
        /// </summary>
        public const int NET_DVR_GET_PICCFG = 104;
        /// <summary>
        /// 设置图象参数
        /// </summary>
        public const int NET_DVR_SET_PICCFG = 105;
        /// <summary>
        /// 获取压缩参数
        /// </summary>
        public const int NET_DVR_GET_COMPRESSCFG = 106;
        /// <summary>
        /// 设置压缩参数
        /// </summary>
        public const int NET_DVR_SET_COMPRESSCFG = 107;
        /// <summary>
        /// 获取录像时间参数
        /// </summary>
        public const int NET_DVR_GET_RECORDCFG = 108;
        /// <summary>
        /// 设置录像时间参数
        /// </summary>
        public const int NET_DVR_SET_RECORDCFG = 109;
        /// <summary>
        /// 获取解码器参数
        /// </summary>
        public const int NET_DVR_GET_DECODERCFG = 110;
        /// <summary>
        /// 设置解码器参数
        /// </summary>
        public const int NET_DVR_SET_DECODERCFG = 111;
        /// <summary>
        /// 获取232串口参数
        /// </summary>
        public const int NET_DVR_GET_RS232CFG = 112;
        /// <summary>
        /// 设置232串口参数
        /// </summary>
        public const int NET_DVR_SET_RS232CFG = 113;
        /// <summary>
        /// 获取报警输入参数
        /// </summary>
        public const int NET_DVR_GET_ALARMINCFG = 114;
        /// <summary>
        /// 设置报警输入参数
        /// </summary>
        public const int NET_DVR_SET_ALARMINCFG = 115;
        /// <summary>
        /// 获取报警输出参数
        /// </summary>
        public const int NET_DVR_GET_ALARMOUTCFG = 116;
        /// <summary>
        /// 设置报警输出参数
        /// </summary>
        public const int NET_DVR_SET_ALARMOUTCFG = 117;
        /// <summary>
        /// 获取DVR时间
        /// </summary>
        public const int NET_DVR_GET_TIMECFG = 118;
        /// <summary>
        /// 设置DVR时间
        /// </summary>
        public const int NET_DVR_SET_TIMECFG = 119;
        /// <summary>
        /// 获取预览参数
        /// </summary>
        public const int NET_DVR_GET_PREVIEWCFG = 120;
        /// <summary>
        /// 设置预览参数
        /// </summary>
        public const int NET_DVR_SET_PREVIEWCFG = 121;
        /// <summary>
        /// 获取视频输出参数
        /// </summary>
        public const int NET_DVR_GET_VIDEOOUTCFG = 122;
        /// <summary>
        /// 设置视频输出参数
        /// </summary>
        public const int NET_DVR_SET_VIDEOOUTCFG = 123;
        /// <summary>
        /// 获取用户参数
        /// </summary>
        public const int NET_DVR_GET_USERCFG = 124;
        /// <summary>
        /// 设置用户参数
        /// </summary>
        public const int NET_DVR_SET_USERCFG = 125;
        /// <summary>
        /// 获取异常参数
        /// </summary>
        public const int NET_DVR_GET_EXCEPTIONCFG = 126;
        /// <summary>
        /// 设置异常参数
        /// </summary>
        public const int NET_DVR_SET_EXCEPTIONCFG = 127;
        /// <summary>
        /// 获取时区和夏时制参数
        /// </summary>
        public const int NET_DVR_GET_ZONEANDDST = 128;
        /// <summary>
        /// 设置时区和夏时制参数
        /// </summary>
        public const int NET_DVR_SET_ZONEANDDST = 129;
        /// <summary>
        /// 获取叠加字符参数
        /// </summary>
        public const int NET_DVR_GET_SHOWSTRING = 130;
        /// <summary>
        /// 设置叠加字符参数
        /// </summary>
        public const int NET_DVR_SET_SHOWSTRING = 131;
        /// <summary>
        /// 获取事件触发录像参数
        /// </summary>
        public const int NET_DVR_GET_EVENTCOMPCFG = 132;
        /// <summary>
        /// 设置事件触发录像参数
        /// </summary>
        public const int NET_DVR_SET_EVENTCOMPCFG = 133;
        /// <summary>
        /// 获取报警触发辅助输出设置(HS设备辅助输出2006-02-28)
        /// </summary>
        public const int NET_DVR_GET_AUXOUTCFG = 140;
        /// <summary>
        /// 设置报警触发辅助输出设置(HS设备辅助输出2006-02-28)
        /// </summary>
        public const int NET_DVR_SET_AUXOUTCFG = 141;
        /// <summary>
        /// 获取-s系列双输出预览参数(-s系列双输出2006-04-13)
        /// </summary>
        public const int NET_DVR_GET_PREVIEWCFG_AUX = 142;
        /// <summary>
        /// 设置-s系列双输出预览参数(-s系列双输出2006-04-13)
        /// </summary>
        public const int NET_DVR_SET_PREVIEWCFG_AUX = 143;
        /// <summary>
        /// 获取图象参数(SDK_V14扩展命令)
        /// </summary>
        public const int NET_DVR_GET_PICCFG_EX = 200;
        /// <summary>
        /// 设置图象参数(SDK_V14扩展命令)
        /// </summary>
        public const int NET_DVR_SET_PICCFG_EX = 201;
        /// <summary>
        /// 获取用户参数(SDK_V15扩展命令)
        /// </summary>
        public const int NET_DVR_GET_USERCFG_EX = 202;
        /// <summary>
        /// 设置用户参数(SDK_V15扩展命令)
        /// </summary>
        public const int NET_DVR_SET_USERCFG_EX = 203;
        /// <summary>
        /// 获取压缩参数(SDK_V15扩展命令2006-05-15)
        /// </summary>
        public const int NET_DVR_GET_COMPRESSCFG_EX = 204;
        /// <summary>
        /// 设置压缩参数(SDK_V15扩展命令2006-05-15)
        /// </summary>
        public const int NET_DVR_SET_COMPRESSCFG_EX = 205;
        /// <summary>
        /// 获取网络应用参数 NTP/DDNS/EMAIL
        /// </summary>
        public const int NET_DVR_GET_NETAPPCFG = 222;
        /// <summary>
        /// 设置网络应用参数 NTP/DDNS/EMAIL
        /// </summary>
        public const int NET_DVR_SET_NETAPPCFG = 223;
        /// <summary>
        /// 获取网络应用参数 NTP
        /// </summary>
        public const int NET_DVR_GET_NTPCFG = 224;
        /// <summary>
        /// 设置网络应用参数 NTP
        /// </summary>
        public const int NET_DVR_SET_NTPCFG = 225;
        /// <summary>
        /// 获取网络应用参数 DDNS
        /// </summary>
        public const int NET_DVR_GET_DDNSCFG = 226;
        /// <summary>
        /// 设置网络应用参数 DDNS
        /// </summary>
        public const int NET_DVR_SET_DDNSCFG = 227;
        /// <summary>
        /// 对应NET_DVR_EMAILPARA
        /// </summary>
        public const int NET_DVR_GET_EMAILCFG = 228;
        /// <summary>
        /// 设置网络应用参数 EMAIL
        /// </summary>
        public const int NET_DVR_SET_EMAILCFG = 229;
        /// <summary>
        /// NFS disk config
        /// </summary>
        public const int NET_DVR_GET_NFSCFG = 230;
        /// <summary>
        /// NFS disk config
        /// </summary>
        public const int NET_DVR_SET_NFSCFG = 231;
        /// <summary>
        /// 获取叠加字符参数扩展(支持8条字符)
        /// </summary>
        public const int NET_DVR_GET_SHOWSTRING_EX = 238;
        /// <summary>
        /// 设置叠加字符参数扩展(支持8条字符)
        /// </summary>
        public const int NET_DVR_SET_SHOWSTRING_EX = 239;
        /// <summary>
        /// 获取网络参数
        /// </summary>
        public const int NET_DVR_GET_NETCFG_OTHER = 244;
        /// <summary>
        /// 设置网络参数
        /// </summary>
        public const int NET_DVR_SET_NETCFG_OTHER = 245;
        /// <summary>
        /// 对应NET_DVR_EMAILCFG结构
        /// </summary>
        public const int NET_DVR_GET_EMAILPARACFG = 250;
        /// <summary>
        /// Setup EMAIL parameters
        /// </summary>
        public const int NET_DVR_SET_EMAILPARACFG = 251;
        /// <summary>
        /// 获取扩展DDNS参数
        /// </summary>
        public const int NET_DVR_GET_DDNSCFG_EX = 274;
        /// <summary>
        /// 设置扩展DDNS参数
        /// </summary>
        public const int NET_DVR_SET_DDNSCFG_EX = 275;
        /// <summary>
        /// 云台设置PTZ位置
        /// </summary>
        public const int NET_DVR_SET_PTZPOS = 292;
        /// <summary>
        /// 云台获取PTZ位置
        /// </summary>
        public const int NET_DVR_GET_PTZPOS = 293;
        /// <summary>
        /// 云台获取PTZ范围
        /// </summary>
        public const int NET_DVR_GET_PTZSCOPE = 294;
        /// <summary>
        /// 获取无线网络资源参数
        /// </summary>
        public const int NET_DVR_GET_AP_INFO_LIST = 305;
        /// <summary>
        /// 设置IP布防设备无线参数
        /// </summary>
        public const int NET_DVR_SET_WIFI_CFG = 306;
        /// <summary>
        /// 获取IP布防设备无线参数
        /// </summary>
        public const int NET_DVR_GET_WIFI_CFG = 307;
        /// <summary>
        /// 设置IP布防设备网口工作模式参数
        /// </summary>
        public const int NET_DVR_SET_WIFI_WORKMODE = 308;
        /// <summary>
        /// 获取IP布防设备网口工作模式参数
        /// </summary>
        public const int NET_DVR_GET_WIFI_WORKMODE = 309;
        /// <summary>
        /// 获取设备当前wifi连接状态
        /// </summary>
        public const int NET_DVR_GET_WIFI_STATUS = 310;
        /// <summary>
        /// *************************智能服务器 begin ****************************
        /// 智能设备类型
        /// </summary>
        public const int DS6001_HF_B = 60;
        /// <summary>
        /// 车牌识别：DS6001-HF/P
        /// </summary>
        public const int DS6001_HF_P = 61;
        /// <summary>
        /// 双机：DS6002-HF/B
        /// </summary>
        public const int DS6002_HF_B = 62;
        /// <summary>
        /// 异常行为识别：DS6101-HF/B
        /// </summary>
        public const int DS6101_HF_B = 63;
        /// <summary>
        /// 智能分析仪IVMS
        /// </summary>
        public const int IDS52XX = 64;
        /// <summary>
        /// 9000系列智能DVR
        /// </summary>
        public const int DS9000_IVS = 65;
        /// <summary>
        /// 智能ATM, DS8004AHL-S/A
        /// </summary>
        public const int DS8004_AHL_A = 66;
        /// <summary>
        /// 车牌识别：DS6101-HF/P
        /// </summary>
        public const int DS6101_HF_P = 67;
        /// <summary>
        /// 能力获取命令
        /// </summary>
        public const int VCA_DEV_ABILITY = 256;
        /// <summary>
        /// 异常行为识别能力
        /// </summary>
        public const int VCA_CHAN_ABILITY = 272;
        /// <summary>
        /// 多路解码器显示、解码能力
        /// </summary>
        public const int MATRIXDECODER_ABILITY = 512;
        /// <summary>
        /// 获取/设置大接口参数配置命令
        /// 车牌识别（NET_VCA_PLATE_CFG）
        /// </summary>
        public const int NET_DVR_SET_PLATECFG = 150;
        /// <summary>
        /// 获取车牌识别参数
        /// </summary>
        public const int NET_DVR_GET_PLATECFG = 151;
        /// <summary>
        /// 行为对应（NET_VCA_RULECFG）
        /// </summary>
        public const int NET_DVR_SET_RULECFG = 152;
        /// <summary>
        /// 获取异常行为识别规则
        /// </summary>
        public const int NET_DVR_GET_RULECFG = 153;
        /// <summary>
        /// 双摄像机标定参数（NET_DVR_LF_CFG）
        /// </summary>
        public const int NET_DVR_SET_LF_CFG = 160;
        /// <summary>
        /// 获取双摄像机的配置参数
        /// </summary>
        public const int NET_DVR_GET_LF_CFG = 161;
        /// <summary>
        /// 智能分析仪取流配置结构
        /// </summary>
        public const int NET_DVR_SET_IVMS_STREAMCFG = 162;
        /// <summary>
        /// 获取智能分析仪取流参数
        /// </summary>
        public const int NET_DVR_GET_IVMS_STREAMCFG = 163;
        /// <summary>
        /// 智能控制参数结构
        /// </summary>
        public const int NET_DVR_SET_VCA_CTRLCFG = 164;
        /// <summary>
        /// 获取智能控制参数
        /// </summary>
        public const int NET_DVR_GET_VCA_CTRLCFG = 165;
        /// <summary>
        /// 屏蔽区域NET_VCA_MASK_REGION_LIST
        /// </summary>
        public const int NET_DVR_SET_VCA_MASK_REGION = 166;
        /// <summary>
        /// 获取屏蔽区域参数
        /// </summary>
        public const int NET_DVR_GET_VCA_MASK_REGION = 167;
        /// <summary>
        /// ATM进入区域 NET_VCA_ENTER_REGION
        /// </summary>
        public const int NET_DVR_SET_VCA_ENTER_REGION = 168;
        /// <summary>
        /// 获取进入区域参数
        /// </summary>
        public const int NET_DVR_GET_VCA_ENTER_REGION = 169;
        /// <summary>
        /// 标定线配置NET_VCA_LINE_SEGMENT_LIST
        /// </summary>
        public const int NET_DVR_SET_VCA_LINE_SEGMENT = 170;
        /// <summary>
        /// 获取标定线
        /// </summary>
        public const int NET_DVR_GET_VCA_LINE_SEGMENT = 171;
        /// <summary>
        /// ivms屏蔽区域NET_IVMS_MASK_REGION_LIST
        /// </summary>
        public const int NET_DVR_SET_IVMS_MASK_REGION = 172;
        /// <summary>
        /// 获取IVMS屏蔽区域参数
        /// </summary>
        public const int NET_DVR_GET_IVMS_MASK_REGION = 173;
        /// <summary>
        /// ivms进入检测区域NET_IVMS_ENTER_REGION
        /// </summary>
        public const int NET_DVR_SET_IVMS_ENTER_REGION = 174;
        /// <summary>
        /// 获取IVMS进入区域参数
        /// </summary>
        public const int NET_DVR_GET_IVMS_ENTER_REGION = 175;
        /// <summary>
        /// 设置智能分析仪行为规则参数
        /// </summary>
        public const int NET_DVR_SET_IVMS_BEHAVIORCFG = 176;
        /// <summary>
        /// 获取智能分析仪行为规则参数
        /// </summary>
        public const int NET_DVR_GET_IVMS_BEHAVIORCFG = 177;
        /// <summary>
        /// IVMS 回放检索
        /// </summary>
        public const int NET_DVR_IVMS_SET_SEARCHCFG = 178;
        /// <summary>
        /// 获取IVMS回放检索参数
        /// </summary>
        public const int NET_DVR_IVMS_GET_SEARCHCFG = 179;
        /// <summary>
        /// *************************DS9000新增命令(_V30) begin ****************************
        /// 网络(NET_DVR_NETCFG_V30结构)
        /// </summary>
        public const int NET_DVR_GET_NETCFG_V30 = 1000;
        /// <summary>
        /// 设置网络参数
        /// </summary>
        public const int NET_DVR_SET_NETCFG_V30 = 1001;
        /// <summary>
        /// 图象(NET_DVR_PICCFG_V30结构)
        /// </summary>
        public const int NET_DVR_GET_PICCFG_V30 = 1002;
        /// <summary>
        /// 设置图象参数
        /// </summary>
        public const int NET_DVR_SET_PICCFG_V30 = 1003;
        /// <summary>
        /// 图象(NET_DVR_PICCFG_V40结构)
        /// </summary>
        public const int NET_DVR_GET_PICCFG_V40 = 6179;
        /// <summary>
        /// 设置图象参数V40扩展
        /// </summary>
        public const int NET_DVR_SET_PICCFG_V40 = 6180;
        /// <summary>
        /// 录像时间(NET_DVR_RECORD_V30结构)
        /// </summary>
        public const int NET_DVR_GET_RECORDCFG_V30 = 1004;
        /// <summary>
        /// 设置录像参数
        /// </summary>
        public const int NET_DVR_SET_RECORDCFG_V30 = 1005;
        /// <summary>
        /// 获取录像参数(扩展)
        /// </summary>
        public const int NET_DVR_GET_RECORDCFG_V40 = 1008;
        /// <summary>
        /// 设置录像参数(扩展)
        /// </summary>
        public const int NET_DVR_SET_RECORDCFG_V40 = 1009;
        /// <summary>
        /// 用户(NET_DVR_USER_V30结构)
        /// </summary>
        public const int NET_DVR_GET_USERCFG_V30 = 1006;
        /// <summary>
        /// 设置用户参数
        /// </summary>
        public const int NET_DVR_SET_USERCFG_V30 = 1007;
        /// <summary>
        /// 9000DDNS参数配置(NET_DVR_DDNSPARA_V30结构)
        /// </summary>
        public const int NET_DVR_GET_DDNSCFG_V30 = 1010;
        /// <summary>
        /// 设置DDNS(9000扩展)
        /// </summary>
        public const int NET_DVR_SET_DDNSCFG_V30 = 1011;
        /// <summary>
        /// EMAIL功能(NET_DVR_EMAILCFG_V30结构)
        /// </summary>
        public const int NET_DVR_GET_EMAILCFG_V30 = 1012;
        /// <summary>
        /// 设置EMAIL参数
        /// </summary>
        public const int NET_DVR_SET_EMAILCFG_V30 = 1013;
        /// <summary>
        /// 巡航参数 (NET_DVR_CRUISE_PARA结构)
        /// </summary>
        public const int NET_DVR_GET_CRUISE = 1020;
        public const int NET_DVR_SET_CRUISE = 1021;
        /// <summary>
        /// 报警输入结构参数 (NET_DVR_ALARMINCFG_V30结构)
        /// </summary>
        public const int NET_DVR_GET_ALARMINCFG_V30 = 1024;
        public const int NET_DVR_SET_ALARMINCFG_V30 = 1025;
        /// <summary>
        /// 报警输出结构参数 (NET_DVR_ALARMOUTCFG_V30结构)
        /// </summary>
        public const int NET_DVR_GET_ALARMOUTCFG_V30 = 1026;
        public const int NET_DVR_SET_ALARMOUTCFG_V30 = 1027;
        /// <summary>
        /// 视频输出结构参数 (NET_DVR_VIDEOOUT_V30结构)
        /// </summary>
        public const int NET_DVR_GET_VIDEOOUTCFG_V30 = 1028;
        public const int NET_DVR_SET_VIDEOOUTCFG_V30 = 1029;
        /// <summary>
        /// 获取前端参数
        /// </summary>
        public const int NET_DVR_GET_CCDPARAMCFG_EX = 3368;
        /// <summary>
        /// 设置CCD参数配置
        /// </summary>
        public const int NET_DVR_SET_CCDPARAMCFG_EX = 3369;
        /// <summary>
        /// 叠加字符结构参数 (NET_DVR_SHOWSTRING_V30结构)
        /// </summary>
        public const int NET_DVR_GET_SHOWSTRING_V30 = 1030;
        public const int NET_DVR_SET_SHOWSTRING_V30 = 1031;
        /// <summary>
        /// 异常结构参数 (NET_DVR_EXCEPTION_V30结构)
        /// </summary>
        public const int NET_DVR_GET_EXCEPTIONCFG_V30 = 1034;
        public const int NET_DVR_SET_EXCEPTIONCFG_V30 = 1035;
        /// <summary>
        /// 串口232结构参数 (NET_DVR_RS232CFG_V30结构)
        /// </summary>
        public const int NET_DVR_GET_RS232CFG_V30 = 1036;
        public const int NET_DVR_SET_RS232CFG_V30 = 1037;
        /// <summary>
        /// 网络硬盘接入结构参数 (NET_DVR_NET_DISKCFG结构)
        /// </summary>
        public const int NET_DVR_GET_NET_DISKCFG = 1038;
        /// <summary>
        /// 网络硬盘接入设置
        /// </summary>
        public const int NET_DVR_SET_NET_DISKCFG = 1039;
        /// <summary>
        /// 压缩参数 (NET_DVR_COMPRESSIONCFG_V30结构)
        /// </summary>
        public const int NET_DVR_GET_COMPRESSCFG_V30 = 1040;
        public const int NET_DVR_SET_COMPRESSCFG_V30 = 1041;
        /// <summary>
        /// 获取485解码器参数 (NET_DVR_DECODERCFG_V30结构)
        /// </summary>
        public const int NET_DVR_GET_DECODERCFG_V30 = 1042;
        /// <summary>
        /// 设置解码器参数
        /// </summary>
        public const int NET_DVR_SET_DECODERCFG_V30 = 1043;
        /// <summary>
        /// 获取预览参数 (NET_DVR_PREVIEWCFG_V30结构)
        /// </summary>
        public const int NET_DVR_GET_PREVIEWCFG_V30 = 1044;
        /// <summary>
        /// 设置预览参数
        /// </summary>
        public const int NET_DVR_SET_PREVIEWCFG_V30 = 1045;
        /// <summary>
        /// 辅助预览参数 (NET_DVR_PREVIEWCFG_AUX_V30结构)
        /// </summary>
        public const int NET_DVR_GET_PREVIEWCFG_AUX_V30 = 1046;
        /// <summary>
        /// 设置辅助预览参数
        /// </summary>
        public const int NET_DVR_SET_PREVIEWCFG_AUX_V30 = 1047;
        /// <summary>
        /// IP接入配置参数 （NET_DVR_IPPARACFG结构）
        /// </summary>
        public const int NET_DVR_GET_IPPARACFG = 1048;
        /// <summary>
        /// 设置IP接入配置信息
        /// </summary>
        public const int NET_DVR_SET_IPPARACFG = 1049;
        /// <summary>
        /// IP接入配置参数 （NET_DVR_IPPARACFG_V40结构）
        /// </summary>
        public const int NET_DVR_GET_IPPARACFG_V40 = 1062;
        /// <summary>
        /// 设置IP接入配置信息
        /// </summary>
        public const int NET_DVR_SET_IPPARACFG_V40 = 1063;
        /// <summary>
        /// IP报警输入接入配置参数 （NET_DVR_IPALARMINCFG结构）
        /// </summary>
        public const int NET_DVR_GET_IPALARMINCFG = 1050;
        /// <summary>
        /// 设置IP报警输入接入配置信息
        /// </summary>
        public const int NET_DVR_SET_IPALARMINCFG = 1051;
        /// <summary>
        /// IP报警输出接入配置参数 （NET_DVR_IPALARMOUTCFG结构）
        /// </summary>
        public const int NET_DVR_GET_IPALARMOUTCFG = 1052;
        /// <summary>
        /// 设置IP报警输出接入配置信息
        /// </summary>
        public const int NET_DVR_SET_IPALARMOUTCFG = 1053;
        /// <summary>
        /// 硬盘管理的参数获取 (NET_DVR_HDCFG结构)
        /// </summary>
        public const int NET_DVR_GET_HDCFG = 1054;
        /// <summary>
        /// 设置硬盘管理配置参数
        /// </summary>
        public const int NET_DVR_SET_HDCFG = 1055;
        /// <summary>
        /// 盘组管理的参数获取 (NET_DVR_HDGROUP_CFG结构)
        /// </summary>
        public const int NET_DVR_GET_HDGROUP_CFG = 1056;
        /// <summary>
        /// 设置盘组管理配置参数
        /// </summary>
        public const int NET_DVR_SET_HDGROUP_CFG = 1057;
        /// <summary>
        /// 设备编码类型配置(NET_DVR_COMPRESSION_AUDIO结构)
        /// </summary>
        public const int NET_DVR_GET_COMPRESSCFG_AUD = 1058;
        /// <summary>
        /// 设置设备语音对讲编码参数
        /// </summary>
        public const int NET_DVR_SET_COMPRESSCFG_AUD = 1059;
        /// <summary>
        /// IP接入配置参数 （NET_DVR_IPPARACFG_V31结构）
        /// </summary>
        public const int NET_DVR_GET_IPPARACFG_V31 = 1060;
        /// <summary>
        /// 设置IP接入配置信息
        /// </summary>
        public const int NET_DVR_SET_IPPARACFG_V31 = 1061;
        /// <summary>
        /// 设备参数配置 （NET_DVR_DEVICECFG_V40结构）
        /// </summary>
        public const int NET_DVR_GET_DEVICECFG_V40 = 1100;
        /// <summary>
        /// 设置设备参数
        /// </summary>
        public const int NET_DVR_SET_DEVICECFG_V40 = 1101;
        /// <summary>
        /// 多网卡配置(NET_DVR_NETCFG_MULTI结构)
        /// </summary>
        public const int NET_DVR_GET_NETCFG_MULTI = 1161;
        public const int NET_DVR_SET_NETCFG_MULTI = 1162;
        /// <summary>
        /// BONDING网卡(NET_DVR_NETWORK_BONDING结构)
        /// </summary>
        public const int NET_DVR_GET_NETWORK_BONDING = 1254;
        public const int NET_DVR_SET_NETWORK_BONDING = 1255;
        /// <summary>
        /// 人脸比对库配置
        /// </summary>
        public const int NET_DVR_GET_FACELIB_TRIGGER = 3962;
        /// <summary>
        /// 设置人脸比对库的联动配置
        /// </summary>
        public const int NET_DVR_SET_FACELIB_TRIGGER = 3963;
        /// <summary>
        /// 获取人脸比对库的布防时间配置
        /// </summary>
        public const int NET_DVR_GET_FACELIB_SCHEDULE = 3977;
        /// <summary>
        /// 设置人脸比对库的布防时间配置
        /// </summary>
        public const int NET_DVR_SET_FACELIB_SCHEDULE = 3978;
        /// <summary>
        /// NAT映射配置参数 （NET_DVR_NAT_CFG结构）
        /// </summary>
        public const int NET_DVR_GET_NAT_CFG = 6111;
        /// <summary>
        /// 设置NAT映射参数
        /// </summary>
        public const int NET_DVR_SET_NAT_CFG = 6112;
        /// <summary>
        /// 电视墙
        /// </summary>
        public const int NET_DVR_SET_WINCFG = 1202;
        /// <summary>
        /// 获取大屏拼接参数
        /// </summary>
        public const int NET_DVR_MATRIX_BIGSCREENCFG_GET = 1140;
        /// <summary>
        /// 设置大屏拼接参数
        /// </summary>
        public const int NET_DVR_MATRIX_BIGSCREENCFG_SET = 1141;
        /// <summary>
        /// 获取电视墙中屏幕参数
        /// </summary>
        public const int NET_DVR_MATRIX_WALL_GET = 9002;
        /// <summary>
        /// 设置电视墙中屏幕参数
        /// </summary>
        public const int NET_DVR_MATRIX_WALL_SET = 9001;
        /// <summary>
        /// 获取电视墙窗口参数
        /// </summary>
        public const int NET_DVR_WALLWIN_GET = 9003;
        /// <summary>
        /// 设置电视墙窗口参数
        /// </summary>
        public const int NET_DVR_WALLWIN_SET = 9004;
        /// <summary>
        /// 获取电视墙窗口相关参数
        /// </summary>
        public const int NET_DVR_WALLWINPARAM_SET = 9005;
        /// <summary>
        /// 设置电视墙窗口相关参数
        /// </summary>
        public const int NET_DVR_WALLWINPARAM_GET = 9006;
        /// <summary>
        /// 窗口置顶
        /// </summary>
        public const int NET_DVR_SWITCH_WIN_TOP = 9017;
        /// <summary>
        /// 窗口置底
        /// </summary>
        public const int NET_DVR_SWITCH_WIN_BOTTOM = 9018;
        /// <summary>
        /// 获取显示输出位置参数
        /// </summary>
        public const int NET_DVR_GET_VIDEOWALLDISPLAYPOSITION = 1734;
        /// <summary>
        /// 设置显示输出位置参数
        /// </summary>
        public const int NET_DVR_SET_VIDEOWALLDISPLAYPOSITION = 1733;
        /// <summary>
        /// 获取设备显示输出号
        /// </summary>
        public const int NET_DVR_GET_VIDEOWALLDISPLAYNO = 1732;
        /// <summary>
        /// 获取电视墙窗口参数
        /// </summary>
        public const int NET_DVR_GET_VIDEOWALLWINDOWPOSITION = 1735;
        /// <summary>
        /// 设置电视墙窗口参数
        /// </summary>
        public const int NET_DVR_SET_VIDEOWALLWINDOWPOSITION = 1736;
        /// <summary>
        /// 获取编码通道关联资源参数
        /// </summary>
        public const int NET_DVR_GET_CHAN_RELATION = 9209;
        /// <summary>
        /// 设置编码通道关联资源参数
        /// </summary>
        public const int NET_DVR_SET_CHAN_RELATION = 9210;
        /// <summary>
        /// 获取所有编码通道关联资源参数
        /// </summary>
        public const int NET_DVR_GET_ALL_CHAN_RELATION = 9211;
        /// <summary>
        /// 获取电视墙场景模式参数
        /// </summary>
        public const int NET_DVR_GET_VW_SCENE_PARAM = 1746;
        /// <summary>
        /// 设置电视墙场景模式参数
        /// </summary>
        public const int NET_DVR_SET_VW_SCENE_PARAM = 1747;
        /// <summary>
        /// 获取输出口图片窗口参数
        /// </summary>
        public const int NET_DVR_GET_OUTPUT_PIC_WIN_CFG = 9202;
        /// <summary>
        /// 设置输出口图片窗口参数
        /// </summary>
        public const int NET_DVR_SET_OUTPUT_PIC_WIN_CFG = 9203;
        /// <summary>
        /// 获取输出口OSD参数
        /// </summary>
        public const int NET_DVR_GET_OUTPUT_OSD_CFG = 9206;
        /// <summary>
        /// 设置输出口OSD参数
        /// </summary>
        public const int NET_DVR_SET_OUTPUT_OSD_CFG = 9207;
        /// <summary>
        /// 场景控制
        /// </summary>
        public const int NET_DVR_SCENE_CONTROL = 1744;
        public const int NET_DVR_GET_CARD = 2560;
        public const int NET_DVR_SET_CARD = 2561;
        public const int NET_DVR_DEL_CARD = 2562;
        public const int NET_DVR_GET_FINGERPRINT = 2563;
        public const int NET_DVR_SET_FINGERPRINT = 2564;
        public const int NET_DVR_DEL_FINGERPRINT = 2565;
        public const int NET_DVR_GET_FACE = 2566;
        public const int NET_DVR_SET_FACE = 2567;
        /// <summary>
        /// delete face param configure
        /// </summary>
        public const int NET_DVR_DEL_FACE_PARAM_CFG = 2509;
        /// <summary>
        /// capture face information
        /// </summary>
        public const int NET_DVR_CAPTURE_FACE_INFO = 2510;
        /// <summary>
        /// 获取门禁主机参数
        /// </summary>
        public const int NET_DVR_GET_ACS_CFG = 2159;
        /// <summary>
        /// 配置门禁主机参数
        /// </summary>
        public const int NET_DVR_SET_ACS_CFG = 2160;
        /// <summary>
        /// 获取门禁主机工作状态
        /// </summary>
        public const int NET_DVR_GET_ACS_WORK_STATUS_V50 = 2180;
        public const int NET_SDK_CONFIG_STATUS_SUCCESS = 1000;
        public const int NET_SDK_CONFIG_STATUS_NEED_WAIT = 1001;
        public const int NET_SDK_CONFIG_STATUS_FINISH = 1002;
        public const int NET_SDK_CONFIG_STATUS_FAILED = 1003;
        public const int NET_SDK_CONFIG_STATUS_EXCEPTION = 1004;
        /// <summary>
        /// 预置点名称获取与设置
        /// </summary>
        public const int NET_DVR_GET_PRESET_NAME = 3383;
        public const int NET_DVR_SET_PRESET_NAME = 3382;
        /// <summary>
        /// 获取异常行为识别参数
        /// </summary>
        public const int NET_VCA_GET_RULECFG_V41 = 5011;
        /// <summary>
        /// 设置异常行为识别参数
        /// </summary>
        public const int NET_VCA_SET_RULECFG_V41 = 5012;
        /// <summary>
        /// 获取越界侦测配置
        /// </summary>
        public const int NET_DVR_GET_TRAVERSE_PLANE_DETECTION = 3360;
        /// <summary>
        /// 设置越界侦测配置
        /// </summary>
        public const int NET_DVR_SET_TRAVERSE_PLANE_DETECTION = 3361;
        /// <summary>
        /// 获取预置点测温报警规则配置
        /// </summary>
        public const int NET_DVR_GET_THERMOMETRY_ALARMRULE = 3627;
        /// <summary>
        /// 设置预置点测温报警规则配置
        /// </summary>
        public const int NET_DVR_SET_THERMOMETRY_ALARMRULE = 3628;
        /// <summary>
        /// 获取测温联动配置
        /// </summary>
        public const int NET_DVR_GET_THERMOMETRY_TRIGGER = 3632;
        /// <summary>
        /// 设置测温联动配置
        /// </summary>
        public const int NET_DVR_SET_THERMOMETRY_TRIGGER = 3633;
        /// <summary>
        /// 设置手动测温基本参数
        /// </summary>
        public const int NET_DVR_SET_MANUALTHERM_BASICPARAM = 6716;
        /// <summary>
        /// 获取手动测温基本参数
        /// </summary>
        public const int NET_DVR_GET_MANUALTHERM_BASICPARAM = 6717;
        /// <summary>
        /// 设置手动测温数据设置
        /// </summary>
        public const int NET_DVR_SET_MANUALTHERM = 6708;
        /// <summary>
        /// 远程获取多码流压缩参数
        /// </summary>
        public const int NET_DVR_GET_MULTI_STREAM_COMPRESSIONCFG = 3216;
        /// <summary>
        /// 远程设置多码流压缩参数
        /// </summary>
        public const int NET_DVR_SET_MULTI_STREAM_COMPRESSIONCFG = 3217;
        /// <summary>
        /// 可视话对讲信令处理
        /// </summary>
        public const int NET_DVR_VIDEO_CALL_SIGNAL_PROCESS = 16032;
        /// <summary>
        /// 按布防类型对子系统布防
        /// </summary>
        public const int NET_DVR_ARM_ALARMHOST_SUBSYSTEM = 2036;
        /// <summary>
        /// 获取多重卡参数V50
        /// </summary>
        public const int NET_DVR_GET_MULTI_CARD_CFG_V50 = 2515;
        /// <summary>
        /// 设置多重卡参数V50
        /// </summary>
        public const int NET_DVR_SET_MULTI_CARD_CFG_V50 = 2516;
        /// <summary>
        /// 获取所有车辆授权和非授权名单信息
        /// </summary>
        public const int NET_DVR_GET_ALL_VEHICLE_CONTROL_LIST = 3124;
        /// <summary>
        /// 道闸控制
        /// </summary>
        public const int NET_DVR_BARRIERGATE_CTRL = 3128;
        /// <summary>
        /// 设置车辆授权和非授权名单信息(批量)
        /// </summary>
        public const int NET_DVR_VEHICLELIST_CTRL_START = 3133;
        /// <summary>
        /// 发送数据
        /// </summary>
        public const int ENUM_SENDDATA = 0x0;
        /// <summary>
        /// 获取审讯机刻录状态-长连接
        /// </summary>
        public const int NET_DVR_INQUEST_GET_CDW_STATUS = 6350;
        /// <summary>
        /// 实时温度检测
        /// </summary>
        public const int NET_DVR_GET_REALTIME_THERMOMETRY = 3629;
        /// <summary>
        /// 设备事件获取
        /// </summary>
        public const int NET_DVR_GET_ACS_EVENT = 2514;
        public const int NET_SDK_GET_NEXT_STATUS_SUCCESS = 1000;
        public const int NET_SDK_GET_NEXT_STATUS_NEED_WAIT = 1001;
        public const int NET_SDK_GET_NEXT_STATUS_FINISH = 1002;
        public const int NET_SDK_GET_NEXT_STATUS_FAILED = 1003;
        /// <summary>
        /// ***********************参数配置命令 end******************************
        /// **********************DVR日志 begin**************************
        /// 报警
        /// 主类型
        /// </summary>
        public const int MAJOR_ALARM = 1;
        /// <summary>
        /// 次类型
        /// </summary>
        public const int MINOR_ALARM_IN = 1;
        /// <summary>
        /// 报警输出
        /// </summary>
        public const int MINOR_ALARM_OUT = 2;
        /// <summary>
        /// 移动侦测报警开始
        /// </summary>
        public const int MINOR_MOTDET_START = 3;
        /// <summary>
        /// 移动侦测报警结束
        /// </summary>
        public const int MINOR_MOTDET_STOP = 4;
        /// <summary>
        /// 遮挡报警开始
        /// </summary>
        public const int MINOR_HIDE_ALARM_START = 5;
        /// <summary>
        /// 遮挡报警结束
        /// </summary>
        public const int MINOR_HIDE_ALARM_STOP = 6;
        /// <summary>
        /// 智能报警开始
        /// </summary>
        public const int MINOR_VCA_ALARM_START = 7;
        /// <summary>
        /// 智能报警停止
        /// </summary>
        public const int MINOR_VCA_ALARM_STOP = 8;
        /// <summary>
        /// 异常
        /// 主类型
        /// </summary>
        public const int MAJOR_EXCEPTION = 2;
        /// <summary>
        /// 次类型
        /// </summary>
        public const int MINOR_VI_LOST = 33;
        /// <summary>
        /// 非法访问
        /// </summary>
        public const int MINOR_ILLEGAL_ACCESS = 34;
        /// <summary>
        /// 硬盘满
        /// </summary>
        public const int MINOR_HD_FULL = 35;
        /// <summary>
        /// 硬盘错误
        /// </summary>
        public const int MINOR_HD_ERROR = 36;
        /// <summary>
        /// MODEM 掉线(保留不使用)
        /// </summary>
        public const int MINOR_DCD_LOST = 37;
        /// <summary>
        /// IP地址冲突
        /// </summary>
        public const int MINOR_IP_CONFLICT = 38;
        /// <summary>
        /// 网络断开
        /// </summary>
        public const int MINOR_NET_BROKEN = 39;
        /// <summary>
        /// 录像出错
        /// </summary>
        public const int MINOR_REC_ERROR = 40;
        /// <summary>
        /// IPC连接异常
        /// </summary>
        public const int MINOR_IPC_NO_LINK = 41;
        /// <summary>
        /// 视频输入异常(只针对模拟通道)
        /// </summary>
        public const int MINOR_VI_EXCEPTION = 42;
        /// <summary>
        /// ipc ip 地址 冲突
        /// </summary>
        public const int MINOR_IPC_IP_CONFLICT = 43;
        /// <summary>
        /// 视频综合平台
        /// </summary>
        public const int MINOR_FANABNORMAL = 49;
        /// <summary>
        /// 视频综合平台：风扇状态恢复正常
        /// </summary>
        public const int MINOR_FANRESUME = 50;
        /// <summary>
        /// 视频综合平台：6467异常重启
        /// </summary>
        public const int MINOR_SUBSYSTEM_ABNORMALREBOOT = 51;
        /// <summary>
        /// 视频综合平台：dm6467异常，启动蜂鸣器
        /// </summary>
        public const int MINOR_MATRIX_STARTBUZZER = 52;
        /// <summary>
        /// 操作
        /// 主类型
        /// </summary>
        public const int MAJOR_OPERATION = 3;
        /// <summary>
        /// 次类型
        /// </summary>
        public const int MINOR_START_DVR = 65;
        /// <summary>
        /// 关机
        /// </summary>
        public const int MINOR_STOP_DVR = 66;
        /// <summary>
        /// 异常关机
        /// </summary>
        public const int MINOR_STOP_ABNORMAL = 67;
        /// <summary>
        /// 本地重启设备
        /// </summary>
        public const int MINOR_REBOOT_DVR = 68;
        /// <summary>
        /// 本地登陆
        /// </summary>
        public const int MINOR_LOCAL_LOGIN = 80;
        /// <summary>
        /// 本地注销登陆
        /// </summary>
        public const int MINOR_LOCAL_LOGOUT = 81;
        /// <summary>
        /// 本地配置参数
        /// </summary>
        public const int MINOR_LOCAL_CFG_PARM = 82;
        /// <summary>
        /// 本地按文件回放或下载
        /// </summary>
        public const int MINOR_LOCAL_PLAYBYFILE = 83;
        /// <summary>
        /// 本地按时间回放或下载
        /// </summary>
        public const int MINOR_LOCAL_PLAYBYTIME = 84;
        /// <summary>
        /// 本地开始录像
        /// </summary>
        public const int MINOR_LOCAL_START_REC = 85;
        /// <summary>
        /// 本地停止录像
        /// </summary>
        public const int MINOR_LOCAL_STOP_REC = 86;
        /// <summary>
        /// 本地云台控制
        /// </summary>
        public const int MINOR_LOCAL_PTZCTRL = 87;
        /// <summary>
        /// 本地预览 (保留不使用)
        /// </summary>
        public const int MINOR_LOCAL_PREVIEW = 88;
        /// <summary>
        /// 本地修改时间(保留不使用)
        /// </summary>
        public const int MINOR_LOCAL_MODIFY_TIME = 89;
        /// <summary>
        /// 本地升级
        /// </summary>
        public const int MINOR_LOCAL_UPGRADE = 90;
        /// <summary>
        /// 本地备份录象文件
        /// </summary>
        public const int MINOR_LOCAL_RECFILE_OUTPUT = 91;
        /// <summary>
        /// 本地初始化硬盘
        /// </summary>
        public const int MINOR_LOCAL_FORMAT_HDD = 92;
        /// <summary>
        /// 导出本地配置文件
        /// </summary>
        public const int MINOR_LOCAL_CFGFILE_OUTPUT = 93;
        /// <summary>
        /// 导入本地配置文件
        /// </summary>
        public const int MINOR_LOCAL_CFGFILE_INPUT = 94;
        /// <summary>
        /// 本地备份文件
        /// </summary>
        public const int MINOR_LOCAL_COPYFILE = 95;
        /// <summary>
        /// 本地锁定录像文件
        /// </summary>
        public const int MINOR_LOCAL_LOCKFILE = 96;
        /// <summary>
        /// 本地解锁录像文件
        /// </summary>
        public const int MINOR_LOCAL_UNLOCKFILE = 97;
        /// <summary>
        /// 本地手动清除和触发报警
        /// </summary>
        public const int MINOR_LOCAL_DVR_ALARM = 98;
        /// <summary>
        /// 本地添加IPC
        /// </summary>
        public const int MINOR_IPC_ADD = 99;
        /// <summary>
        /// 本地删除IPC
        /// </summary>
        public const int MINOR_IPC_DEL = 100;
        /// <summary>
        /// 本地设置IPC
        /// </summary>
        public const int MINOR_IPC_SET = 101;
        /// <summary>
        /// 本地开始备份
        /// </summary>
        public const int MINOR_LOCAL_START_BACKUP = 102;
        /// <summary>
        /// 本地停止备份
        /// </summary>
        public const int MINOR_LOCAL_STOP_BACKUP = 103;
        /// <summary>
        /// 本地备份开始时间
        /// </summary>
        public const int MINOR_LOCAL_COPYFILE_START_TIME = 104;
        /// <summary>
        /// 本地备份结束时间
        /// </summary>
        public const int MINOR_LOCAL_COPYFILE_END_TIME = 105;
        /// <summary>
        /// 本地添加网络硬盘
        /// </summary>
        public const int MINOR_LOCAL_ADD_NAS = 106;
        /// <summary>
        /// 本地删除nas盘
        /// </summary>
        public const int MINOR_LOCAL_DEL_NAS = 107;
        /// <summary>
        /// 本地设置nas盘
        /// </summary>
        public const int MINOR_LOCAL_SET_NAS = 108;
        /// <summary>
        /// 远程登录
        /// </summary>
        public const int MINOR_REMOTE_LOGIN = 112;
        /// <summary>
        /// 远程注销登陆
        /// </summary>
        public const int MINOR_REMOTE_LOGOUT = 113;
        /// <summary>
        /// 远程开始录像
        /// </summary>
        public const int MINOR_REMOTE_START_REC = 114;
        /// <summary>
        /// 远程停止录像
        /// </summary>
        public const int MINOR_REMOTE_STOP_REC = 115;
        /// <summary>
        /// 开始透明传输
        /// </summary>
        public const int MINOR_START_TRANS_CHAN = 116;
        /// <summary>
        /// 停止透明传输
        /// </summary>
        public const int MINOR_STOP_TRANS_CHAN = 117;
        /// <summary>
        /// 远程获取参数
        /// </summary>
        public const int MINOR_REMOTE_GET_PARM = 118;
        /// <summary>
        /// 远程配置参数
        /// </summary>
        public const int MINOR_REMOTE_CFG_PARM = 119;
        /// <summary>
        /// 远程获取状态
        /// </summary>
        public const int MINOR_REMOTE_GET_STATUS = 120;
        /// <summary>
        /// 远程布防
        /// </summary>
        public const int MINOR_REMOTE_ARM = 121;
        /// <summary>
        /// 远程撤防
        /// </summary>
        public const int MINOR_REMOTE_DISARM = 122;
        /// <summary>
        /// 远程重启
        /// </summary>
        public const int MINOR_REMOTE_REBOOT = 123;
        /// <summary>
        /// 开始语音对讲
        /// </summary>
        public const int MINOR_START_VT = 124;
        /// <summary>
        /// 停止语音对讲
        /// </summary>
        public const int MINOR_STOP_VT = 125;
        /// <summary>
        /// 远程升级
        /// </summary>
        public const int MINOR_REMOTE_UPGRADE = 126;
        /// <summary>
        /// 远程按文件回放
        /// </summary>
        public const int MINOR_REMOTE_PLAYBYFILE = 127;
        /// <summary>
        /// 远程按时间回放
        /// </summary>
        public const int MINOR_REMOTE_PLAYBYTIME = 128;
        /// <summary>
        /// 远程云台控制
        /// </summary>
        public const int MINOR_REMOTE_PTZCTRL = 129;
        /// <summary>
        /// 远程格式化硬盘
        /// </summary>
        public const int MINOR_REMOTE_FORMAT_HDD = 130;
        /// <summary>
        /// 远程关机
        /// </summary>
        public const int MINOR_REMOTE_STOP = 131;
        /// <summary>
        /// 远程锁定文件
        /// </summary>
        public const int MINOR_REMOTE_LOCKFILE = 132;
        /// <summary>
        /// 远程解锁文件
        /// </summary>
        public const int MINOR_REMOTE_UNLOCKFILE = 133;
        /// <summary>
        /// 远程导出配置文件
        /// </summary>
        public const int MINOR_REMOTE_CFGFILE_OUTPUT = 134;
        /// <summary>
        /// 远程导入配置文件
        /// </summary>
        public const int MINOR_REMOTE_CFGFILE_INTPUT = 135;
        /// <summary>
        /// 远程导出录象文件
        /// </summary>
        public const int MINOR_REMOTE_RECFILE_OUTPUT = 136;
        /// <summary>
        /// 远程手动清除和触发报警
        /// </summary>
        public const int MINOR_REMOTE_DVR_ALARM = 137;
        /// <summary>
        /// 远程添加IPC
        /// </summary>
        public const int MINOR_REMOTE_IPC_ADD = 138;
        /// <summary>
        /// 远程删除IPC
        /// </summary>
        public const int MINOR_REMOTE_IPC_DEL = 139;
        /// <summary>
        /// 远程设置IPC
        /// </summary>
        public const int MINOR_REMOTE_IPC_SET = 140;
        /// <summary>
        /// 重启智能库
        /// </summary>
        public const int MINOR_REBOOT_VCA_LIB = 141;
        /// <summary>
        /// 远程添加nas盘
        /// </summary>
        public const int MINOR_REMOTE_ADD_NAS = 142;
        /// <summary>
        /// 远程删除nas盘
        /// </summary>
        public const int MINOR_REMOTE_DEL_NAS = 143;
        /// <summary>
        /// 远程设置nas盘
        /// </summary>
        public const int MINOR_REMOTE_SET_NAS = 144;
        /// <summary>
        /// 2009-12-16 增加视频综合平台日志类型
        /// </summary>
        public const int MINOR_SUBSYSTEMREBOOT = 160;
        /// <summary>
        /// 视频综合平台：矩阵切换开始传输图像
        /// </summary>
        public const int MINOR_MATRIX_STARTTRANSFERVIDEO = 161;
        /// <summary>
        /// 视频综合平台：矩阵切换停止传输图像
        /// </summary>
        public const int MINOR_MATRIX_STOPTRANSFERVIDEO = 162;
        /// <summary>
        /// 视频综合平台：设置所有6467子系统信息
        /// </summary>
        public const int MINOR_REMOTE_SET_ALLSUBSYSTEM = 163;
        /// <summary>
        /// 视频综合平台：获取所有6467子系统信息
        /// </summary>
        public const int MINOR_REMOTE_GET_ALLSUBSYSTEM = 164;
        /// <summary>
        /// 视频综合平台：设置计划轮询组
        /// </summary>
        public const int MINOR_REMOTE_SET_PLANARRAY = 165;
        /// <summary>
        /// 视频综合平台：获取计划轮询组
        /// </summary>
        public const int MINOR_REMOTE_GET_PLANARRAY = 166;
        /// <summary>
        /// 视频综合平台：矩阵切换开始传输音频
        /// </summary>
        public const int MINOR_MATRIX_STARTTRANSFERAUDIO = 167;
        /// <summary>
        /// 视频综合平台：矩阵切换停止传输音频
        /// </summary>
        public const int MINOR_MATRIX_STOPRANSFERAUDIO = 168;
        /// <summary>
        /// 视频综合平台：登陆码分器
        /// </summary>
        public const int MINOR_LOGON_CODESPITTER = 169;
        /// <summary>
        /// 视频综合平台：退出码分器
        /// </summary>
        public const int MINOR_LOGOFF_CODESPITTER = 170;
        /// <summary>
        /// 2010-12-16 报警板日志
        /// </summary>
        public const int MINOR_REMOTE_BYPASS = 0xd0;
        /// <summary>
        /// 远程旁路恢复
        /// </summary>
        public const int MINOR_REMOTE_UNBYPASS = 0xd1;
        /// <summary>
        /// 远程设置报警输入参数
        /// </summary>
        public const int MINOR_REMOTE_SET_ALARMIN_CFG = 0xd2;
        /// <summary>
        /// 远程获取报警输入参数
        /// </summary>
        public const int MINOR_REMOTE_GET_ALARMIN_CFG = 0xd3;
        /// <summary>
        /// 远程设置报警输出参数
        /// </summary>
        public const int MINOR_REMOTE_SET_ALARMOUT_CFG = 0xd4;
        /// <summary>
        /// 远程获取报警输出参数
        /// </summary>
        public const int MINOR_REMOTE_GET_ALARMOUT_CFG = 0xd5;
        /// <summary>
        /// 远程手动开启报警输出
        /// </summary>
        public const int MINOR_REMOTE_ALARMOUT_OPEN_MAN = 0xd6;
        /// <summary>
        /// 远程手动关闭报警输出
        /// </summary>
        public const int MINOR_REMOTE_ALARMOUT_CLOSE_MAN = 0xd7;
        /// <summary>
        /// 远程设置报警主机的RS485串口使能状态
        /// </summary>
        public const int MINOR_REMOTE_ALARM_ENABLE_CFG = 0xd8;
        /// <summary>
        /// 导出数据库记录
        /// </summary>
        public const int MINOR_DBDATA_OUTPUT = 0xd9;
        /// <summary>
        /// 导入数据库记录
        /// </summary>
        public const int MINOR_DBDATA_INPUT = 0xda;
        /// <summary>
        /// 级联切换
        /// </summary>
        public const int MINOR_MU_SWITCH = 0xdb;
        /// <summary>
        /// 级联PTZ控制
        /// </summary>
        public const int MINOR_MU_PTZ = 0xdc;
        /// <summary>
        /// 删除logo
        /// </summary>
        public const int MINOR_DELETE_LOGO = 0xdd;
        /// <summary>
        /// 远程删除文件
        /// </summary>
        public const int MINOR_REMOTE_INQUEST_DEL_FILE = 0xde;
        /// <summary>
        /// 日志附加信息
        /// 主类型
        /// </summary>
        public const int MAJOR_INFORMATION = 4;
        /// <summary>
        /// 次类型
        /// </summary>
        public const int MINOR_HDD_INFO = 161;
        /// <summary>
        /// SMART信息
        /// </summary>
        public const int MINOR_SMART_INFO = 162;
        /// <summary>
        /// 开始录像
        /// </summary>
        public const int MINOR_REC_START = 163;
        /// <summary>
        /// 停止录像
        /// </summary>
        public const int MINOR_REC_STOP = 164;
        /// <summary>
        /// 过期录像删除
        /// </summary>
        public const int MINOR_REC_OVERDUE = 165;
        /// <summary>
        /// 连接前端设备
        /// </summary>
        public const int MINOR_LINK_START = 166;
        /// <summary>
        /// 断开前端设备
        /// </summary>
        public const int MINOR_LINK_STOP = 167;
        /// <summary>
        /// 网络硬盘信息
        /// </summary>
        public const int MINOR_NET_DISK_INFO = 168;
        /// <summary>
        /// 当日志的主类型为MAJOR_OPERATION=03，次类型为MINOR_LOCAL_CFG_PARM=0x52或者MINOR_REMOTE_GET_PARM=0x76或者MINOR_REMOTE_CFG_PARM=0x77时，dwParaType:参数类型有效，其含义如下：
        /// </summary>
        public const int PARA_VIDEOOUT = 1;
        public const int PARA_IMAGE = 2;
        public const int PARA_ENCODE = 4;
        public const int PARA_NETWORK = 8;
        public const int PARA_ALARM = 16;
        public const int PARA_EXCEPTION = 32;
        /// <summary>
        /// 解码器
        /// </summary>
        public const int PARA_DECODER = 64;
        public const int PARA_RS232 = 128;
        public const int PARA_PREVIEW = 256;
        public const int PARA_SECURITY = 512;
        public const int PARA_DATETIME = 1024;
        /// <summary>
        /// 帧格式
        /// </summary>
        public const int PARA_FRAMETYPE = 2048;
        /// <summary>
        /// vca
        /// </summary>
        public const int PARA_VCA_RULE = 4096;
        /// <summary>
        /// **********************DVR日志 End**************************
        /// *****************查找文件和日志函数返回值************************
        /// </summary>
        public const int NET_DVR_FILE_SUCCESS = 1000;
        /// <summary>
        /// 没有文件
        /// </summary>
        public const int NET_DVR_FILE_NOFIND = 1001;
        /// <summary>
        /// 正在查找文件
        /// </summary>
        public const int NET_DVR_ISFINDING = 1002;
        /// <summary>
        /// 查找文件时没有更多的文件
        /// </summary>
        public const int NET_DVR_NOMOREFILE = 1003;
        /// <summary>
        /// 查找文件时异常
        /// </summary>
        public const int NET_DVR_FILE_EXCEPTION = 1004;
        /// <summary>
        /// *******************回调函数类型 begin***********************
        /// </summary>
        public const int COMM_ALARM = 0x1100;
        /// <summary>
        /// 异常行为识别报警信息，对应NET_VCA_RULE_ALARM
        /// </summary>
        public const int COMM_ALARM_RULE = 0x1102;
        /// <summary>
        /// 人流量统计报警上传，对应NET_DVR_PDC_ALRAM_INFO
        /// </summary>
        public const int COMM_ALARM_PDC = 0x1103;
        /// <summary>
        /// 网络报警主机报警上传，对应NET_DVR_ALARMHOST_ALARMINFO
        /// </summary>
        public const int COMM_ALARM_ALARMHOST = 0x1105;
        /// <summary>
        /// 人脸检测识别报警信息，对应NET_DVR_FACEDETECT_ALARM
        /// </summary>
        public const int COMM_ALARM_FACE = 0x1106;
        /// <summary>
        /// 事件数据信息上传
        /// </summary>
        public const int COMM_RULE_INFO_UPLOAD = 0x1107;
        /// <summary>
        /// 交通事件报警信息
        /// </summary>
        public const int COMM_ALARM_AID = 0x1110;
        /// <summary>
        /// 交通参数统计报警信息
        /// </summary>
        public const int COMM_ALARM_TPS = 0x1111;
        /// <summary>
        /// 人脸识别结果上传
        /// </summary>
        public const int COMM_UPLOAD_FACESNAP_RESULT = 0x1112;
        /// <summary>
        /// 人脸侦测报警信息
        /// </summary>
        public const int COMM_ALARM_FACE_DETECTION = 0x4010;
        /// <summary>
        /// 交通取证报警信息
        /// </summary>
        public const int COMM_ALARM_TFS = 0x1113;
        /// <summary>
        /// 交通参数统计报警信息扩展
        /// </summary>
        public const int COMM_ALARM_TPS_V41 = 0x1114;
        /// <summary>
        /// 交通事件报警信息扩展
        /// </summary>
        public const int COMM_ALARM_AID_V41 = 0x1115;
        /// <summary>
        /// 视频质量诊断报警
        /// </summary>
        public const int COMM_ALARM_VQD_EX = 0x1116;
        /// <summary>
        /// 模拟量数据实时上传
        /// </summary>
        public const int COMM_SENSOR_VALUE_UPLOAD = 0x1120;
        /// <summary>
        /// 模拟量报警上传
        /// </summary>
        public const int COMM_SENSOR_ALARM = 0x1121;
        /// <summary>
        /// 开关量报警
        /// </summary>
        public const int COMM_SWITCH_ALARM = 0x1122;
        /// <summary>
        /// 报警主机故障报警
        /// </summary>
        public const int COMM_ALARMHOST_EXCEPTION = 0x1123;
        /// <summary>
        /// 操作事件报警上传
        /// </summary>
        public const int COMM_ALARMHOST_OPERATEEVENT_ALARM = 0x1124;
        /// <summary>
        /// 防护舱状态
        /// </summary>
        public const int COMM_ALARMHOST_SAFETYCABINSTATE = 0x1125;
        /// <summary>
        /// 报警输出口/警号状态
        /// </summary>
        public const int COMM_ALARMHOST_ALARMOUTSTATUS = 0x1126;
        /// <summary>
        /// CID报告报警上传
        /// </summary>
        public const int COMM_ALARMHOST_CID_ALARM = 0x1127;
        /// <summary>
        /// 报警主机外接设备报警上传
        /// </summary>
        public const int COMM_ALARMHOST_EXTERNAL_DEVICE_ALARM = 0x1128;
        /// <summary>
        /// 报警数据上传
        /// </summary>
        public const int COMM_ALARMHOST_DATA_UPLOAD = 0x1129;
        /// <summary>
        /// 可视对讲事件记录上传
        /// </summary>
        public const int COMM_UPLOAD_VIDEO_INTERCOM_EVENT = 0x1132;
        /// <summary>
        /// 声音报警信息
        /// </summary>
        public const int COMM_ALARM_AUDIOEXCEPTION = 0x1150;
        /// <summary>
        /// 虚焦报警信息
        /// </summary>
        public const int COMM_ALARM_DEFOCUS = 0x1151;
        /// <summary>
        /// 按钮按下报警信息
        /// </summary>
        public const int COMM_ALARM_BUTTON_DOWN_EXCEPTION = 0x1152;
        /// <summary>
        /// GPS报警信息上传
        /// </summary>
        public const int COMM_ALARM_ALARMGPS = 0x1202;
        /// <summary>
        /// ATMDVR主动上传交易信息
        /// </summary>
        public const int COMM_TRADEINFO = 0x1500;
        /// <summary>
        /// 上传车牌信息
        /// </summary>
        public const int COMM_UPLOAD_PLATE_RESULT = 0x2800;
        /// <summary>
        /// 实时状态检测结果上传(智能高清IPC)
        /// </summary>
        public const int COMM_ITC_STATUS_DETECT_RESULT = 0x2810;
        /// <summary>
        /// PIR报警、无线报警、呼救报警上传
        /// </summary>
        public const int COMM_IPC_AUXALARM_RESULT = 0x2820;
        /// <summary>
        /// 上传图片信息
        /// </summary>
        public const int COMM_UPLOAD_PICTUREINFO = 0x2900;
        /// <summary>
        /// 禁止名单比对结果上传
        /// </summary>
        public const int COMM_SNAP_MATCH_ALARM = 0x2902;
        /// <summary>
        /// 终端图片上传
        /// </summary>
        public const int COMM_ITS_PLATE_RESULT = 0x3050;
        /// <summary>
        /// 终端统计数据上传
        /// </summary>
        public const int COMM_ITS_TRAFFIC_COLLECT = 0x3051;
        /// <summary>
        /// 出入口车辆抓拍数据上传
        /// </summary>
        public const int COMM_ITS_GATE_VEHICLE = 0x3052;
        /// <summary>
        /// 出入口人脸抓拍数据上传
        /// </summary>
        public const int COMM_ITS_GATE_FACE = 0x3053;
        /// <summary>
        /// 出入口过车收费明细 2013-11-19
        /// </summary>
        public const int COMM_ITS_GATE_COSTITEM = 0x3054;
        /// <summary>
        /// 出入口交接班数据 2013-11-19
        /// </summary>
        public const int COMM_ITS_GATE_HANDOVER = 0x3055;
        /// <summary>
        /// 停车场数据上传
        /// </summary>
        public const int COMM_ITS_PARK_VEHICLE = 0x3056;
        /// <summary>
        /// 禁止名单报警上传
        /// </summary>
        public const int COMM_ITS_BLOCKLIST_ALARM = 0x3057;
        /// <summary>
        /// TPS实时过车数据上传
        /// </summary>
        public const int COMM_ALARM_TPS_REAL_TIME = 0x3081;
        /// <summary>
        /// TPS统计过车数据上传
        /// </summary>
        public const int COMM_ALARM_TPS_STATISTICS = 0x3082;
        /// <summary>
        /// 9000报警信息主动上传
        /// </summary>
        public const int COMM_ALARM_V30 = 0x4000;
        /// <summary>
        /// 9000设备IPC接入配置改变报警信息主动上传
        /// </summary>
        public const int COMM_IPCCFG = 0x4001;
        /// <summary>
        /// 9000设备IPC接入配置改变报警信息主动上传扩展 9000_1.1
        /// </summary>
        public const int COMM_IPCCFG_V31 = 0x4002;
        /// <summary>
        /// IVMS 2000 编码服务器 NVR IPC接入配置改变时报警信息上传
        /// </summary>
        public const int COMM_IPCCFG_V40 = 0x4003;
        /// <summary>
        /// 设备报警内容，由于通道值大于256而扩展
        /// </summary>
        public const int COMM_ALARM_DEVICE = 0x4004;
        /// <summary>
        /// CVR 2.0.X外部报警类型
        /// </summary>
        public const int COMM_ALARM_CVR = 0x4005;
        /// <summary>
        /// 热备异常报警（N+1模式异常报警）
        /// </summary>
        public const int COMM_ALARM_HOT_SPARE = 0x4006;
        /// <summary>
        /// 移动侦测，视频丢失，遮挡，IO信号量等报警信息主动上传，报警数据为可变长
        /// </summary>
        public const int COMM_ALARM_V40 = 0x4007;
        /// <summary>
        /// 热度图报警上传
        /// </summary>
        public const int COMM_UPLOAD_HEATMAP_RESULT = 0x4008;
        /// <summary>
        /// 路口设备异常报警
        /// </summary>
        public const int COMM_ITS_ROAD_EXCEPTION = 0x4500;
        /// <summary>
        /// 外控报警
        /// </summary>
        public const int COMM_ITS_EXTERNAL_CONTROL_ALARM = 0x4520;
        /// <summary>
        /// 火点检测报警
        /// </summary>
        public const int COMM_FIREDETECTION_ALARM = 0x4991;
        /// <summary>
        /// 多屏控制器报警类型
        /// </summary>
        public const int COMM_SCREEN_ALARM = 0x5000;
        /// <summary>
        /// 分布式大屏控制器报警上传
        /// </summary>
        public const int COMM_DVCS_STATE_ALARM = 0x5001;
        /// <summary>
        /// VQD主动报警上传
        /// </summary>
        public const int COMM_ALARM_VQD = 0x6000;
        /// <summary>
        /// 推模式录像信息上传
        /// </summary>
        public const int COMM_PUSH_UPDATE_RECORD_INFO = 0x6001;
        /// <summary>
        /// 诊断服务器VQD报警上传
        /// </summary>
        public const int COMM_DIAGNOSIS_UPLOAD = 0x5100;
        /// <summary>
        /// 门禁主机报警
        /// </summary>
        public const int COMM_ALARM_ACS = 0x5002;
        /// <summary>
        /// 身份证信息上传
        /// </summary>
        public const int COMM_ID_INFO_ALARM = 0x5200;
        /// <summary>
        /// 通行人数上报
        /// </summary>
        public const int COMM_PASSNUM_INFO_ALARM = 0x5201;
        public const int COMM_ISAPI_ALARM = 0x6009;
        /// <summary>
        /// 温度报警信息
        /// </summary>
        public const int COMM_THERMOMETRY_ALARM = 0x5212;
        /// <summary>
        /// 设备支持AI开放平台接入，上传视频检测数据
        /// </summary>
        public const int COMM_UPLOAD_AIOP_VIDEO = 0x4021;
        /// <summary>
        /// 设备支持AI开放平台接入，上传图片检测数据
        /// </summary>
        public const int COMM_UPLOAD_AIOP_PICTURE = 0x4022;
        /// <summary>
        /// 设备支持AI开放平台接入，上传轮巡抓图图片检测数据 对应的结构体(NET_AIOP_POLLING_SNAP_HEAD)
        /// </summary>
        public const int COMM_UPLOAD_AIOP_POLLING_SNAP = 0x4023;
        /// <summary>
        /// 设备支持AI开放平台接入，上传轮巡视频检测数据 对应的结构体(NET_AIOP_POLLING_VIDEO_HEAD)
        /// </summary>
        public const int COMM_UPLOAD_AIOP_POLLING_VIDEO = 0x4024;
        public const int NET_DVR_JSON_CONFIG = 2550;
        public const int NET_DVR_FACE_DATA_RECORD = 2551;
        public const int NET_DVR_FACE_DATA_SEARCH = 2552;
        public const int NET_DVR_FACE_DATA_MODIFY = 2553;
        /// <summary>
        /// 远程开锁
        /// </summary>
        public const int NET_DVR_REMOTECONTROL_GATEWAY = 16009;
        public const int NET_DVR_CLEAR_ACS_PARAM = 2118;
        public const int ACS_PARAM_CARD = 0x00001000;
        public const int NET_SDK_NEXT_STATUS__FINISH = 1002;

        /// <summary>
        /// [DllImportAttribute(@".\HCNetSDK.dll")]
        /// public static extern int NET_DVR_SendWithRecvRemoteConfig(int lHandle, IntPtr lpInBuff, uint dwInBuffSize, IntPtr lpOutBuff, uint dwOutBuffSize, ref int dwOutDataLen);
        /// </summary>
        //[DllImportAttribute(@".\HCNetSDK.dll")]
        //public static extern int NET_DVR_SendWithRecvRemoteConfig(int lHandle, IntPtr lpInBuff, uint dwInBuffSize, IntPtr lpOutBuff, uint dwOutBuffSize, ref int dwOutDataLen);
        [StructLayout(LayoutKind.Sequential)]
        public struct NET_DVR_ACS_PARAM_TYPE
        {
            /// <summary>
            /// 结构体大小（C# 中建议使用 uint，对应 Java 的 int）
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 参数类型（按位表示，C# 中建议使用 uint）
            /// </summary>
            public uint dwParamType;
            /// <summary>
            /// 就地控制器序号 [1,64]，0 代表门禁主机（对应 Java 的 short）
            /// </summary>
            public ushort wLocalControllerID;
            /// <summary>
            /// 固定长度字节数组（需与 Java 中的数组长度一致）
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 30)]
            public byte[] byRes;
        }

        /// <summary>
        /// 用户调用SendwithRecv接口时，接口返回的状态
        /// </summary>
        public enum NET_SDK_SENDWITHRECV_STATUS
        {
            /// <summary>
            /// 成功读取到数据，客户端处理完本次数据后需要再次调用NET_DVR_SendWithRecvRemoteConfig获取下一条数据
            /// </summary>
            NET_SDK_CONFIG_STATUS_SUCCESS = 1000,
            /// <summary>
            /// 配置等待，客户端可重新NET_DVR_SendWithRecvRemoteConfig
            /// </summary>
            NET_SDK_CONFIG_STATUS_NEEDWAIT,
            /// <summary>
            /// 数据全部取完，此时客户端可调用NET_DVR_StopRemoteConfig结束
            /// </summary>
            NET_SDK_CONFIG_STATUS_FINISH,
            /// <summary>
            /// 配置失败，客户端可重新NET_DVR_SendWithRecvRemoteConfig
            /// </summary>
            NET_SDK_CONFIG_STATUS_FAILED,
            /// <summary>
            /// 配置异常，此时客户端可调用NET_DVR_StopRemoteConfig结束
            /// </summary>
            NET_SDK_CONFIG_STATUS_EXCEPTION
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_JSON_DATA_CFG
        {
            /// <summary>
            /// size of NET_DVR_JSON_DATA_CFG
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// Json data
            /// </summary>
            public IntPtr lpJsonData;
            /// <summary>
            /// Json data size
            /// </summary>
            public uint dwJsonDataSize;
            /// <summary>
            /// picture data
            /// </summary>
            public IntPtr lpPicData;
            /// <summary>
            /// picture data size
            /// </summary>
            public uint dwPicDataSize;
            /// <summary>
            /// infrared picture data size
            /// </summary>
            public uint dwInfraredFacePicSize;
            /// <summary>
            /// infrared picture data
            /// </summary>
            public IntPtr lpInfraredFacePicBuffer;
            /// <summary>
            /// reserve
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 248)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CAPTURE_FACE_COND
        {
            public int dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CAPTURE_FACE_CFG
        {
            public int dwSize;
            /// <summary>
            /// 人脸模板1数据大小，等于0时，代表无人脸模板1数据
            /// </summary>
            public int dwFaceTemplate1Size;
            /// <summary>
            /// 人脸模板1数据缓存（不大于2.5k）
            /// </summary>
            public IntPtr pFaceTemplate1Buffer;
            /// <summary>
            /// 人脸模板2数据大小，等于0时，代表无人脸模板2数据
            /// </summary>
            public int dwFaceTemplate2Size;
            /// <summary>
            /// 人脸模板2数据缓存（不大于2.5K）
            /// </summary>
            public IntPtr pFaceTemplate2Buffer;
            /// <summary>
            /// 人脸图片数据大小，等于0时，代表无人脸图片数据;
            /// </summary>
            public int dwFacePicSize;
            /// <summary>
            /// 人脸图片数据缓存;
            /// </summary>
            public IntPtr pFacePicBuffer;
            /// <summary>
            /// 人脸质量，范围1-100
            /// </summary>
            public byte byFaceQuality1;
            /// <summary>
            /// 人脸质量，范围1-100
            /// </summary>
            public byte byFaceQuality2;
            /// <summary>
            /// 采集进度，目前只有两种进度值：0-未采集到人脸，100-采集到人脸（只有在进度为100时，才解析人脸信息）
            /// </summary>
            public byte byCaptureProgress;
            public byte byRes1;
            /// <summary>
            /// 红外人脸图片数据大小，等于0时，代表无人脸图片数据
            /// </summary>
            public int dwInfraredFacePicSize;
            /// <summary>
            /// 红外人脸图片数据缓存
            /// </summary>
            public IntPtr pInfraredFacePicBuffer;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 116, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        public const int ERROR_MSG_LEN = 32;
        public const int MAX_FINGER_PRINT_LEN = 768;
        public const int NET_DVR_CAPTURE_FINGERPRINT_INFO = 2504;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FINGERPRINT_STATUS
        {
            public int dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN)]
            public byte[] byCardNo;
            /// <summary>
            /// 指纹读卡器状态，按字节表示，0-失败，1-成功，2-该指纹模组不在线，3-重试或指纹质量差，4-内存已满，5-已存在该指纹，6-已存在该指纹ID，7-非法指纹ID，8-该指纹模组无需配置
            /// </summary>
            public byte byCardReaderRecvStatus;
            /// <summary>
            /// 手指编号，有效值范围为1-10
            /// </summary>
            public byte byFingerPrintID;
            /// <summary>
            /// 指纹类型  0-普通指纹，1-胁迫指纹
            /// </summary>
            public byte byFingerType;
            /// <summary>
            /// 主机错误状态：0-成功，1-手指编号错误，2-指纹类型错误，3-卡号错误（卡号规格不符合设备要求），4-指纹未关联工号或卡号（工号或卡号字段为空），5-工号不存在，6-指纹数据长度为0，7-读卡器编号错误，8-工号错误
            /// </summary>
            public byte byRecvStatus;
            /// <summary>
            /// 下发错误信息，当byCardReaderRecvStatus为5时，表示已存在指纹对应的卡号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ERROR_MSG_LEN)]
            public byte[] byErrorMsg;
            /// <summary>
            /// 当byCardReaderRecvStatus为5时，表示已存在指纹对应的指纹读卡器编号，可用于下发错误返回。0时表示无错误信息
            /// </summary>
            public int dwCardReaderNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FINGERPRINT_RECORD
        {
            public int dwSize;
            /// <summary>
            /// 指纹关联的卡号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN)]
            public byte[] byCardNo;
            /// <summary>
            /// 指纹数据长度
            /// </summary>
            public int dwFingerPrintLen;
            /// <summary>
            /// 需要下发指纹的读卡器编号
            /// </summary>
            public int dwEnableReaderNo;
            /// <summary>
            /// 手指编号，有效值范围为1-10
            /// </summary>
            public byte byFingerPrintID;
            /// <summary>
            /// 指纹类型  0-普通指纹，1-胁迫指纹
            /// </summary>
            public byte byFingerType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 30)]
            public byte[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_FINGER_PRINT_LEN)]
            public byte[] byFingerData;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 96)]
            public byte[] byRes;
        }
        public const int MAX_ALARMHOST_ALARMIN_NUM = 512;
        public const int MAX_ALARMHOST_ALARMOUT_NUM = 512;

        [StructLayout(LayoutKind.Sequential)]
        public struct NET_DVR_ACS_WORK_STATUS_V50
        {
            public uint dwSize;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_DOOR_NUM_256)]
            public byte[] byDoorLockStatus;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_DOOR_NUM_256)]
            public byte[] byDoorStatus;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_DOOR_NUM_256)]
            public byte[] byMagneticStatus;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_CASE_SENSOR_NUM)]
            public byte[] byCaseStatus;
            public ushort wBatteryVoltage;
            public byte byBatteryLowVoltage;
            public byte byPowerSupplyStatus;
            public byte byMultiDoorInterlockStatus;
            public byte byAntiSneakStatus;
            public byte byHostAntiDismantleStatus;
            public byte byIndicatorLightStatus;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_CARD_READER_NUM_512)]
            public byte[] byCardReaderOnlineStatus;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_CARD_READER_NUM_512)]
            public byte[] byCardReaderAntiDismantleStatus;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_CARD_READER_NUM_512)]
            public byte[] byCardReaderVerifyMode;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_ALARMHOST_ALARMIN_NUM)]
            public byte[] bySetupAlarmStatus;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_ALARMHOST_ALARMIN_NUM)]
            public byte[] byAlarmInStatus;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_ALARMHOST_ALARMOUT_NUM)]
            public byte[] byAlarmOutStatus;
            public uint dwCardNum;
            public byte byFireAlarmStatus;
            public byte byBatteryChargeStatus;
            public byte byMasterChannelControllerStatus;
            public byte bySlaveChannelControllerStatus;
            public byte byAntiSneakServerStatus;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
            public byte[] byRes3;
            public uint dwAllowFaceNum;
            public uint dwBlockFaceNum;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 108)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FINGER_PRINT_INFO_CTRL_V50_ByCardNo
        {
            public int dwSize;
            /// <summary>
            /// 删除方式，0-按卡号（人员ID）方式删除，1-按读卡器删除
            /// </summary>
            public byte byMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3)]
            public byte[] byRes1;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_FINGER_PRINT_BYCARD_V50 struProcessMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FINGER_PRINT_BYCARD_V50
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN)]
            public byte[] byCardNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CARD_READER_NUM_512)]
            public byte[] byEnableCardReader;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_FINGER_PRINT_NUM)]
            public byte[] byFingerPrintID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2)]
            public byte[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_SDK_EMPLOYEE_NO_LEN)]
            public byte[] byEmployeeNo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FINGER_PRINT_INFO_STATUS_V50
        {
            public int dwSize;
            public int dwCardReaderNo;
            public byte byStatus;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 63)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CAPTURE_FINGERPRINT_COND
        {
            public int dwSize;
            /// <summary>
            /// 图片类型：0-无意义
            /// </summary>
            public byte byFingerPrintPicType;
            /// <summary>
            /// 手指编号，范围1-10
            /// </summary>
            public byte byFingerNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 126)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CAPTURE_FINGERPRINT_CFG
        {
            public int dwSize;
            /// <summary>
            /// 指纹数据大小
            /// </summary>
            public int dwFingerPrintDataSize;
            /// <summary>
            /// 指纹数据内容
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_FINGER_PRINT_LEN)]
            public byte[] byFingerData;
            /// <summary>
            /// 指纹图片大小，等于0时，代表无指纹图片数据
            /// </summary>
            public int dwFingerPrintPicSize;
            /// <summary>
            /// 指纹图片缓存
            /// </summary>
            public IntPtr pFingerPrintPicBuffer;
            /// <summary>
            /// 手指编号，范围1-10
            /// </summary>
            public byte byFingerNo;
            /// <summary>
            /// 指纹质量，范围1-100
            /// </summary>
            public byte byFingerPrintQuality;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 62)]
            public byte[] byRes;
        }

        /// <summary>
        /// Network Configure Structure(V50)
        /// </summary>
        //Network Configure Structure(V50)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_NETCFG_V50
        {
            public uint dwSize;
            /// <summary>
            /// Network Port
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ETHERNET, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ETHERNET_V30[] struEtherNet;
            /// <summary>
            /// reserve
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPADDR[] struRes1;
            /// <summary>
            /// IP address of remote management host
            /// </summary>
            public NET_DVR_IPADDR struAlarmHostIpAddr;
            /// <summary>
            /// reserve
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// Port of remote management Host
            /// </summary>
            public ushort wAlarmHostIpPort;
            /// <summary>
            /// Whether to enable the DHCP 0xff- invalid 0- enabled 1- not enabled
            /// </summary>
            public byte byUseDhcp;
            /// <summary>
            /// IPv6 allocation, 0- routing announcement, 1- manually, 2- enable DHCP allocation
            /// </summary>
            public byte byIPv6Mode;
            /// <summary>
            /// IP address of the domain name server 1
            /// </summary>
            public NET_DVR_IPADDR struDnsServer1IpAddr;
            /// <summary>
            /// IP address of the domain name server 2
            /// </summary>
            public NET_DVR_IPADDR struDnsServer2IpAddr;
            /// <summary>
            /// IP parse server domain name or IP address
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byIpResolver;
            /// <summary>
            /// Parsing IP server port number
            /// </summary>
            public ushort wIpResolverPort;
            /// <summary>
            /// HTTP port number
            /// </summary>
            public ushort wHttpPortNo;
            /// <summary>
            /// Multicast group address
            /// </summary>
            public NET_DVR_IPADDR struMulticastIpAddr;
            /// <summary>
            /// Gateway address
            /// </summary>
            public NET_DVR_IPADDR struGatewayIpAddr;
            public NET_DVR_PPPOECFG struPPPoE;
            /// <summary>
            /// Private multicast search, 0- default, 1- enabled, 2 - disabled
            /// </summary>
            public byte byEnablePrivateMulticastDiscovery;
            /// <summary>
            /// Onvif multicast search, 0- default, 1- enabled, 2 - disabled
            /// </summary>
            public byte byEnableOnvifMulticastDiscovery;
            /// <summary>
            /// Alarm host 2 port
            /// </summary>
            public ushort wAlarmHost2IpPort;
            /// <summary>
            /// Alarm host 2 IP addresses
            /// </summary>
            public NET_DVR_IPADDR struAlarmHost2IpAddr;
            /// <summary>
            /// DNS Enabled, 0-close,1-open
            /// </summary>
            public byte byEnableDNS;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 599, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        public const int MAX_CENTERNUM = 4;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMHOST_NETCFG
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CENTERNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ALARMHOST_NETPARAM[] struNetCenter;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMHOST_ABILITY
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 报警输入口总数(防区),包括级联
            /// </summary>
            public ushort wTotalAlarmInNum;
            /// <summary>
            /// 本地报警输入口
            /// </summary>
            public ushort wLocalAlarmInNum;
            /// <summary>
            /// 可扩展的报警输入口
            /// </summary>
            public ushort wExpandAlarmInNum;
            /// <summary>
            /// 报警输出口总数 （设备支持的总数）
            /// </summary>
            public ushort wTotalAlarmOutNum;
            /// <summary>
            /// 本地报警输出口个数
            /// </summary>
            public ushort wLocalAlarmOutNum;
            /// <summary>
            /// 可扩展的报警输出口
            /// </summary>
            public ushort wExpandAlarmOutNum;
            /// <summary>
            /// 报警输出口总数 （设备支持的总数）
            /// </summary>
            public ushort wTotalRs485Num;
            /// <summary>
            /// 本地485口数
            /// </summary>
            public ushort wLocalRs485Num;
            /// <summary>
            /// 可扩展的485口数
            /// </summary>
            public ushort wExpandRs485Num;
            /// <summary>
            /// 全双工的485口数
            /// </summary>
            public ushort wFullDuplexRs485Num;
            /// <summary>
            /// 模拟量最大个数 (设备支持的总数)
            /// </summary>
            public ushort wTotalSensorNum;
            /// <summary>
            /// 本地模拟量个数
            /// </summary>
            public ushort wLocalSensorNum;
            /// <summary>
            /// 可扩展的模拟量个数
            /// </summary>
            public ushort wExpandSensorNum;
            /// <summary>
            /// 语音输出个数
            /// </summary>
            public ushort wAudioOutNum;
            /// <summary>
            /// 门禁个数
            /// </summary>
            public ushort wGatewayNum;
            /// <summary>
            /// 电锁个数
            /// </summary>
            public ushort wElectroLockNum;
            /// <summary>
            /// 主机警号数目
            /// </summary>
            public ushort wSirenNum;
            /// <summary>
            /// 可划分子系统数目
            /// </summary>
            public ushort wSubSystemNum;
            /// <summary>
            /// 网络用户数
            /// </summary>
            public ushort wNetUserNum;
            /// <summary>
            /// 键盘数
            /// </summary>
            public ushort wKeyboardNum;
            /// <summary>
            /// 操作用户数
            /// </summary>
            public ushort wOperatorUserNum;
            /// <summary>
            /// 是否支持常开、常闭探测器，1-支持，0-不支持
            /// </summary>
            public byte bySupportDetector;
            /// <summary>
            /// 是否支持防区灵敏度，1-支持，0-不支持
            /// </summary>
            public byte bySupportSensitivity;
            /// <summary>
            /// 是否支持组旁路，1-支持，0-不支持
            /// </summary>
            public byte bySupportArrayBypass;
            /// <summary>
            /// 是否支持防区延迟,1-支持，0-不支持
            /// </summary>
            public byte bySupportAlarmInDelay;
            /// <summary>
            /// 支持的防区类型,数组0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区 8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区15-无
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] bySupportAlarmInType;
            /// <summary>
            /// 支持电话个数
            /// </summary>
            public byte byTelNum;
            /// <summary>
            /// 中心组个数
            /// </summary>
            public byte byCenterGroupNum;
            /// <summary>
            /// GPRS中心数，最多4个
            /// </summary>
            public byte byGPRSNum;
            /// <summary>
            /// 网络中心数，最多4个
            /// </summary>
            public byte byNetNum;
            /// <summary>
            /// 音频个数
            /// </summary>
            public byte byAudioNum;
            /// <summary>
            /// 3G模块个数
            /// </summary>
            public byte by3GNum;
            /// <summary>
            /// 模拟视频通道个数
            /// </summary>
            public byte byAnalogVideoChanNum;
            /// <summary>
            /// 数字视频通道个数
            /// </summary>
            public byte byDigitalVideoChanNum;
            /// <summary>
            /// 子系统布防类型，0-表示不支持，1-表示支持。bit0-普通布防（注：网络小主机只支持普通布防，在能力集中加这个字段的时候网络小主机已经发布，所以网络小主机中该字段为0，所以用0表示支持，1表示不支持。对外接口中SDK内部会做兼容），bit1-即时布防，bit2-留守布防。
            /// </summary>
            public byte bySubSystemArmType;
            /// <summary>
            /// 公共子系统个数
            /// </summary>
            public byte byPublicSubSystemNum;
            /// <summary>
            /// 按位表示，结果非0表示支持，0表示不支持
            /// </summary>
            public uint dwSupport1;
            /// <summary>
            /// 子系统事件，按位表示，0表示不支持，非0表示支持,bit0-进入延时，bit1-退出延时，bit2-布防，bit3-撤防，bit4-报警，bit5-消除报警记忆
            /// </summary>
            public uint dwSubSystemEvent;
            /// <summary>
            /// 全局事件，按位表示，0表示不支持，非0表示支持，bit0-交流电掉电，bit1-电池电压低，bit2-电话线掉线，bit3-有线网络异常，bit4-无线网络异常，bit5-硬盘故障,bit6-3G/4G信号异常, bit7-（模块链接）第三方主机掉线,bit8-WIFI通信故障，bit9-RF信号干扰故障
            /// </summary>
            public uint dwOverallEvent;
            /// <summary>
            /// 设备支持的故障类型，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-主键盘掉线，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常
            /// </summary>
            public uint dwFaultType;
            /// <summary>
            /// 公共子系统可关联的子系统个数
            /// </summary>
            public byte byPublicSubsystemAssociateSubsystemNum;
            /// <summary>
            /// 全局键盘个数
            /// </summary>
            public byte byOverallKeyboard;
            /// <summary>
            /// 防护舱控制器能力，按位表示，结果非0表示支持，0表示不支持
            /// </summary>
            public ushort wSafetyCabinSupport;
            /// <summary>
            /// 485虚拟槽位号
            /// </summary>
            public byte by485SlotNum;
            /// <summary>
            /// 值恒为1，禁止1号子系统关闭使能
            /// </summary>
            public byte bySubSystemAttributeAbility;
            /// <summary>
            /// 键盘地址数
            /// </summary>
            public ushort wKeyboardAddrNum;
            /// <summary>
            /// 警灯数目
            /// </summary>
            public byte byAlarmLampNum;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 117, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        public const int ALARMHOST_ABILITY = 0x500;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMHOST_NETCFG_V50
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CENTERNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ALARMHOST_NETPARAM_V50[] struNetCenter;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMHOST_NETPARAM_V50
        {
            public uint dwSize;
            public NET_DVR_IPADDR struIP;
            public ushort wPort;
            /// <summary>
            /// 0 - 无意义, 1 - ipv4/ipv6地址，2 - 域名
            /// </summary>
            public byte byAddressType;
            /// <summary>
            /// 使能，0-不启用，1-启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 域名，GPRS参数配置、网络参数配置时该字段均有效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byDomainName;
            /// <summary>
            /// 1-private 2-NAL2300, 3-Ehome
            /// </summary>
            public byte byReportProtocol;
            /// <summary>
            /// 协议为NAL2300时有效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACCOUNTNUM_LEN_32, ArraySubType = UnmanagedType.I1)]
            public byte[] byDevID;
            /// <summary>
            /// EHome协议版本，0-无意义,1–v2.0，2–v4.0，3-v5.0
            /// </summary>
            public byte byProtocolVersion;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// EHome Key（用于EHome 5.0版本）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_SDK_EHOME_KEY_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byEHomeKey;
            /// <summary>
            /// GPRS的域名解析是在固定的服务器上进行的，所以不需要给解析服务器的信息预留一些字段
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 28, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        /// <summary>
        /// Set Net info V50
        /// </summary>
        public const int NET_DVR_SET_ALARMHOST_NETCFG_V50 = 2225;
        /// <summary>
        /// Get Net infoV50
        /// </summary>
        public const int NET_DVR_GET_ALARMHOST_NETCFG_V50 = 2224;
        public const int MAX_AUDIO_V40 = 8;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SIMPLE_DAYTIME
        {
            /// <summary>
            /// hour
            /// </summary>
            public byte byHour;
            /// <summary>
            /// minute
            /// </summary>
            public byte byMinute;
            /// <summary>
            /// second
            /// </summary>
            public byte bySecond;
            public byte byRes;
        }
        /// <summary>
        /// Get network parameter configuration (V50)
        /// </summary>
        public const int NET_DVR_GET_NETCFG_V50 = 1015;
        /// <summary>
        /// Set network parameter configuration (V50)
        /// </summary>
        public const int NET_DVR_SET_NETCFG_V50 = 1016;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INDEX
        {
            public uint iIndex;
        }

        public struct NET_DVR_INBUFF
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.U4)]
            public uint[] StatusList;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40
        {
            public uint dwSize;
            public byte byValid;
            /// <summary>
            /// 1-All alarm data 2-not alarm data 3-all data,4-zone report,5-not zone report
            /// </summary>
            public byte byDataType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// alarm channels, 1-T1,2-T2, 3-N1, 4-N2,5-G1, 6-G2 ,7-N3, 8-N4
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.Struct)]
            public byte[] byChanAlarmMode;
            /// <summary>
            /// send to these centers while send fail 0-not choose,1-choose
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.Struct)]
            public byte[] byDealFailCenter;
            /// <summary>
            /// zone report type,0-not upload,1-upload
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 512, ArraySubType = UnmanagedType.Struct)]
            public byte[] byZoneReport;
            /// <summary>
            /// not zone report, 0-not upload,1-upload byNonZoneReport[0]-soft zone report byNonZoneReport[1]-system status report byNonZoneReport[2]-cancel report byNonZoneReport[3]-test report byNonZoneReport[4]-arm report byNonZoneReport[5]-disarm report byNonZoneReport[6]-duress report byNonZoneReport[7]-alarm recovery report byNonZoneReport[8]-bypass report byNonZoneReport[9]-bypass restore report,byNonZoneReport[10]-detector connect status report(online/offline),byNonZoneReport[11]-detector power status report(normal/low);bit12-video alarm report
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.Struct)]
            public byte[] byNonZoneReport;
            /// <summary>
            /// network card center,0-primary card_1,1-primary card_2,2-extend card_1,3-extend card_2
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.Struct)]
            public byte[] byAlarmNetCard;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 252, ArraySubType = UnmanagedType.Struct)]
            public byte[] byRes2;
        }
        /// <summary>
        /// door name len
        /// </summary>
        public const int DOOR_NAME_LEN = 32;
        /// <summary>
        /// stress password len
        /// </summary>
        public const int STRESS_PASSWORD_LEN = 8;
        /// <summary>
        /// super password len
        /// </summary>
        public const int SUPER_PASSWORD_LEN = 8;
        public const int UNLOCK_PASSWORD_LEN = 8;
        public const int MAX_DOOR_NUM = 32;
        public const int MAX_GROUP_NUM = 32;
        public const int LOCAL_CONTROLLER_NAME_LEN = 32;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DOOR_CFG
        {
            public uint dwSize;
            /// <summary>
            /// door name
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = DOOR_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDoorName;
            /// <summary>
            /// magnetic type, 0-always close 1-always open
            /// </summary>
            public byte byMagneticType;
            /// <summary>
            /// open button type,  0-always close 1-always open
            /// </summary>
            public byte byOpenButtonType;
            /// <summary>
            /// open duration time, 1-255s(ladder control relay action time)
            /// </summary>
            public byte byOpenDuration;
            /// <summary>
            /// disable open duration , 1-255s
            /// </summary>
            public byte byDisabledOpenDuration;
            /// <summary>
            /// magnetic alarm time out , 0-255s,0 means not to alarm
            /// </summary>
            public byte byMagneticAlarmTimeout;
            /// <summary>
            /// whether to enable door lock, 0-disable, 1-enable
            /// </summary>
            public byte byEnableDoorLock;
            /// <summary>
            /// whether to enable leader card , 0-disable, 1-enable
            /// </summary>
            public byte byEnableLeaderCard;
            /// <summary>
            /// First card mode, 0 - first card function is not enabled, and 1 - the first card normally open mode, 2 - the first card authorization mode (using this field, the byEnableLeaderCard is invalid )
            /// </summary>
            public byte byLeaderCardMode;
            /// <summary>
            /// leader card open duration 1-1440min
            /// </summary>
            public uint dwLeaderCardOpenDuration;
            /// <summary>
            /// stress ppassword
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = STRESS_PASSWORD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byStressPassword;
            /// <summary>
            /// super password
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = SUPER_PASSWORD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] bySuperPassword;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = UNLOCK_PASSWORD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byUnlockPassword;
            /// <summary>
            /// Read-only, whether the connection on the local controller, 0 - no, 1 - yes
            /// </summary>
            public byte byUseLocalController;
            public byte byRes1;
            /// <summary>
            /// Read-only, on-site controller serial number, 1-64, 0 on behalf of unregistered
            /// </summary>
            public ushort wLocalControllerID;
            /// <summary>
            /// Read-only, on-site controller door number, 1-4, 0 represents the unregistered
            /// </summary>
            public ushort wLocalControllerDoorNumber;
            /// <summary>
            /// Read-only, on-site controller online status: 0 - offline, 1 - online, 2 - loop of RS485 serial port 1 on 1, 3 - loop of RS485 serial port 2 on 2, 4 - loop of RS485 serial port 1, 5 - loop of RS485 serial port 2, 6 - loop 3 of RS485 serial port 1, 7 - the loop on the RS485 serial port on the 3 4 2, 8 - loop on the RS485 serial port 1, 9 - loop 4 of RS485 serial port 2 (read-only)
            /// </summary>
            public ushort wLocalControllerStatus;
            /// <summary>
            /// Whether to enable the door input detection (1 public byte, 0 is not enabled, 1 is enabled, is not enabled by default)
            /// </summary>
            public byte byLockInputCheck;
            /// <summary>
            /// Door lock input type
            /// </summary>
            public byte byLockInputType;
            /// <summary>
            /// Gate terminal working mode
            /// </summary>
            public byte byDoorTerminalMode;
            /// <summary>
            /// Whether to enable the open button
            /// </summary>
            public byte byOpenButton;
            /// <summary>
            /// ladder control delay time,1-255min
            /// </summary>
            public byte byLadderControlDelayTime;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 43, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        /// <summary>
        /// get door parameter
        /// </summary>
        public const int NET_DVR_GET_DOOR_CFG = 2108;
        /// <summary>
        /// set door parameter
        /// </summary>
        public const int NET_DVR_SET_DOOR_CFG = 2109;
        /// <summary>
        /// set data report mode v30
        /// </summary>
        public const int NET_DVR_SET_ALARMHOST_REPORT_CENTER_V40 = 2065;
        /// <summary>
        /// ***********操作异常类型(消息方式, 回调方式(保留))***************
        /// </summary>
        public const int EXCEPTION_EXCHANGE = 32768;
        /// <summary>
        /// 语音对讲异常
        /// </summary>
        public const int EXCEPTION_AUDIOEXCHANGE = 32769;
        /// <summary>
        /// 报警异常
        /// </summary>
        public const int EXCEPTION_ALARM = 32770;
        /// <summary>
        /// 网络预览异常
        /// </summary>
        public const int EXCEPTION_PREVIEW = 32771;
        /// <summary>
        /// 透明通道异常
        /// </summary>
        public const int EXCEPTION_SERIAL = 32772;
        /// <summary>
        /// 预览时重连
        /// </summary>
        public const int EXCEPTION_RECONNECT = 32773;
        /// <summary>
        /// 报警时重连
        /// </summary>
        public const int EXCEPTION_ALARMRECONNECT = 32774;
        /// <summary>
        /// 透明通道重连
        /// </summary>
        public const int EXCEPTION_SERIALRECONNECT = 32775;
        /// <summary>
        /// 回放异常
        /// </summary>
        public const int EXCEPTION_PLAYBACK = 32784;
        /// <summary>
        /// 硬盘格式化
        /// </summary>
        public const int EXCEPTION_DISKFMT = 32785;
        /// <summary>
        /// ******************预览回调函数********************
        /// </summary>
        public const int NET_DVR_SYSHEAD = 1;
        /// <summary>
        /// 视频流数据（包括复合流和音视频分开的视频流数据）
        /// </summary>
        public const int NET_DVR_STREAMDATA = 2;
        /// <summary>
        /// 音频流数据
        /// </summary>
        public const int NET_DVR_AUDIOSTREAMDATA = 3;
        /// <summary>
        /// 标准视频流数据
        /// </summary>
        public const int NET_DVR_STD_VIDEODATA = 4;
        /// <summary>
        /// 标准音频流数据
        /// </summary>
        public const int NET_DVR_STD_AUDIODATA = 5;
        /// <summary>
        /// 回调预览中的状态和消息
        /// </summary>
        public const int NET_DVR_REALPLAYEXCEPTION = 111;
        /// <summary>
        /// 预览时连接断开
        /// </summary>
        public const int NET_DVR_REALPLAYNETCLOSE = 112;
        /// <summary>
        /// 预览5s没有收到数据
        /// </summary>
        public const int NET_DVR_REALPLAY5SNODATA = 113;
        /// <summary>
        /// 预览重连
        /// </summary>
        public const int NET_DVR_REALPLAYRECONNECT = 114;
        /// <summary>
        /// ******************回放回调函数********************
        /// </summary>
        public const int NET_DVR_PLAYBACKOVER = 101;
        /// <summary>
        /// 回放异常
        /// </summary>
        public const int NET_DVR_PLAYBACKEXCEPTION = 102;
        /// <summary>
        /// 回放时候连接断开
        /// </summary>
        public const int NET_DVR_PLAYBACKNETCLOSE = 103;
        /// <summary>
        /// 回放5s没有收到数据
        /// </summary>
        public const int NET_DVR_PLAYBACK5SNODATA = 104;
        /// <summary>
        /// *******************回调函数类型 end***********************
        /// 设备型号(DVR类型)
        /// 设备类型
        /// </summary>
        public const int DVR = 1;
        /// <summary>
        /// atm dvr
        /// </summary>
        public const int ATMDVR = 2;
        /// <summary>
        /// DVS
        /// </summary>
        public const int DVS = 3;
        /// <summary>
        /// 6001D
        /// </summary>
        public const int DEC = 4;
        /// <summary>
        /// 6001F
        /// </summary>
        public const int ENC_DEC = 5;
        /// <summary>
        /// 8000HC
        /// </summary>
        public const int DVR_HC = 6;
        /// <summary>
        /// 8000HT
        /// </summary>
        public const int DVR_HT = 7;
        /// <summary>
        /// 8000HF
        /// </summary>
        public const int DVR_HF = 8;
        /// <summary>
        /// 8000HS DVR(no audio)
        /// </summary>
        public const int DVR_HS = 9;
        /// <summary>
        /// 8016HTS DVR(no audio)
        /// </summary>
        public const int DVR_HTS = 10;
        /// <summary>
        /// HB DVR(SATA HD)
        /// </summary>
        public const int DVR_HB = 11;
        /// <summary>
        /// 8000HCS DVR
        /// </summary>
        public const int DVR_HCS = 12;
        /// <summary>
        /// 带ATA硬盘的DVS
        /// </summary>
        public const int DVS_A = 13;
        /// <summary>
        /// 8000HC-S
        /// </summary>
        public const int DVR_HC_S = 14;
        /// <summary>
        /// 8000HT-S
        /// </summary>
        public const int DVR_HT_S = 15;
        /// <summary>
        /// 8000HF-S
        /// </summary>
        public const int DVR_HF_S = 16;
        /// <summary>
        /// 8000HS-S
        /// </summary>
        public const int DVR_HS_S = 17;
        /// <summary>
        /// ATM-S
        /// </summary>
        public const int ATMDVR_S = 18;
        /// <summary>
        /// 7000H系列
        /// </summary>
        public const int LOWCOST_DVR = 19;
        /// <summary>
        /// 多路解码器
        /// </summary>
        public const int DEC_MAT = 20;
        /// <summary>
        /// mobile DVR
        /// </summary>
        public const int DVR_MOBILE = 21;
        /// <summary>
        /// 8000HD-S
        /// </summary>
        public const int DVR_HD_S = 22;
        /// <summary>
        /// 8000HD-SL
        /// </summary>
        public const int DVR_HD_SL = 23;
        /// <summary>
        /// 8000HC-SL
        /// </summary>
        public const int DVR_HC_SL = 24;
        /// <summary>
        /// 8000HS_ST
        /// </summary>
        public const int DVR_HS_ST = 25;
        /// <summary>
        /// 6000HW
        /// </summary>
        public const int DVS_HW = 26;
        /// <summary>
        /// 多路解码器
        /// </summary>
        public const int DS630X_D = 27;
        /// <summary>
        /// IP 摄像机
        /// </summary>
        public const int IPCAM = 30;
        /// <summary>
        /// X52MF系列,752MF,852MF
        /// </summary>
        public const int MEGA_IPCAM = 31;
        /// <summary>
        /// X62MF系列可接入9000设备,762MF,862MF
        /// </summary>
        public const int IPCAM_X62MF = 32;
        /// <summary>
        /// IP 标清球机
        /// </summary>
        public const int IPDOME = 40;
        /// <summary>
        /// IP 200万高清球机
        /// </summary>
        public const int IPDOME_MEGA200 = 41;
        /// <summary>
        /// IP 130万高清球机
        /// </summary>
        public const int IPDOME_MEGA130 = 42;
        /// <summary>
        /// IP 模块
        /// </summary>
        public const int IPMOD = 50;
        /// <summary>
        /// DS71XXH_S
        /// </summary>
        public const int DS71XX_H = 71;
        /// <summary>
        /// DS72XXH_S
        /// </summary>
        public const int DS72XX_H_S = 72;
        /// <summary>
        /// DS73XXH_S
        /// </summary>
        public const int DS73XX_H_S = 73;
        /// <summary>
        /// DS76XX_H_S
        /// </summary>
        public const int DS76XX_H_S = 76;
        /// <summary>
        /// DS81XX_HS_S
        /// </summary>
        public const int DS81XX_HS_S = 81;
        /// <summary>
        /// DS81XX_HL_S
        /// </summary>
        public const int DS81XX_HL_S = 82;
        /// <summary>
        /// DS81XX_HC_S
        /// </summary>
        public const int DS81XX_HC_S = 83;
        /// <summary>
        /// DS81XX_HD_S
        /// </summary>
        public const int DS81XX_HD_S = 84;
        /// <summary>
        /// DS81XX_HE_S
        /// </summary>
        public const int DS81XX_HE_S = 85;
        /// <summary>
        /// DS81XX_HF_S
        /// </summary>
        public const int DS81XX_HF_S = 86;
        /// <summary>
        /// DS81XX_AH_S
        /// </summary>
        public const int DS81XX_AH_S = 87;
        /// <summary>
        /// DS81XX_AHF_S
        /// </summary>
        public const int DS81XX_AHF_S = 88;
        /// <summary>
        /// DS90XX_HF_S
        /// </summary>
        public const int DS90XX_HF_S = 90;
        /// <summary>
        /// DS91XX_HF_S
        /// </summary>
        public const int DS91XX_HF_S = 91;
        /// <summary>
        /// 91XXHD-S(MD)
        /// </summary>
        public const int DS91XX_HD_S = 92;
        /// <summary>
        /// ********************设备类型 end**********************
        /// ********************能力集类型 begin**********************
        /// </summary>
        public const int DEVICE_SOFTHARDWARE_ABILITY = 0x001;
        public const int DEVICE_NETWORK_ABILITY = 0x002;
        public const int DEVICE_ENCODE_ALL_ABILITY_V20 = 0x008;
        public const int IPC_FRONT_PARAMETER_V20 = 0x009;
        public const int DEVICE_RAID_ABILITY = 0x007;
        public const int DEVICE_ALARM_ABILITY = 0x00a;
        public const int DEVICE_DYNCHAN_ABILITY = 0x00b;
        public const int DEVICE_USER_ABILITY = 0x00c;
        public const int DEVICE_NETAPP_ABILITY = 0x00d;
        public const int DEVICE_VIDEOPIC_ABILITY = 0x00e;
        public const int DEVICE_JPEG_CAP_ABILITY = 0x00f;
        public const int DEVICE_SERIAL_ABILITY = 0x010;
        public const int DEVICE_ABILITY_INFO = 0x011;
        /// <summary>
        /// ********************能力集类型 end**********************
        /// ***********************************************
        /// 门禁事件类型
        /// ************************************************
        /// Alarm
        /// Main Type
        /// public const int MAJOR_ALARM = 0x1;
        /// Hypo- Type
        /// </summary>
        public const int MINOR_ALARMIN_SHORT_CIRCUIT = 0x400;
        /// <summary>
        /// region broken circuit
        /// </summary>
        public const int MINOR_ALARMIN_BROKEN_CIRCUIT = 0x401;
        /// <summary>
        /// region exception
        /// </summary>
        public const int MINOR_ALARMIN_EXCEPTION = 0x402;
        /// <summary>
        /// region resume
        /// </summary>
        public const int MINOR_ALARMIN_RESUME = 0x403;
        /// <summary>
        /// host desmantle alarm
        /// </summary>
        public const int MINOR_HOST_DESMANTLE_ALARM = 0x404;
        /// <summary>
        /// host desmantle resume
        /// </summary>
        public const int MINOR_HOST_DESMANTLE_RESUME = 0x405;
        /// <summary>
        /// card reader desmantle alarm
        /// </summary>
        public const int MINOR_CARD_READER_DESMANTLE_ALARM = 0x406;
        /// <summary>
        /// card reader desmantle resume
        /// </summary>
        public const int MINOR_CARD_READER_DESMANTLE_RESUME = 0x407;
        /// <summary>
        /// case sensor alarm
        /// </summary>
        public const int MINOR_CASE_SENSOR_ALARM = 0x408;
        /// <summary>
        /// case sensor resume
        /// </summary>
        public const int MINOR_CASE_SENSOR_RESUME = 0x409;
        /// <summary>
        /// stress alarm
        /// </summary>
        public const int MINOR_STRESS_ALARM = 0x40a;
        /// <summary>
        /// offline ecent nearly full
        /// </summary>
        public const int MINOR_OFFLINE_ECENT_NEARLY_FULL = 0x40b;
        /// <summary>
        /// card max authenticate fall
        /// </summary>
        public const int MINOR_CARD_MAX_AUTHENTICATE_FAIL = 0x40c;
        /// <summary>
        /// SD card is full
        /// </summary>
        public const int MINOR_SD_CARD_FULL = 0x40d;
        /// <summary>
        /// lingage capture picture
        /// </summary>
        public const int MINOR_LINKAGE_CAPTURE_PIC = 0x40e;
        /// <summary>
        /// Door control security module desmantle alarm
        /// </summary>
        public const int MINOR_SECURITY_MODULE_DESMANTLE_ALARM = 0x40f;
        /// <summary>
        /// Door control security module desmantle resume
        /// </summary>
        public const int MINOR_SECURITY_MODULE_DESMANTLE_RESUME = 0x410;
        /// <summary>
        /// POS Start
        /// </summary>
        public const int MINOR_POS_START_ALARM = 0x411;
        /// <summary>
        /// POS end
        /// </summary>
        public const int MINOR_POS_END_ALARM = 0x412;
        /// <summary>
        /// face image quality low
        /// </summary>
        public const int MINOR_FACE_IMAGE_QUALITY_LOW = 0x413;
        /// <summary>
        /// finger print quality low
        /// </summary>
        public const int MINOR_FINGE_RPRINT_QUALITY_LOW = 0x414;
        /// <summary>
        /// Fire import short circuit
        /// </summary>
        public const int MINOR_FIRE_IMPORT_SHORT_CIRCUIT = 0x415;
        /// <summary>
        /// Fire import broken circuit
        /// </summary>
        public const int MINOR_FIRE_IMPORT_BROKEN_CIRCUIT = 0x416;
        /// <summary>
        /// Fire import resume
        /// </summary>
        public const int MINOR_FIRE_IMPORT_RESUME = 0x417;
        /// <summary>
        /// fire button trigger
        /// </summary>
        public const int MINOR_FIRE_BUTTON_TRIGGER = 0x418;
        /// <summary>
        /// fire button resume
        /// </summary>
        public const int MINOR_FIRE_BUTTON_RESUME = 0x419;
        /// <summary>
        /// maintenance button trigger
        /// </summary>
        public const int MINOR_MAINTENANCE_BUTTON_TRIGGER = 0x41a;
        /// <summary>
        /// maintenance button resume
        /// </summary>
        public const int MINOR_MAINTENANCE_BUTTON_RESUME = 0x41b;
        /// <summary>
        /// emergency button trigger
        /// </summary>
        public const int MINOR_EMERGENCY_BUTTON_TRIGGER = 0x41c;
        /// <summary>
        /// emergency button resume
        /// </summary>
        public const int MINOR_EMERGENCY_BUTTON_RESUME = 0x41d;
        /// <summary>
        /// distract controller alarm
        /// </summary>
        public const int MINOR_DISTRACT_CONTROLLER_ALARM = 0x41e;
        /// <summary>
        /// distract controller resume
        /// </summary>
        public const int MINOR_DISTRACT_CONTROLLER_RESUME = 0x41f;
        /// <summary>
        /// channel controller desmantle alarm
        /// </summary>
        public const int MINOR_CHANNEL_CONTROLLER_DESMANTLE_ALARM = 0x422;
        /// <summary>
        /// channel controller desmantle resume
        /// </summary>
        public const int MINOR_CHANNEL_CONTROLLER_DESMANTLE_RESUME = 0x423;
        /// <summary>
        /// channel controller fire import alarm
        /// </summary>
        public const int MINOR_CHANNEL_CONTROLLER_FIRE_IMPORT_ALARM = 0x424;
        /// <summary>
        /// channel controller fire import resume
        /// </summary>
        public const int MINOR_CHANNEL_CONTROLLER_FIRE_IMPORT_RESUME = 0x425;
        /// <summary>
        /// printer no paper
        /// </summary>
        public const int MINOR_PRINTER_OUT_OF_PAPER = 0x440;
        /// <summary>
        /// Legal event nearly full
        /// </summary>
        public const int MINOR_LEGAL_EVENT_NEARLY_FULL = 0x442;
        /// <summary>
        /// Exception
        /// Main Type
        /// public const int MAJOR_EXCEPTION = 0x2;
        /// Hypo- Type
        /// public const int MINOR_NET_BROKEN = 0x27; // Network disconnected
        /// </summary>
        public const int MINOR_RS485_DEVICE_ABNORMAL = 0x3a;
        /// <summary>
        /// RS485 connect status exception recovery
        /// </summary>
        public const int MINOR_RS485_DEVICE_REVERT = 0x3b;
        /// <summary>
        /// device power on
        /// </summary>
        public const int MINOR_DEV_POWER_ON = 0x400;
        /// <summary>
        /// device power off
        /// </summary>
        public const int MINOR_DEV_POWER_OFF = 0x401;
        /// <summary>
        /// watch dog reset
        /// </summary>
        public const int MINOR_WATCH_DOG_RESET = 0x402;
        /// <summary>
        /// low battery
        /// </summary>
        public const int MINOR_LOW_BATTERY = 0x403;
        /// <summary>
        /// battery resume
        /// </summary>
        public const int MINOR_BATTERY_RESUME = 0x404;
        /// <summary>
        /// AC off
        /// </summary>
        public const int MINOR_AC_OFF = 0x405;
        /// <summary>
        /// AC resume
        /// </summary>
        public const int MINOR_AC_RESUME = 0x406;
        /// <summary>
        /// Net resume
        /// </summary>
        public const int MINOR_NET_RESUME = 0x407;
        /// <summary>
        /// FLASH abnormal
        /// </summary>
        public const int MINOR_FLASH_ABNORMAL = 0x408;
        /// <summary>
        /// card reader offline
        /// </summary>
        public const int MINOR_CARD_READER_OFFLINE = 0x409;
        /// <summary>
        /// card reader resume
        /// </summary>
        public const int MINOR_CARD_READER_RESUME = 0x40a;
        /// <summary>
        /// Indicator Light Off
        /// </summary>
        public const int MINOR_INDICATOR_LIGHT_OFF = 0x40b;
        /// <summary>
        /// Indicator Light Resume
        /// </summary>
        public const int MINOR_INDICATOR_LIGHT_RESUME = 0x40c;
        /// <summary>
        /// channel controller off
        /// </summary>
        public const int MINOR_CHANNEL_CONTROLLER_OFF = 0x40d;
        /// <summary>
        /// channel controller resume
        /// </summary>
        public const int MINOR_CHANNEL_CONTROLLER_RESUME = 0x40e;
        /// <summary>
        /// Door control security module off
        /// </summary>
        public const int MINOR_SECURITY_MODULE_OFF = 0x40f;
        /// <summary>
        /// Door control security module resume
        /// </summary>
        public const int MINOR_SECURITY_MODULE_RESUME = 0x410;
        /// <summary>
        /// battery electric low
        /// </summary>
        public const int MINOR_BATTERY_ELECTRIC_LOW = 0x411;
        /// <summary>
        /// battery electric resume
        /// </summary>
        public const int MINOR_BATTERY_ELECTRIC_RESUME = 0x412;
        /// <summary>
        /// Local control net broken
        /// </summary>
        public const int MINOR_LOCAL_CONTROL_NET_BROKEN = 0x413;
        /// <summary>
        /// Local control net resume
        /// </summary>
        public const int MINOR_LOCAL_CONTROL_NET_RSUME = 0x414;
        /// <summary>
        /// Master RS485 loop node broken
        /// </summary>
        public const int MINOR_MASTER_RS485_LOOPNODE_BROKEN = 0x415;
        /// <summary>
        /// Master RS485 loop node resume
        /// </summary>
        public const int MINOR_MASTER_RS485_LOOPNODE_RESUME = 0x416;
        /// <summary>
        /// Local control offline
        /// </summary>
        public const int MINOR_LOCAL_CONTROL_OFFLINE = 0x417;
        /// <summary>
        /// Local control resume
        /// </summary>
        public const int MINOR_LOCAL_CONTROL_RESUME = 0x418;
        /// <summary>
        /// Local downside RS485 loop node broken
        /// </summary>
        public const int MINOR_LOCAL_DOWNSIDE_RS485_LOOPNODE_BROKEN = 0x419;
        /// <summary>
        /// Local downside RS485 loop node resume
        /// </summary>
        public const int MINOR_LOCAL_DOWNSIDE_RS485_LOOPNODE_RESUME = 0x41a;
        /// <summary>
        /// distract controller online
        /// </summary>
        public const int MINOR_DISTRACT_CONTROLLER_ONLINE = 0x41b;
        /// <summary>
        /// distract controller offline
        /// </summary>
        public const int MINOR_DISTRACT_CONTROLLER_OFFLINE = 0x41c;
        /// <summary>
        /// Id card reader not connected(intelligent dedicated)
        /// </summary>
        public const int MINOR_ID_CARD_READER_NOT_CONNECT = 0x41d;
        /// <summary>
        /// Id card reader connection restored(intelligent dedicated)
        /// </summary>
        public const int MINOR_ID_CARD_READER_RESUME = 0x41e;
        /// <summary>
        /// fingerprint module is not connected(intelligent dedicated)
        /// </summary>
        public const int MINOR_FINGER_PRINT_MODULE_NOT_CONNECT = 0x41f;
        /// <summary>
        /// The fingerprint module connection restored(intelligent dedicated)
        /// </summary>
        public const int MINOR_FINGER_PRINT_MODULE_RESUME = 0x420;
        /// <summary>
        /// Camera not connected
        /// </summary>
        public const int MINOR_CAMERA_NOT_CONNECT = 0x421;
        /// <summary>
        /// Camera connection restored
        /// </summary>
        public const int MINOR_CAMERA_RESUME = 0x422;
        /// <summary>
        /// COM not connected
        /// </summary>
        public const int MINOR_COM_NOT_CONNECT = 0x423;
        /// <summary>
        /// COM connection restored
        /// </summary>
        public const int MINOR_COM_RESUME = 0x424;
        /// <summary>
        /// device are not authorized
        /// </summary>
        public const int MINOR_DEVICE_NOT_AUTHORIZE = 0x425;
        /// <summary>
        /// people and ID card device online
        /// </summary>
        public const int MINOR_PEOPLE_AND_ID_CARD_DEVICE_ONLINE = 0x426;
        /// <summary>
        /// people and ID card device offline
        /// </summary>
        public const int MINOR_PEOPLE_AND_ID_CARD_DEVICE_OFFLINE = 0x427;
        /// <summary>
        /// local login lock
        /// </summary>
        public const int MINOR_LOCAL_LOGIN_LOCK = 0x428;
        /// <summary>
        /// local login unlock
        /// </summary>
        public const int MINOR_LOCAL_LOGIN_UNLOCK = 0x429;
        /// <summary>
        /// submarineback communicate break
        /// </summary>
        public const int MINOR_SUBMARINEBACK_COMM_BREAK = 0x42a;
        /// <summary>
        /// submarineback communicate resume
        /// </summary>
        public const int MINOR_SUBMARINEBACK_COMM_RESUME = 0x42b;
        /// <summary>
        /// motor sensor exception
        /// </summary>
        public const int MINOR_MOTOR_SENSOR_EXCEPTION = 0x42c;
        /// <summary>
        /// can bus exception
        /// </summary>
        public const int MINOR_CAN_BUS_EXCEPTION = 0x42d;
        /// <summary>
        /// can bus resume
        /// </summary>
        public const int MINOR_CAN_BUS_RESUME = 0x42e;
        /// <summary>
        /// gate temperature over run
        /// </summary>
        public const int MINOR_GATE_TEMPERATURE_OVERRUN = 0x42f;
        /// <summary>
        /// IR emitter exception
        /// </summary>
        public const int MINOR_IR_EMITTER_EXCEPTION = 0x430;
        /// <summary>
        /// IR emitter resume
        /// </summary>
        public const int MINOR_IR_EMITTER_RESUME = 0x431;
        /// <summary>
        /// lamp board communicate exception
        /// </summary>
        public const int MINOR_LAMP_BOARD_COMM_EXCEPTION = 0x432;
        /// <summary>
        /// lamp board communicate resume
        /// </summary>
        public const int MINOR_LAMP_BOARD_COMM_RESUME = 0x433;
        /// <summary>
        /// IR adaptor communicate exception
        /// </summary>
        public const int MINOR_IR_ADAPTOR_COMM_EXCEPTION = 0x434;
        /// <summary>
        /// IR adaptor communicate resume
        /// </summary>
        public const int MINOR_IR_ADAPTOR_COMM_RESUME = 0x435;
        /// <summary>
        /// printer online
        /// </summary>
        public const int MINOR_PRINTER_ONLINE = 0x436;
        /// <summary>
        /// printer offline
        /// </summary>
        public const int MINOR_PRINTER_OFFLINE = 0x437;
        /// <summary>
        /// 4G module online
        /// </summary>
        public const int MINOR_4G_MOUDLE_ONLINE = 0x438;
        /// <summary>
        /// 4G module offline
        /// </summary>
        public const int MINOR_4G_MOUDLE_OFFLINE = 0x439;
        /// <summary>
        /// Operation
        /// Main Type
        /// public const int MAJOR_OPERATION = 0x3;
        /// Hypo- Type
        /// public const int MINOR_LOCAL_UPGRADE = 0x5a; // Upgrade  (local)
        /// public const int MINOR_REMOTE_LOGIN = 0x70; // Login  (remote)
        /// public const int MINOR_REMOTE_LOGOUT = 0x71; // Logout   (remote)
        /// public const int MINOR_REMOTE_ARM = 0x79; // On guard   (remote)
        /// public const int MINOR_REMOTE_DISARM = 0x7a; // Disarm   (remote)
        /// public const int MINOR_REMOTE_REBOOT = 0x7b; // Reboot   (remote)
        /// public const int MINOR_REMOTE_UPGRADE = 0x7e; // upgrade  (remote)
        /// public const int MINOR_REMOTE_CFGFILE_OUTPUT = 0x86; // Export Configuration   (remote)
        /// public const int MINOR_REMOTE_CFGFILE_INTPUT = 0x87; // Import Configuration  (remote)
        /// public const int MINOR_REMOTE_ALARMOUT_OPEN_MAN = 0xd6; // remote mamual open alarmout
        /// public const int MINOR_REMOTE_ALARMOUT_CLOSE_MAN = 0xd7; // remote mamual close alarmout
        /// </summary>
        public const int MINOR_REMOTE_OPEN_DOOR = 0x400;
        /// <summary>
        /// remote close door (controlled)
        /// </summary>
        public const int MINOR_REMOTE_CLOSE_DOOR = 0x401;
        /// <summary>
        /// remote always open door (free)
        /// </summary>
        public const int MINOR_REMOTE_ALWAYS_OPEN = 0x402;
        /// <summary>
        /// remote always close door (forbiden)
        /// </summary>
        public const int MINOR_REMOTE_ALWAYS_CLOSE = 0x403;
        /// <summary>
        /// remote check time
        /// </summary>
        public const int MINOR_REMOTE_CHECK_TIME = 0x404;
        /// <summary>
        /// ntp check time
        /// </summary>
        public const int MINOR_NTP_CHECK_TIME = 0x405;
        /// <summary>
        /// remote clear card
        /// </summary>
        public const int MINOR_REMOTE_CLEAR_CARD = 0x406;
        /// <summary>
        /// remote restore configure
        /// </summary>
        public const int MINOR_REMOTE_RESTORE_CFG = 0x407;
        /// <summary>
        /// alarm in arm
        /// </summary>
        public const int MINOR_ALARMIN_ARM = 0x408;
        /// <summary>
        /// alarm in disarm
        /// </summary>
        public const int MINOR_ALARMIN_DISARM = 0x409;
        /// <summary>
        /// local configure restore
        /// </summary>
        public const int MINOR_LOCAL_RESTORE_CFG = 0x40a;
        /// <summary>
        /// remote capture picture
        /// </summary>
        public const int MINOR_REMOTE_CAPTURE_PIC = 0x40b;
        /// <summary>
        /// modify net report cfg
        /// </summary>
        public const int MINOR_MOD_NET_REPORT_CFG = 0x40c;
        /// <summary>
        /// modify GPRS report param
        /// </summary>
        public const int MINOR_MOD_GPRS_REPORT_PARAM = 0x40d;
        /// <summary>
        /// modify report group param
        /// </summary>
        public const int MINOR_MOD_REPORT_GROUP_PARAM = 0x40e;
        /// <summary>
        /// unlock password open door
        /// </summary>
        public const int MINOR_UNLOCK_PASSWORD_OPEN_DOOR = 0x40f;
        /// <summary>
        /// auto renumber
        /// </summary>
        public const int MINOR_AUTO_RENUMBER = 0x410;
        /// <summary>
        /// auto complement number
        /// </summary>
        public const int MINOR_AUTO_COMPLEMENT_NUMBER = 0x411;
        /// <summary>
        /// normal cfg file input
        /// </summary>
        public const int MINOR_NORMAL_CFGFILE_INPUT = 0x412;
        /// <summary>
        /// normal cfg file output
        /// </summary>
        public const int MINOR_NORMAL_CFGFILE_OUTTPUT = 0x413;
        /// <summary>
        /// card right input
        /// </summary>
        public const int MINOR_CARD_RIGHT_INPUT = 0x414;
        /// <summary>
        /// card right output
        /// </summary>
        public const int MINOR_CARD_RIGHT_OUTTPUT = 0x415;
        /// <summary>
        /// local USB upgrade
        /// </summary>
        public const int MINOR_LOCAL_USB_UPGRADE = 0x416;
        /// <summary>
        /// visitor call ladder
        /// </summary>
        public const int MINOR_REMOTE_VISITOR_CALL_LADDER = 0x417;
        /// <summary>
        /// household call ladder
        /// </summary>
        public const int MINOR_REMOTE_HOUSEHOLD_CALL_LADDER = 0x418;
        /// <summary>
        /// remote actual guard
        /// </summary>
        public const int MINOR_REMOTE_ACTUAL_GUARD = 0x419;
        /// <summary>
        /// remote actual unguard
        /// </summary>
        public const int MINOR_REMOTE_ACTUAL_UNGUARD = 0x41a;
        /// <summary>
        /// remote control not code operate failed
        /// </summary>
        public const int MINOR_REMOTE_CONTROL_NOT_CODE_OPER_FAILED = 0x41b;
        /// <summary>
        /// remote control close door
        /// </summary>
        public const int MINOR_REMOTE_CONTROL_CLOSE_DOOR = 0x41c;
        /// <summary>
        /// remote control open door
        /// </summary>
        public const int MINOR_REMOTE_CONTROL_OPEN_DOOR = 0x41d;
        /// <summary>
        /// remote control always open door
        /// </summary>
        public const int MINOR_REMOTE_CONTROL_ALWAYS_OPEN_DOOR = 0x41e;
        /// <summary>
        /// Additional Log Info
        /// Main Type
        /// </summary>
        public const int MAJOR_EVENT = 0x5;
        /// <summary>
        /// Hypo- Type
        /// </summary>
        public const int MINOR_LEGAL_CARD_PASS = 0x01;
        /// <summary>
        /// swipe and password pass
        /// </summary>
        public const int MINOR_CARD_AND_PSW_PASS = 0x02;
        /// <summary>
        /// swipe and password fail
        /// </summary>
        public const int MINOR_CARD_AND_PSW_FAIL = 0x03;
        /// <summary>
        /// swipe and password timeout
        /// </summary>
        public const int MINOR_CARD_AND_PSW_TIMEOUT = 0x04;
        /// <summary>
        /// swipe and password over time
        /// </summary>
        public const int MINOR_CARD_AND_PSW_OVER_TIME = 0x05;
        /// <summary>
        /// card no right
        /// </summary>
        public const int MINOR_CARD_NO_RIGHT = 0x06;
        /// <summary>
        /// invalid period
        /// </summary>
        public const int MINOR_CARD_INVALID_PERIOD = 0x07;
        /// <summary>
        /// card out of date
        /// </summary>
        public const int MINOR_CARD_OUT_OF_DATE = 0x08;
        /// <summary>
        /// invalid card
        /// </summary>
        public const int MINOR_INVALID_CARD = 0x09;
        /// <summary>
        /// anti sneak fail
        /// </summary>
        public const int MINOR_ANTI_SNEAK_FAIL = 0x0a;
        /// <summary>
        /// interlock door doesn't close
        /// </summary>
        public const int MINOR_INTERLOCK_DOOR_NOT_CLOSE = 0x0b;
        /// <summary>
        /// card no belong multi group
        /// </summary>
        public const int MINOR_NOT_BELONG_MULTI_GROUP = 0x0c;
        /// <summary>
        /// invalid multi verify period
        /// </summary>
        public const int MINOR_INVALID_MULTI_VERIFY_PERIOD = 0x0d;
        /// <summary>
        /// have no super right in multi verify mode
        /// </summary>
        public const int MINOR_MULTI_VERIFY_SUPER_RIGHT_FAIL = 0x0e;
        /// <summary>
        /// have no remote right in multi verify mode
        /// </summary>
        public const int MINOR_MULTI_VERIFY_REMOTE_RIGHT_FAIL = 0x0f;
        /// <summary>
        /// success in multi verify mode
        /// </summary>
        public const int MINOR_MULTI_VERIFY_SUCCESS = 0x10;
        /// <summary>
        /// leader card begin to open
        /// </summary>
        public const int MINOR_LEADER_CARD_OPEN_BEGIN = 0x11;
        /// <summary>
        /// leader card end to open
        /// </summary>
        public const int MINOR_LEADER_CARD_OPEN_END = 0x12;
        /// <summary>
        /// always open begin
        /// </summary>
        public const int MINOR_ALWAYS_OPEN_BEGIN = 0x13;
        /// <summary>
        /// always open end
        /// </summary>
        public const int MINOR_ALWAYS_OPEN_END = 0x14;
        /// <summary>
        /// lock open
        /// </summary>
        public const int MINOR_LOCK_OPEN = 0x15;
        /// <summary>
        /// lock close
        /// </summary>
        public const int MINOR_LOCK_CLOSE = 0x16;
        /// <summary>
        /// press door open button
        /// </summary>
        public const int MINOR_DOOR_BUTTON_PRESS = 0x17;
        /// <summary>
        /// release door open button
        /// </summary>
        public const int MINOR_DOOR_BUTTON_RELEASE = 0x18;
        /// <summary>
        /// door open normal
        /// </summary>
        public const int MINOR_DOOR_OPEN_NORMAL = 0x19;
        /// <summary>
        /// door close normal
        /// </summary>
        public const int MINOR_DOOR_CLOSE_NORMAL = 0x1a;
        /// <summary>
        /// open door abnormal
        /// </summary>
        public const int MINOR_DOOR_OPEN_ABNORMAL = 0x1b;
        /// <summary>
        /// open door timeout
        /// </summary>
        public const int MINOR_DOOR_OPEN_TIMEOUT = 0x1c;
        /// <summary>
        /// alarm out turn on
        /// </summary>
        public const int MINOR_ALARMOUT_ON = 0x1d;
        /// <summary>
        /// alarm out turn off
        /// </summary>
        public const int MINOR_ALARMOUT_OFF = 0x1e;
        /// <summary>
        /// always close begin
        /// </summary>
        public const int MINOR_ALWAYS_CLOSE_BEGIN = 0x1f;
        /// <summary>
        /// always close end
        /// </summary>
        public const int MINOR_ALWAYS_CLOSE_END = 0x20;
        /// <summary>
        /// need remote open in multi verify mode
        /// </summary>
        public const int MINOR_MULTI_VERIFY_NEED_REMOTE_OPEN = 0x21;
        /// <summary>
        /// superpasswd verify success in multi verify mode
        /// </summary>
        public const int MINOR_MULTI_VERIFY_SUPERPASSWD_VERIFY_SUCCESS = 0x22;
        /// <summary>
        /// repeat verify in multi verify mode
        /// </summary>
        public const int MINOR_MULTI_VERIFY_REPEAT_VERIFY = 0x23;
        /// <summary>
        /// timeout in multi verify mode
        /// </summary>
        public const int MINOR_MULTI_VERIFY_TIMEOUT = 0x24;
        /// <summary>
        /// doorbell ringing
        /// </summary>
        public const int MINOR_DOORBELL_RINGING = 0x25;
        /// <summary>
        /// fingerprint compare pass
        /// </summary>
        public const int MINOR_FINGERPRINT_COMPARE_PASS = 0x26;
        /// <summary>
        /// fingerprint compare fail
        /// </summary>
        public const int MINOR_FINGERPRINT_COMPARE_FAIL = 0x27;
        /// <summary>
        /// card and fingerprint verify pass
        /// </summary>
        public const int MINOR_CARD_FINGERPRINT_VERIFY_PASS = 0x28;
        /// <summary>
        /// card and fingerprint verify fail
        /// </summary>
        public const int MINOR_CARD_FINGERPRINT_VERIFY_FAIL = 0x29;
        /// <summary>
        /// card and fingerprint verify timeout
        /// </summary>
        public const int MINOR_CARD_FINGERPRINT_VERIFY_TIMEOUT = 0x2a;
        /// <summary>
        /// card and fingerprint and passwd verify pass
        /// </summary>
        public const int MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_PASS = 0x2b;
        /// <summary>
        /// card and fingerprint and passwd verify fail
        /// </summary>
        public const int MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_FAIL = 0x2c;
        /// <summary>
        /// card and fingerprint and passwd verify timeout
        /// </summary>
        public const int MINOR_CARD_FINGERPRINT_PASSWD_VERIFY_TIMEOUT = 0x2d;
        /// <summary>
        /// fingerprint and passwd verify pass
        /// </summary>
        public const int MINOR_FINGERPRINT_PASSWD_VERIFY_PASS = 0x2e;
        /// <summary>
        /// fingerprint and passwd verify fail
        /// </summary>
        public const int MINOR_FINGERPRINT_PASSWD_VERIFY_FAIL = 0x2f;
        /// <summary>
        /// fingerprint and passwd verify timeout
        /// </summary>
        public const int MINOR_FINGERPRINT_PASSWD_VERIFY_TIMEOUT = 0x30;
        /// <summary>
        /// fingerprint inexistence
        /// </summary>
        public const int MINOR_FINGERPRINT_INEXISTENCE = 0x31;
        /// <summary>
        /// card platform verify
        /// </summary>
        public const int MINOR_CARD_PLATFORM_VERIFY = 0x32;
        /// <summary>
        /// call center
        /// </summary>
        public const int MINOR_CALL_CENTER = 0x33;
        /// <summary>
        /// fire relay turn on door always open
        /// </summary>
        public const int MINOR_FIRE_RELAY_TURN_ON_DOOR_ALWAYS_OPEN = 0x34;
        /// <summary>
        /// fire relay recover door recover normal
        /// </summary>
        public const int MINOR_FIRE_RELAY_RECOVER_DOOR_RECOVER_NORMAL = 0x35;
        /// <summary>
        /// face and finger print verify pass
        /// </summary>
        public const int MINOR_FACE_AND_FP_VERIFY_PASS = 0x36;
        /// <summary>
        /// face and finger print verify fail
        /// </summary>
        public const int MINOR_FACE_AND_FP_VERIFY_FAIL = 0x37;
        /// <summary>
        /// face and finger print verify timeout
        /// </summary>
        public const int MINOR_FACE_AND_FP_VERIFY_TIMEOUT = 0x38;
        /// <summary>
        /// face and password verify pass
        /// </summary>
        public const int MINOR_FACE_AND_PW_VERIFY_PASS = 0x39;
        /// <summary>
        /// face and password verify fail
        /// </summary>
        public const int MINOR_FACE_AND_PW_VERIFY_FAIL = 0x3a;
        /// <summary>
        /// face and password verify timeout
        /// </summary>
        public const int MINOR_FACE_AND_PW_VERIFY_TIMEOUT = 0x3b;
        /// <summary>
        /// face and card verify pass
        /// </summary>
        public const int MINOR_FACE_AND_CARD_VERIFY_PASS = 0x3c;
        /// <summary>
        /// face and card verify fail
        /// </summary>
        public const int MINOR_FACE_AND_CARD_VERIFY_FAIL = 0x3d;
        /// <summary>
        /// face and card verify timeout
        /// </summary>
        public const int MINOR_FACE_AND_CARD_VERIFY_TIMEOUT = 0x3e;
        /// <summary>
        /// face and password and finger print verify pass
        /// </summary>
        public const int MINOR_FACE_AND_PW_AND_FP_VERIFY_PASS = 0x3f;
        /// <summary>
        /// face and password and finger print verify fail
        /// </summary>
        public const int MINOR_FACE_AND_PW_AND_FP_VERIFY_FAIL = 0x40;
        /// <summary>
        /// face and password and finger print verify timeout
        /// </summary>
        public const int MINOR_FACE_AND_PW_AND_FP_VERIFY_TIMEOUT = 0x41;
        /// <summary>
        /// face and card and finger print verify pass
        /// </summary>
        public const int MINOR_FACE_CARD_AND_FP_VERIFY_PASS = 0x42;
        /// <summary>
        /// face and card and finger print verify fail
        /// </summary>
        public const int MINOR_FACE_CARD_AND_FP_VERIFY_FAIL = 0x43;
        /// <summary>
        /// face and card and finger print verify timeout
        /// </summary>
        public const int MINOR_FACE_CARD_AND_FP_VERIFY_TIMEOUT = 0x44;
        /// <summary>
        /// employee and finger print verify pass
        /// </summary>
        public const int MINOR_EMPLOYEENO_AND_FP_VERIFY_PASS = 0x45;
        /// <summary>
        /// employee and finger print verify fail
        /// </summary>
        public const int MINOR_EMPLOYEENO_AND_FP_VERIFY_FAIL = 0x46;
        /// <summary>
        /// employee and finger print verify timeout
        /// </summary>
        public const int MINOR_EMPLOYEENO_AND_FP_VERIFY_TIMEOUT = 0x47;
        /// <summary>
        /// employee and finger print and password verify pass
        /// </summary>
        public const int MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_PASS = 0x48;
        /// <summary>
        /// employee and finger print and password verify fail
        /// </summary>
        public const int MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_FAIL = 0x49;
        /// <summary>
        /// employee and finger print and password verify timeout
        /// </summary>
        public const int MINOR_EMPLOYEENO_AND_FP_AND_PW_VERIFY_TIMEOUT = 0x4a;
        /// <summary>
        /// face verify pass
        /// </summary>
        public const int MINOR_FACE_VERIFY_PASS = 0x4b;
        /// <summary>
        /// face verify fail
        /// </summary>
        public const int MINOR_FACE_VERIFY_FAIL = 0x4c;
        /// <summary>
        /// employee no and face verify pass
        /// </summary>
        public const int MINOR_EMPLOYEENO_AND_FACE_VERIFY_PASS = 0x4d;
        /// <summary>
        /// employee no and face verify fail
        /// </summary>
        public const int MINOR_EMPLOYEENO_AND_FACE_VERIFY_FAIL = 0x4e;
        /// <summary>
        /// employee no and face verify time out
        /// </summary>
        public const int MINOR_EMPLOYEENO_AND_FACE_VERIFY_TIMEOUT = 0x4f;
        /// <summary>
        /// face recognize fail
        /// </summary>
        public const int MINOR_FACE_RECOGNIZE_FAIL = 0x50;
        /// <summary>
        /// first card authorize begin
        /// </summary>
        public const int MINOR_FIRSTCARD_AUTHORIZE_BEGIN = 0x51;
        /// <summary>
        /// first card authorize end
        /// </summary>
        public const int MINOR_FIRSTCARD_AUTHORIZE_END = 0x52;
        /// <summary>
        /// door lock input short circuit
        /// </summary>
        public const int MINOR_DOORLOCK_INPUT_SHORT_CIRCUIT = 0x53;
        /// <summary>
        /// door lock input broken circuit
        /// </summary>
        public const int MINOR_DOORLOCK_INPUT_BROKEN_CIRCUIT = 0x54;
        /// <summary>
        /// door lock input exception
        /// </summary>
        public const int MINOR_DOORLOCK_INPUT_EXCEPTION = 0x55;
        /// <summary>
        /// door contact input short circuit
        /// </summary>
        public const int MINOR_DOORCONTACT_INPUT_SHORT_CIRCUIT = 0x56;
        /// <summary>
        /// door contact input broken circuit
        /// </summary>
        public const int MINOR_DOORCONTACT_INPUT_BROKEN_CIRCUIT = 0x57;
        /// <summary>
        /// door contact input exception
        /// </summary>
        public const int MINOR_DOORCONTACT_INPUT_EXCEPTION = 0x58;
        /// <summary>
        /// open button input short circuit
        /// </summary>
        public const int MINOR_OPENBUTTON_INPUT_SHORT_CIRCUIT = 0x59;
        /// <summary>
        /// open button input broken circuit
        /// </summary>
        public const int MINOR_OPENBUTTON_INPUT_BROKEN_CIRCUIT = 0x5a;
        /// <summary>
        /// open button input exception
        /// </summary>
        public const int MINOR_OPENBUTTON_INPUT_EXCEPTION = 0x5b;
        /// <summary>
        /// door lock open exception
        /// </summary>
        public const int MINOR_DOORLOCK_OPEN_EXCEPTION = 0x5c;
        /// <summary>
        /// door lock open timeout
        /// </summary>
        public const int MINOR_DOORLOCK_OPEN_TIMEOUT = 0x5d;
        /// <summary>
        /// first card open without authorize
        /// </summary>
        public const int MINOR_FIRSTCARD_OPEN_WITHOUT_AUTHORIZE = 0x5e;
        /// <summary>
        /// call ladder relay break
        /// </summary>
        public const int MINOR_CALL_LADDER_RELAY_BREAK = 0x5f;
        /// <summary>
        /// call ladder relay close
        /// </summary>
        public const int MINOR_CALL_LADDER_RELAY_CLOSE = 0x60;
        /// <summary>
        /// auto key relay break
        /// </summary>
        public const int MINOR_AUTO_KEY_RELAY_BREAK = 0x61;
        /// <summary>
        /// auto key relay close
        /// </summary>
        public const int MINOR_AUTO_KEY_RELAY_CLOSE = 0x62;
        /// <summary>
        /// key control relay break
        /// </summary>
        public const int MINOR_KEY_CONTROL_RELAY_BREAK = 0x63;
        /// <summary>
        /// key control relay close
        /// </summary>
        public const int MINOR_KEY_CONTROL_RELAY_CLOSE = 0x64;
        /// <summary>
        /// minor employee no and password pass
        /// </summary>
        public const int MINOR_EMPLOYEENO_AND_PW_PASS = 0x65;
        /// <summary>
        /// minor employee no and password fail
        /// </summary>
        public const int MINOR_EMPLOYEENO_AND_PW_FAIL = 0x66;
        /// <summary>
        /// minor employee no and password timeout
        /// </summary>
        public const int MINOR_EMPLOYEENO_AND_PW_TIMEOUT = 0x67;
        /// <summary>
        /// human detect fail
        /// </summary>
        public const int MINOR_HUMAN_DETECT_FAIL = 0x68;
        /// <summary>
        /// the comparison with people and id card success
        /// </summary>
        public const int MINOR_PEOPLE_AND_ID_CARD_COMPARE_PASS = 0x69;
        /// <summary>
        /// the comparison with people and id card failed
        /// </summary>
        public const int MINOR_PEOPLE_AND_ID_CARD_COMPARE_FAIL = 0x70;
        /// <summary>
        /// block list
        /// </summary>
        public const int MINOR_CERTIFICATE_BLOCKLIST = 0x71;
        /// <summary>
        /// legal message
        /// </summary>
        public const int MINOR_LEGAL_MESSAGE = 0x72;
        /// <summary>
        /// illegal messag
        /// </summary>
        public const int MINOR_ILLEGAL_MESSAGE = 0x73;
        /// <summary>
        /// mac detect
        /// </summary>
        public const int MINOR_MAC_DETECT = 0x74;
        /// <summary>
        /// door open or dormant fail
        /// </summary>
        public const int MINOR_DOOR_OPEN_OR_DORMANT_FAIL = 0x75;
        /// <summary>
        /// auth plan dormant fail
        /// </summary>
        public const int MINOR_AUTH_PLAN_DORMANT_FAIL = 0x76;
        /// <summary>
        /// card encrypt verify fail
        /// </summary>
        public const int MINOR_CARD_ENCRYPT_VERIFY_FAIL = 0x77;
        /// <summary>
        /// submarineback reply fail
        /// </summary>
        public const int MINOR_SUBMARINEBACK_REPLY_FAIL = 0x78;
        /// <summary>
        /// door open or dormant open fail
        /// </summary>
        public const int MINOR_DOOR_OPEN_OR_DORMANT_OPEN_FAIL = 0x82;
        /// <summary>
        /// door open or dormant linkage open fail
        /// </summary>
        public const int MINOR_DOOR_OPEN_OR_DORMANT_LINKAGE_OPEN_FAIL = 0x84;
        /// <summary>
        /// trailing
        /// </summary>
        public const int MINOR_TRAILING = 0x85;
        /// <summary>
        /// heart beat event
        /// </summary>
        public const int MINOR_HEART_BEAT = 0x83;
        /// <summary>
        /// reverse access
        /// </summary>
        public const int MINOR_REVERSE_ACCESS = 0x86;
        /// <summary>
        /// force access
        /// </summary>
        public const int MINOR_FORCE_ACCESS = 0x87;
        /// <summary>
        /// climbing over gate
        /// </summary>
        public const int MINOR_CLIMBING_OVER_GATE = 0x88;
        /// <summary>
        /// passing timeout
        /// </summary>
        public const int MINOR_PASSING_TIMEOUT = 0x89;
        /// <summary>
        /// intrusion alarm
        /// </summary>
        public const int MINOR_INTRUSION_ALARM = 0x8a;
        /// <summary>
        /// free gate pass not auth
        /// </summary>
        public const int MINOR_FREE_GATE_PASS_NOT_AUTH = 0x8b;
        /// <summary>
        /// drop arm block
        /// </summary>
        public const int MINOR_DROP_ARM_BLOCK = 0x8c;
        /// <summary>
        /// drop arm block resume
        /// </summary>
        public const int MINOR_DROP_ARM_BLOCK_RESUME = 0x8d;
        /// <summary>
        /// device upgrade with module failed
        /// </summary>
        public const int MINOR_LOCAL_FACE_MODELING_FAIL = 0x8e;
        /// <summary>
        /// stay event
        /// </summary>
        public const int MINOR_STAY_EVENT = 0x8f;
        /// <summary>
        /// password mismatch
        /// </summary>
        public const int MINOR_PASSWORD_MISMATCH = 0x97;
        /// <summary>
        /// employee no not exist
        /// </summary>
        public const int MINOR_EMPLOYEE_NO_NOT_EXIST = 0x98;
        /// <summary>
        /// combined verify pass
        /// </summary>
        public const int MINOR_COMBINED_VERIFY_PASS = 0x99;
        /// <summary>
        /// combined verify timeout
        /// </summary>
        public const int MINOR_COMBINED_VERIFY_TIMEOUT = 0x9a;
        /// <summary>
        /// verify mode mismatch
        /// </summary>
        public const int MINOR_VERIFY_MODE_MISMATCH = 0x9b;

        /// <summary>
        /// ***********************************************
        /// 参数配置结构、参数(其中_V30为9000新增)
        /// ************************************************
        /// 校时结构参数
        /// </summary>
        

        /*************************************************
        参数配置结构、参数(其中_V30为9000新增)
        **************************************************/
        //校时结构参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TIME
        {
            public int dwYear;
            public int dwMonth;
            public int dwDay;
            public int dwHour;
            public int dwMinute;
            public int dwSecond;
        }

        /// <summary>
        /// 时间参数
        /// </summary>
        //时间参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TIME_V30
        {
            public ushort wYear;
            public byte byMonth;
            public byte byDay;
            public byte byHour;
            public byte byMinute;
            public byte bySecond;
            public byte byRes;
            public ushort wMilliSec;
            public byte cTimeDifferenceH;
            public byte cTimeDifferenceM;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TIME_EX
        {
            public ushort wYear;
            public byte byMonth;
            public byte byDay;
            public byte byHour;
            public byte byMinute;
            public byte bySecond;
            public byte byRes;
        }

        /// <summary>
        /// 时间段(子结构)
        /// </summary>
        //时间段(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCHEDTIME
        {
            /// <summary>
            /// 开始时间
            /// </summary>
            public byte byStartHour;
            /// <summary>
            /// 开始时间
            /// </summary>
            public byte byStartMin;
            /// <summary>
            /// 结束时间
            /// </summary>
            public byte byStopHour;
            /// <summary>
            /// 结束时间
            /// </summary>
            public byte byStopMin;
        }
        /// <summary>
        /// 设备报警和异常处理方式
        /// </summary>
        public const int NOACTION = 0x0;
        /// <summary>
        /// 显示器上警告
        /// </summary>
        public const int WARNONMONITOR = 0x1;
        /// <summary>
        /// 声音警告
        /// </summary>
        public const int WARNONAUDIOOUT = 0x2;
        /// <summary>
        /// 上传中心
        /// </summary>
        public const int UPTOCENTER = 0x4;
        /// <summary>
        /// 触发报警输出
        /// </summary>
        public const int TRIGGERALARMOUT = 0x8;
        /// <summary>
        /// 触发抓图并上传E-mail
        /// </summary>
        public const int TRIGGERCATPIC = 0x10;
        /// <summary>
        /// 抓图并上传ftp
        /// </summary>
        public const int SEND_PIC_FTP = 0x200;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_STRUCTHEAD
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public ushort wLength;
            /// <summary>
            /// 高低4位分别代表高低版本，后续根据版本和长度进行扩展，不同的版本的长度进行限制
            /// </summary>
            public byte byVersion;
            public byte byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HANDLEEXCEPTION_V41
        {
            /// <summary>
            /// 处理方式,处理方式的"或"结果
            /// </summary>
            public uint dwHandleType;
            /// <summary>
            /// 0x00: 无响应
            /// 0x01: 显示器上警告
            /// 0x02: 声音警告
            /// 0x04: 上传中心
            /// 0x08: 触发报警输出
            /// 0x10: 触发JPRG抓图并上传Email
            /// 0x20: 无线声光报警器联动
            /// 0x40: 联动电子地图(目前只有PCNVR支持)
            /// 0x200: 抓图并上传FTP
            /// </summary>
            public uint dwMaxRelAlarmOutChanNum;
            /// <summary>
            /// 触发报警通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMOUT_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRelAlarmOut;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HANDLEEXCEPTION_V40
        {
            /// <summary>
            /// 处理方式,处理方式的"或"结果
            /// </summary>
            public uint dwHandleType;
            /// <summary>
            /// 0x00: 无响应
            /// 0x01: 显示器上警告
            /// 0x02: 声音警告
            /// 0x04: 上传中心
            /// 0x08: 触发报警输出
            /// 0x10: 触发JPRG抓图并上传Email
            /// 0x20: 无线声光报警器联动
            /// 0x40: 联动电子地图(目前只有PCNVR支持)
            /// 0x200: 抓图并上传FTP
            /// </summary>
            public uint dwMaxRelAlarmOutChanNum;
            /// <summary>
            /// 触发的报警输出通道数 实际支持数
            /// </summary>
            public uint dwRelAlarmOutChanNum;
            /// <summary>
            /// 触发报警通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRelAlarmOut;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 报警和异常处理结构(子结构)(多处使用)(9000扩展)
        /// </summary>
        //报警和异常处理结构(子结构)(多处使用)(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HANDLEEXCEPTION_V30
        {
            /// <summary>
            /// 处理方式,处理方式的"或"结果
            /// </summary>
            public uint dwHandleType;
            /// <summary>
            /// 0x00: 无响应
            /// 0x01: 显示器上警告
            /// 0x02: 声音警告
            /// 0x04: 上传中心
            /// 0x08: 触发报警输出
            /// 0x10: 触发JPRG抓图并上传Email
            /// 0x20: 无线声光报警器联动
            /// 0x40: 联动电子地图(目前只有PCNVR支持)
            /// 0x200: 抓图并上传FTP
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMOUT_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelAlarmOut;
        }

        /// <summary>
        /// 报警和异常处理结构(子结构)(多处使用)
        /// </summary>
        //报警和异常处理结构(子结构)(多处使用)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HANDLEEXCEPTION
        {
            /// <summary>
            /// 处理方式,处理方式的"或"结果
            /// </summary>
            public uint dwHandleType;
            /// <summary>
            /// 0x00: 无响应
            /// 0x01: 显示器上警告
            /// 0x02: 声音警告
            /// 0x04: 上传中心
            /// 0x08: 触发报警输出
            /// 0x10: Jpeg抓图并上传EMail
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMOUT, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelAlarmOut;
        }

        /// <summary>
        /// DVR设备参数
        /// </summary>
        //DVR设备参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEVICECFG
        {
            public uint dwSize;
            /// <summary>
            /// DVR名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sDVRName;
            /// <summary>
            /// DVR ID,用于遥控器 //V1.4(0-99), V1.5(0-255)
            /// </summary>
            public uint dwDVRID;
            /// <summary>
            /// 是否循环录像,0:不是; 1:是
            /// </summary>
            public uint dwRecycleRecord;
            /// <summary>
            /// 以下不可更改
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SERIALNO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sSerialNumber;
            /// <summary>
            /// 软件版本号,高16位是主版本,低16位是次版本
            /// </summary>
            public uint dwSoftwareVersion;
            /// <summary>
            /// 软件生成日期,0xYYYYMMDD
            /// </summary>
            public uint dwSoftwareBuildDate;
            /// <summary>
            /// DSP软件版本,高16位是主版本,低16位是次版本
            /// </summary>
            public uint dwDSPSoftwareVersion;
            /// <summary>
            /// DSP软件生成日期,0xYYYYMMDD
            /// </summary>
            public uint dwDSPSoftwareBuildDate;
            /// <summary>
            /// 前面板版本,高16位是主版本,低16位是次版本
            /// </summary>
            public uint dwPanelVersion;
            /// <summary>
            /// 硬件版本,高16位是主版本,低16位是次版本
            /// </summary>
            public uint dwHardwareVersion;
            /// <summary>
            /// DVR报警输入个数
            /// </summary>
            public byte byAlarmInPortNum;
            /// <summary>
            /// DVR报警输出个数
            /// </summary>
            public byte byAlarmOutPortNum;
            /// <summary>
            /// DVR 232串口个数
            /// </summary>
            public byte byRS232Num;
            /// <summary>
            /// DVR 485串口个数
            /// </summary>
            public byte byRS485Num;
            /// <summary>
            /// 网络口个数
            /// </summary>
            public byte byNetworkPortNum;
            /// <summary>
            /// DVR 硬盘控制器个数
            /// </summary>
            public byte byDiskCtrlNum;
            /// <summary>
            /// DVR 硬盘个数
            /// </summary>
            public byte byDiskNum;
            /// <summary>
            /// DVR类型, 1:DVR 2:ATM DVR 3:DVS ......
            /// </summary>
            public byte byDVRType;
            /// <summary>
            /// DVR 通道个数
            /// </summary>
            public byte byChanNum;
            /// <summary>
            /// 起始通道号,例如DVS-1,DVR - 1
            /// </summary>
            public byte byStartChan;
            /// <summary>
            /// DVR 解码路数
            /// </summary>
            public byte byDecordChans;
            /// <summary>
            /// VGA口的个数
            /// </summary>
            public byte byVGANum;
            /// <summary>
            /// USB口的个数
            /// </summary>
            public byte byUSBNum;
            /// <summary>
            /// 辅口的个数
            /// </summary>
            public byte byAuxoutNum;
            /// <summary>
            /// 语音口的个数
            /// </summary>
            public byte byAudioNum;
            /// <summary>
            /// 最大数字通道数
            /// </summary>
            public byte byIPChanNum;
        }

        /// <summary>
        /// IP地址
        /// </summary>
        /*IP地址*/
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_IPADDR
        {
            /// <summary>
            /// char[16]
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] sIpV4;
            /// <summary>
            /// BYTE[128]
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byIPv6;
        }

        /// <summary>
        /// 网络数据结构(子结构)(9000扩展)
        /// </summary>
        /*网络数据结构(子结构)(9000扩展)*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ETHERNET_V30
        {
            /// <summary>
            /// DVR IP地址
            /// </summary>
            public NET_DVR_IPADDR struDVRIP;
            /// <summary>
            /// DVR IP地址掩码
            /// </summary>
            public NET_DVR_IPADDR struDVRIPMask;
            /// <summary>
            /// 网络接口：1-10MBase-T；2-10MBase-T全双工；3-100MBase-TX；4-100M全双工；5-10M/100M/1000M自适应；6-1000M全双工
            /// </summary>
            public uint dwNetInterface;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDVRPort;
            /// <summary>
            /// 增加MTU设置，默认1500。
            /// </summary>
            public ushort wMTU;
            /// <summary>
            /// 物理地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMACAddr;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMHOST_NETPARAM
        {
            public uint dwSize;
            public NET_DVR_IPADDR struIP;
            public ushort wPort;
            /// <summary>
            /// 0 - 无意义, 1 - ipv4/ipv6地址，2 - 域名
            /// </summary>
            public byte byAddressType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 1, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byDomainName;
            /// <summary>
            /// 1-private 2-NAL2300, 3-Ehome
            /// </summary>
            public byte byReportProtocol;
            /// <summary>
            /// 协议为NAL2300时有效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACCOUNTNUM_LEN_32, ArraySubType = UnmanagedType.I1)]
            public byte[] byDevID;
            /// <summary>
            /// GPRS的域名解析是在固定的服务器上进行的，所以不需要给解析服务器的信息预留一些字段
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 网络数据结构(子结构)
        /// </summary>
        /*网络数据结构(子结构)*/
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_ETHERNET
        {
            /// <summary>
            /// DVR IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sDVRIP;
            /// <summary>
            /// DVR IP地址掩码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sDVRIPMask;
            /// <summary>
            /// 网络接口 1-10MBase-T 2-10MBase-T全双工 3-100MBase-TX 4-100M全双工 5-10M/100M自适应
            /// </summary>
            public uint dwNetInterface;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDVRPort;
            /// <summary>
            /// 服务器的物理地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMACAddr;
        }

        /// <summary>
        /// pppoe结构
        /// </summary>
        //pppoe结构
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_PPPOECFG
        {
            /// <summary>
            /// 0-不启用,1-启用
            /// </summary>
            public uint dwPPPOE;
            /// <summary>
            /// PPPoE用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPPPoEUser;
            /// <summary>
            /// PPPoE密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = PASSWD_LEN)]
            public string sPPPoEPassword;
            /// <summary>
            /// PPPoE IP地址
            /// </summary>
            public NET_DVR_IPADDR struPPPoEIP;
        }

        /// <summary>
        /// 网络配置结构(9000扩展)
        /// </summary>
        //网络配置结构(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_NETCFG_V30
        {
            public uint dwSize;
            /// <summary>
            /// 以太网口
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ETHERNET, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ETHERNET_V30[] struEtherNet;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPADDR[] struRes1;
            /// <summary>
            /// 报警主机IP地址
            /// </summary>
            public NET_DVR_IPADDR struAlarmHostIpAddr;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            public ushort wAlarmHostIpPort;
            public byte byUseDhcp;
            public byte byRes3;
            /// <summary>
            /// 域名服务器1的IP地址
            /// </summary>
            public NET_DVR_IPADDR struDnsServer1IpAddr;
            /// <summary>
            /// 域名服务器2的IP地址
            /// </summary>
            public NET_DVR_IPADDR struDnsServer2IpAddr;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byIpResolver;
            public ushort wIpResolverPort;
            public ushort wHttpPortNo;
            /// <summary>
            /// 多播组地址
            /// </summary>
            public NET_DVR_IPADDR struMulticastIpAddr;
            /// <summary>
            /// 网关地址
            /// </summary>
            public NET_DVR_IPADDR struGatewayIpAddr;
            public NET_DVR_PPPOECFG struPPPoE;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 单个网卡配置信息结构体
        /// </summary>
        //单个网卡配置信息结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ETHERNET_MULTI
        {
            public NET_DVR_IPADDR struDVRIP;
            public NET_DVR_IPADDR struDVRIPMask;
            public uint dwNetInterface;
            /// <summary>
            /// 网卡类型，0-普通网卡，1-内网网卡，2-外网网卡
            /// </summary>
            public byte byCardType;
            public byte byRes1;
            public ushort wMTU;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMACAddr;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            public byte byUseDhcp;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
            public NET_DVR_IPADDR struGatewayIpAddr;
            public NET_DVR_IPADDR struDnsServer1IpAddr;
            public NET_DVR_IPADDR struDnsServer2IpAddr;
        }
        /// <summary>
        /// 获取设备工作状态
        /// </summary>
        public const int NET_DVR_GET_WORK_STATUS_V50 = 6200;

        /// <summary>
        /// 多网卡网络配置结构
        /// </summary>
        //多网卡网络配置结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_NETCFG_MULTI
        {
            public uint dwSize;
            public byte byDefaultRoute;
            public byte byNetworkCardNum;
            /// <summary>
            /// 0-普通多网卡模式，1-内外网隔离模式
            /// </summary>
            public byte byWorkMode;
            public byte byRes;
            /// <summary>
            /// 以太网口
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NETWORK_CARD, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ETHERNET_MULTI[] struEtherNet;
            public NET_DVR_IPADDR struManageHost1IpAddr;
            public NET_DVR_IPADDR struManageHost2IpAddr;
            public NET_DVR_IPADDR struAlarmHostIpAddr;
            public ushort wManageHost1Port;
            public ushort wManageHost2Port;
            public ushort wAlarmHostIpPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byIpResolver;
            public ushort wIpResolverPort;
            public ushort wDvrPort;
            public ushort wHttpPortNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 多播组地址
            /// </summary>
            public NET_DVR_IPADDR struMulticastIpAddr;
            public NET_DVR_PPPOECFG struPPPoE;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }

        /// <summary>
        /// 网络配置结构
        /// </summary>
        //网络配置结构
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_NETCFG
        {
            public uint dwSize;
            /// <summary>
            /// 以太网口
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ETHERNET, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ETHERNET[] struEtherNet;
            /// <summary>
            /// 远程管理主机地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sManageHostIP;
            /// <summary>
            /// 远程管理主机端口号
            /// </summary>
            public ushort wManageHostPort;
            /// <summary>
            /// IPServer服务器地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sIPServerIP;
            /// <summary>
            /// 多播组地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sMultiCastIP;
            /// <summary>
            /// 网关地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sGatewayIP;
            /// <summary>
            /// NFS主机IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sNFSIP;
            /// <summary>
            /// NFS目录
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PATHNAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sNFSDirectory;
            /// <summary>
            /// 0-不启用,1-启用
            /// </summary>
            public uint dwPPPOE;
            /// <summary>
            /// PPPoE用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPPPoEUser;
            /// <summary>
            /// PPPoE密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = PASSWD_LEN)]
            public string sPPPoEPassword;
            /// <summary>
            /// PPPoE IP地址(只读)
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sPPPoEIP;
            /// <summary>
            /// HTTP端口号
            /// </summary>
            public ushort wHttpPort;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_SIP_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 使能自动注册，0-不使能，1-使能
            /// </summary>
            public byte byEnableAutoLogin;
            /// <summary>
            /// 注册状态，0-未注册，1-已注册，此参数只能获取
            /// </summary>
            public byte byLoginStatus;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// SIP服务器IP
            /// </summary>
            public NET_DVR_IPADDR stuServerIP;
            /// <summary>
            /// SIP服务器端口
            /// </summary>
            public ushort wServerPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 注册用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byUserName;
            /// <summary>
            /// 注册密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPassWord;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NUMBER_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byLocalNo;
            /// <summary>
            /// 设备显示名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDispalyName;
            /// <summary>
            /// 本地端口
            /// </summary>
            public ushort wLocalPort;
            /// <summary>
            /// 注册周期，1-99分钟
            /// </summary>
            public byte byLoginCycle;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 129, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// IP可视对讲分机配置
        /// </summary>
        //IP可视对讲分机配置
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_IP_VIEW_DEVCFG
        {
            public uint dwSize;
            /// <summary>
            /// 默认铃音，范围1-6
            /// </summary>
            public byte byDefaultRing;
            /// <summary>
            /// 铃音音量，范围0-9
            /// </summary>
            public byte byRingVolume;
            /// <summary>
            /// 输入音量值，范围0-6
            /// </summary>
            public byte byInputVolume;
            /// <summary>
            /// 输出音量值，范围0-9
            /// </summary>
            public byte byOutputVolume;
            /// <summary>
            /// Rtp端口
            /// </summary>
            public ushort wRtpPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 预览延时配置，0-30秒
            /// </summary>
            public uint dwPreviewDelayTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// Ip可视对讲音频相关参数配置
        /// </summary>
        //Ip可视对讲音频相关参数配置
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_IP_VIEW_AUDIO_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 音频编码优先级1，0-OggVorbis，1-G711_U，2-G711_A， 5-MPEG2,6-G726，7-AAC
            /// </summary>
            public byte byAudioEncPri1;
            /// <summary>
            /// 音频编码优先级2，当sip服务器不支持音频编码1时会使用音频编码2，0-OggVorbis，1-G711_U，2-G711_A， 5-MPEG2,6-G726，7-AAC
            /// </summary>
            public byte byAudioEncPri2;
            /// <summary>
            /// 音频编码1数据包长度
            /// </summary>
            public ushort wAudioPacketLen1;
            /// <summary>
            /// 音频编码2数据包长度
            /// </summary>
            public ushort wAudioPacketLen2;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// IP分机呼叫对讲参数配置结构体
        /// </summary>
        //IP分机呼叫对讲参数配置结构体
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_IP_VIEW_CALL_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 使能自动应答,0-不使能，1-使能
            /// </summary>
            public byte byEnableAutoResponse;
            /// <summary>
            /// 自动应答时间，0-30秒
            /// </summary>
            public byte byAudoResponseTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 启动报警号码1，0-不启动，1-启动
            /// </summary>
            public byte byEnableAlarmNumber1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 呼叫号码1
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NUMBER_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmNumber1;
            /// <summary>
            /// 启动报警号码2，0-不启动，1-启动
            /// </summary>
            public byte byEnableAlarmNumber2;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
            /// <summary>
            /// 呼叫号码2，呼叫号码1失败会尝试呼叫号码2
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NUMBER_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmNumber2;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 72, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes4;
        }

        /// <summary>
        /// 通道图象结构
        /// 移动侦测(子结构)(按组方式扩展)
        /// </summary>
        //通道图象结构
        //移动侦测(子结构)(按组方式扩展)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_RECORDCHAN
        {
            /// <summary>
            /// 设备支持的最大关联录像通道数-只读
            /// </summary>
            public uint dwMaxRecordChanNum;
            /// <summary>
            /// 当前实际已配置的关联录像通道数
            /// </summary>
            public uint dwCurRecordChanNum;
            /// <summary>
            /// 实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - MAX_CHANNUM_V30-1有效，如果中间遇到0xffffffff,则后续无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.U4)]
            public uint dwRelRecordChan;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 通道图象结构
        /// 移动侦测(子结构)(9000扩展)
        /// </summary>
        //通道图象结构
        //移动侦测(子结构)(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MOTION_V30
        {
            /// <summary>
            /// 侦测区域,0-96位,表示64行,共有96*64个小宏块,为1表示是移动侦测区域,0-表示不是
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 96 * 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byMotionScope;
            /// <summary>
            /// 移动侦测灵敏度, 0 - 5,越高越灵敏,oxff关闭
            /// </summary>
            public byte byMotionSensitive;
            /// <summary>
            /// 是否处理移动侦测 0－否 1－是
            /// </summary>
            public byte byEnableHandleMotion;
            /// <summary>
            /// 启用移动侦测高亮显示：0- 否，1- 是
            /// </summary>
            public byte byEnableDisplay;
            public byte reservedData;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 struMotionHandleType;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 报警触发的录象通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
        }

        /// <summary>
        /// 移动侦测(子结构)
        /// </summary>
        //移动侦测(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MOTION
        {
            /// <summary>
            /// 侦测区域,共有22*18个小宏块,为1表示改宏块是移动侦测区域,0-表示不是
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 396, ArraySubType = UnmanagedType.I1)]
            public byte[] byMotionScope;
            /// <summary>
            /// 移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭
            /// </summary>
            public byte byMotionSensitive;
            /// <summary>
            /// 是否处理移动侦测
            /// </summary>
            public byte byEnableHandleMotion;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 2)]
            public string reservedData;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION strMotionHandleType;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 报警触发的录象通道,为1表示触发该通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
        }

        /// <summary>
        /// 遮挡报警(子结构)(9000扩展)  区域大小704*576
        /// </summary>
        //遮挡报警(子结构)(9000扩展)  区域大小704*576
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HIDEALARM_V30
        {
            /// <summary>
            /// 是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度
            /// </summary>
            public uint dwEnableHideAlarm;
            /// <summary>
            /// 遮挡区域的x坐标
            /// </summary>
            public ushort wHideAlarmAreaTopLeftX;
            /// <summary>
            /// 遮挡区域的y坐标
            /// </summary>
            public ushort wHideAlarmAreaTopLeftY;
            /// <summary>
            /// 遮挡区域的宽
            /// </summary>
            public ushort wHideAlarmAreaWidth;
            /// <summary>
            /// 遮挡区域的高
            /// </summary>
            public ushort wHideAlarmAreaHeight;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 strHideAlarmHandleType;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
        }

        /// <summary>
        /// 遮挡报警(子结构)  区域大小704*576
        /// </summary>
        //遮挡报警(子结构)  区域大小704*576
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HIDEALARM
        {
            /// <summary>
            /// 是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度
            /// </summary>
            public uint dwEnableHideAlarm;
            /// <summary>
            /// 遮挡区域的x坐标
            /// </summary>
            public ushort wHideAlarmAreaTopLeftX;
            /// <summary>
            /// 遮挡区域的y坐标
            /// </summary>
            public ushort wHideAlarmAreaTopLeftY;
            /// <summary>
            /// 遮挡区域的宽
            /// </summary>
            public ushort wHideAlarmAreaWidth;
            /// <summary>
            /// 遮挡区域的高
            /// </summary>
            public ushort wHideAlarmAreaHeight;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION strHideAlarmHandleType;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
        }

        /// <summary>
        /// 信号丢失报警(子结构)(9000扩展)
        /// </summary>
        //信号丢失报警(子结构)(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VILOST_V30
        {
            /// <summary>
            /// 是否处理信号丢失报警
            /// </summary>
            public byte byEnableHandleVILost;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 strVILostHandleType;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 56, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
        }

        /// <summary>
        /// 信号丢失报警(子结构)
        /// </summary>
        //信号丢失报警(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VILOST
        {
            /// <summary>
            /// 是否处理信号丢失报警
            /// </summary>
            public byte byEnableHandleVILost;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION strVILostHandleType;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
        }

        /// <summary>
        /// 遮挡区域(子结构)
        /// </summary>
        //遮挡区域(子结构)
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public struct NET_DVR_SHELTER
        {
            /// <summary>
            /// 遮挡区域的x坐标
            /// </summary>
            public ushort wHideAreaTopLeftX;
            /// <summary>
            /// 遮挡区域的y坐标
            /// </summary>
            public ushort wHideAreaTopLeftY;
            /// <summary>
            /// 遮挡区域的宽
            /// </summary>
            public ushort wHideAreaWidth;
            /// <summary>
            /// 遮挡区域的高
            /// </summary>
            public ushort wHideAreaHeight;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_COLOR
        {
            /// <summary>
            /// 亮度,0-255
            /// </summary>
            public byte byBrightness;
            /// <summary>
            /// 对比度,0-255
            /// </summary>
            public byte byContrast;
            /// <summary>
            /// 饱和度,0-255
            /// </summary>
            public byte bySaturation;
            /// <summary>
            /// 色调,0-255
            /// </summary>
            public byte byHue;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_RGB_COLOR
        {
            /// <summary>
            /// RGB颜色三分量中的红色
            /// </summary>
            public byte byRed;
            /// <summary>
            /// RGB颜色三分量中的绿色
            /// </summary>
            public byte byGreen;
            /// <summary>
            /// RGB颜色三分量中的蓝色
            /// </summary>
            public byte byBlue;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_DAYTIME
        {
            /// <summary>
            /// 0~24
            /// </summary>
            public byte byHour;
            /// <summary>
            /// 0~60
            /// </summary>
            public byte byMinute;
            /// <summary>
            /// 0~60
            /// </summary>
            public byte bySecond;
            public byte byRes;
            /// <summary>
            /// 0~1000
            /// </summary>
            public ushort wMilliSecond;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_SCHEDULE_DAYTIME
        {
            /// <summary>
            /// 开始时间
            /// </summary>
            public NET_DVR_DAYTIME struStartTime;
            /// <summary>
            /// 结束时间
            /// </summary>
            public NET_DVR_DAYTIME struStopTime;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_DNMODE
        {
            /// <summary>
            /// 占比参数(0~100)
            /// </summary>
            public byte byObjectSize;
            /// <summary>
            /// 移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭
            /// </summary>
            public byte byMotionSensitive;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MOTION_MULTI_AREAPARAM
        {
            /// <summary>
            /// 区域编号(IPC- 1~8)
            /// </summary>
            public byte byAreaNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 单个区域的坐标信息(矩形) size = 16;
            /// </summary>
            public NET_VCA_RECT struRect;
            /// <summary>
            /// 关闭模式
            /// </summary>
            public NET_DVR_DNMODE struDayNightDisable;
            /// <summary>
            /// 白天模式
            /// </summary>
            public NET_DVR_DNMODE struDayModeParam;
            /// <summary>
            /// 夜晚模式
            /// </summary>
            public NET_DVR_DNMODE struNightModeParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MOTION_MULTI_AREA
        {
            /// <summary>
            /// 日夜控制 0~关闭,1~自动切换,2~定时切换(默认关闭)
            /// </summary>
            public byte byDayNightCtrl;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 切换时间  16
            /// </summary>
            public NET_DVR_SCHEDULE_DAYTIME struScheduleTime;
            /// <summary>
            /// 最大支持24个区域
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_MULTI_AREA_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_MOTION_MULTI_AREAPARAM[] struMotionMultiAreaParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 60, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MOTION_SINGLE_AREA
        {
            /// <summary>
            /// 侦测区域,0-96位,表示64行,共有96*64个小宏块,目前有效的是22*18,为1表示是移动侦测区域,0-表示不是
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64 * 96, ArraySubType = UnmanagedType.I1)]
            public byte[] byMotionScope;
            /// <summary>
            /// 移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭
            /// </summary>
            public byte byMotionSensitive;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MOTION_MODE_PARAM
        {
            /// <summary>
            /// 普通模式下的单区域设
            /// </summary>
            public NET_DVR_MOTION_SINGLE_AREA struMotionSingleArea;
            /// <summary>
            /// 专家模式下的多区域设置
            /// </summary>
            public NET_DVR_MOTION_MULTI_AREA struMotionMultiArea;
        }

        /// <summary>
        /// 移动侦测
        /// </summary>
        //移动侦测
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MOTION_V40
        {
            /// <summary>
            /// (5.1.0新增)
            /// </summary>
            public NET_DVR_MOTION_MODE_PARAM struMotionMode;
            /// <summary>
            /// 是否处理移动侦测 0－否 1－是
            /// </summary>
            public byte byEnableHandleMotion;
            /// <summary>
            /// 启用移动侦测高亮显示，0-否，1-是
            /// </summary>
            public byte byEnableDisplay;
            /// <summary>
            /// 0~普通,1~专家(5.1.0新增)
            /// </summary>
            public byte byConfigurationMode;
            /// <summary>
            /// 保留字节
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// 异常处理方式
            /// </summary>
            public uint dwHandleType;
            /// <summary>
            /// 0x00: 无响应
            /// 0x01: 显示器上警告
            /// 0x02: 声音警告
            /// 0x04: 上传中心
            /// 0x08: 触发报警输出
            /// 0x10: 触发JPRG抓图并上传Email
            /// 0x20: 无线声光报警器联动
            /// 0x40: 联动电子地图(目前只有PCNVR支持)
            /// 0x200: 抓图并上传FTP
            /// </summary>
            public uint dwMaxRelAlarmOutChanNum;
            /// <summary>
            /// 实际触发的报警输出号，按值表示,采用紧凑型排列，从下标0 - dwRelAlarmOut -1有效，如果中间遇到0xffffffff,则后续无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMOUT_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRelAlarmOut;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 触发的录像通道
            /// </summary>
            public uint dwMaxRecordChanNum;
            /// <summary>
            /// 实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - dwRelRecordChan -1有效，如果中间遇到0xffffffff,则后续无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRelRecordChan;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 遮挡报警
        /// </summary>
        //遮挡报警
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_HIDEALARM_V40
        {
            /// <summary>
            /// 是否启动遮挡报警，0-否，1-低灵敏度，2-中灵敏度，3-高灵敏度
            /// </summary>
            public uint dwEnableHideAlarm;
            /// <summary>
            /// 遮挡区域的x坐标
            /// </summary>
            public ushort wHideAlarmAreaTopLeftX;
            /// <summary>
            /// 遮挡区域的y坐标
            /// </summary>
            public ushort wHideAlarmAreaTopLeftY;
            /// <summary>
            /// 遮挡区域的宽
            /// </summary>
            public ushort wHideAlarmAreaWidth;
            /// <summary>
            /// 遮挡区域的高
            /// </summary>
            public ushort wHideAlarmAreaHeight;
            /// <summary>
            /// 信号丢失触发报警输出
            /// </summary>
            public uint dwHandleType;
            /// <summary>
            /// 0x00: 无响应
            /// 0x01: 显示器上警告
            /// 0x02: 声音警告
            /// 0x04: 上传中心
            /// 0x08: 触发报警输出
            /// 0x10: 触发JPRG抓图并上传Email
            /// 0x20: 无线声光报警器联动
            /// 0x40: 联动电子地图(目前只有PCNVR支持)
            /// 0x200: 抓图并上传FTP
            /// </summary>
            public uint dwMaxRelAlarmOutChanNum;
            /// <summary>
            /// 触发报警输出号，按值表示,采用紧凑型排列，从下标0 - dwRelAlarmOut -1有效，如果中间遇到0xffffffff,则后续无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMOUT_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRelAlarmOut;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 信号丢失报警
        /// </summary>
        //信号丢失报警
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_VILOST_V40
        {
            /// <summary>
            /// 是否启动信号丢失报警 ,0-否,1-是
            /// </summary>
            public uint dwEnableVILostAlarm;
            /// <summary>
            /// 信号丢失触发报警输出
            /// </summary>
            public uint dwHandleType;
            /// <summary>
            /// 0x00: 无响应
            /// 0x01: 显示器上警告
            /// 0x02: 声音警告
            /// 0x04: 上传中心
            /// 0x08: 触发报警输出
            /// 0x10: 触发JPRG抓图并上传Email
            /// 0x20: 无线声光报警器联动
            /// 0x40: 联动电子地图(目前只有PCNVR支持)
            /// 0x200: 抓图并上传FTP
            /// </summary>
            public uint dwMaxRelAlarmOutChanNum;
            /// <summary>
            /// 触发报警输出号，按值表示,采用紧凑型排列，从下标0 - dwRelAlarmOut -1有效，如果中间遇到0xffffffff,则后续无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMOUT_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRelAlarmOut;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_VICOLOR
        {
            /// <summary>
            /// 图象参数(第一个有效，其他三个保留)
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_COLOR[] struColor;
            /// <summary>
            /// 处理时间段(保留)
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struHandleTime;
        }

        /// <summary>
        /// 通道图象结构(V40扩展)
        /// </summary>
        //通道图象结构(V40扩展)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_PICCFG_V40
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sChanName;
            /// <summary>
            /// 只读 视频制式 1-NTSC 2-PAL
            /// </summary>
            public uint dwVideoFormat;
            /// <summary>
            /// 图像参数按时间段设置
            /// </summary>
            public NET_DVR_VICOLOR struViColor;
            /// <summary>
            /// 显示通道名
            /// </summary>
            public uint dwShowChanName;
            /// <summary>
            /// 通道名称显示位置的x坐标
            /// </summary>
            public ushort wShowNameTopLeftX;
            /// <summary>
            /// 通道名称显示位置的y坐标
            /// </summary>
            public ushort wShowNameTopLeftY;
            /// <summary>
            /// 隐私遮挡
            /// </summary>
            public uint dwEnableHide;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SHELTERNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SHELTER[] struShelter;
            /// <summary>
            /// OSD
            /// </summary>
            public uint dwShowOsd;
            /// <summary>
            /// OSD的x坐标
            /// </summary>
            public ushort wOSDTopLeftX;
            /// <summary>
            /// OSD的y坐标
            /// </summary>
            public ushort wOSDTopLeftY;
            /// <summary>
            /// OSD类型(主要是年月日格式)
            /// </summary>
            public byte byOSDType;
            /// <summary>
            /// 0: XXXX-XX-XX 年月日
            /// 1: XX-XX-XXXX 月日年
            /// 2: XXXX年XX月XX日
            /// 3: XX月XX日XXXX年
            /// 4: XX-XX-XXXX 日月年
            /// 5: XX日XX月XXXX年
            /// 6: xx/xx/xxxx(月/日/年)
            /// 7: xxxx/xx/xx(年/月/日)
            /// 8: xx/xx/xxxx(日/月/年)
            /// </summary>
            public byte byDispWeek;
            /// <summary>
            /// OSD属性:透明，闪烁
            /// </summary>
            public byte byOSDAttrib;
            /// <summary>
            /// 0: 不显示OSD
            /// 1: 透明，闪烁
            /// 2: 透明，不闪烁
            /// 3: 不透明，闪烁
            /// 4: 不透明，不闪烁
            /// </summary>
            public byte byHourOSDType;
            /// <summary>
            /// 16*16(中)/8*16(英)，1-32*32(中)/16*32(英)，2-64*64(中)/32*64(英) FOR 91系列HD-SDI高清DVR
            /// </summary>
            public byte byFontSize;
            /// <summary>
            /// 0-默认（黑白）；1-自定义
            /// </summary>
            public byte byOSDColorType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 视频信号丢失报警（支持组）
            /// </summary>
            public NET_DVR_VILOST_V40 struVILost;
            /// <summary>
            /// 音频信号丢失报警（支持组）
            /// </summary>
            public NET_DVR_VILOST_V40 struAULost;
            /// <summary>
            /// 移动侦测报警（支持组）
            /// </summary>
            public NET_DVR_MOTION_V40 struMotion;
            /// <summary>
            /// 遮挡报警（支持组）
            /// </summary>
            public NET_DVR_HIDEALARM_V40 struHideAlarm;
            /// <summary>
            /// OSD颜色
            /// </summary>
            public NET_DVR_RGB_COLOR struOsdColor;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 124, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 通道图象结构(9000扩展)
        /// </summary>
        //通道图象结构(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_PICCFG_V30
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sChanName;
            /// <summary>
            /// 只读 视频制式 1-NTSC 2-PAL
            /// </summary>
            public uint dwVideoFormat;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byReservedData;
            /// <summary>
            /// 显示通道名
            /// </summary>
            public uint dwShowChanName;
            /// <summary>
            /// 通道名称显示位置的x坐标
            /// </summary>
            public ushort wShowNameTopLeftX;
            /// <summary>
            /// 通道名称显示位置的y坐标
            /// </summary>
            public ushort wShowNameTopLeftY;
            /// <summary>
            /// 视频信号丢失报警
            /// </summary>
            public NET_DVR_VILOST_V30 struVILost;
            /// <summary>
            /// 保留
            /// </summary>
            public NET_DVR_VILOST_V30 struRes;
            /// <summary>
            /// 移动侦测
            /// </summary>
            public NET_DVR_MOTION_V30 struMotion;
            /// <summary>
            /// 遮挡报警
            /// </summary>
            public NET_DVR_HIDEALARM_V30 struHideAlarm;
            /// <summary>
            /// 遮挡  区域大小704*576
            /// </summary>
            public uint dwEnableHide;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SHELTERNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SHELTER[] struShelter;
            /// <summary>
            /// OSD
            /// </summary>
            public uint dwShowOsd;
            /// <summary>
            /// OSD的x坐标
            /// </summary>
            public ushort wOSDTopLeftX;
            /// <summary>
            /// OSD的y坐标
            /// </summary>
            public ushort wOSDTopLeftY;
            /// <summary>
            /// OSD类型(主要是年月日格式)
            /// </summary>
            public byte byOSDType;
            /// <summary>
            /// 0: XXXX-XX-XX 年月日
            /// 1: XX-XX-XXXX 月日年
            /// 2: XXXX年XX月XX日
            /// 3: XX月XX日XXXX年
            /// 4: XX-XX-XXXX 日月年
            /// 5: XX日XX月XXXX年
            /// </summary>
            public byte byDispWeek;
            /// <summary>
            /// OSD属性:透明，闪烁
            /// </summary>
            public byte byOSDAttrib;
            /// <summary>
            /// 0: 不显示OSD
            /// 1: 透明,闪烁
            /// 2: 透明,不闪烁
            /// 3: 闪烁,不透明
            /// 4: 不透明,不闪烁
            /// </summary>
            public byte byHourOSDType;
            /// <summary>
            /// 字体大小，16*16(中)/8*16(英)，1-32*32(中)/16*32(英)，2-64*64(中)/32*64(英)  3-48*48(中)/24*48(英) 0xff-自适应(adaptive)
            /// </summary>
            public byte byFontSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 63, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 通道图象结构SDK_V14扩展
        /// </summary>
        //通道图象结构SDK_V14扩展
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PICCFG_EX
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sChanName;
            /// <summary>
            /// 只读 视频制式 1-NTSC 2-PAL
            /// </summary>
            public uint dwVideoFormat;
            /// <summary>
            /// 亮度,0-255
            /// </summary>
            public byte byBrightness;
            /// <summary>
            /// 对比度,0-255
            /// </summary>
            public byte byContrast;
            /// <summary>
            /// 饱和度,0-255
            /// </summary>
            public byte bySaturation;
            /// <summary>
            /// 色调,0-255
            /// </summary>
            public byte byHue;
            /// <summary>
            /// 显示通道名
            /// </summary>
            public uint dwShowChanName;
            /// <summary>
            /// 通道名称显示位置的x坐标
            /// </summary>
            public ushort wShowNameTopLeftX;
            /// <summary>
            /// 通道名称显示位置的y坐标
            /// </summary>
            public ushort wShowNameTopLeftY;
            /// <summary>
            /// 信号丢失报警
            /// </summary>
            public NET_DVR_VILOST struVILost;
            /// <summary>
            /// 移动侦测
            /// </summary>
            public NET_DVR_MOTION struMotion;
            /// <summary>
            /// 遮挡报警
            /// </summary>
            public NET_DVR_HIDEALARM struHideAlarm;
            /// <summary>
            /// 遮挡  区域大小704*576
            /// </summary>
            public uint dwEnableHide;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SHELTERNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SHELTER[] struShelter;
            /// <summary>
            /// OSD
            /// </summary>
            public uint dwShowOsd;
            /// <summary>
            /// OSD的x坐标
            /// </summary>
            public ushort wOSDTopLeftX;
            /// <summary>
            /// OSD的y坐标
            /// </summary>
            public ushort wOSDTopLeftY;
            /// <summary>
            /// OSD类型(主要是年月日格式)
            /// </summary>
            public byte byOSDType;
            /// <summary>
            /// 0: XXXX-XX-XX 年月日
            /// 1: XX-XX-XXXX 月日年
            /// 2: XXXX年XX月XX日
            /// 3: XX月XX日XXXX年
            /// 4: XX-XX-XXXX 日月年
            /// 5: XX日XX月XXXX年
            /// </summary>
            public byte byDispWeek;
            /// <summary>
            /// OSD属性:透明，闪烁
            /// </summary>
            public byte byOSDAttrib;
            /// <summary>
            /// 0: 不显示OSD
            /// 1: 透明,闪烁
            /// 2: 透明,不闪烁
            /// 3: 闪烁,不透明
            /// 4: 不透明,不闪烁
            /// </summary>
            public byte byHourOsdType;
        }

        /// <summary>
        /// 通道图象结构(SDK_V13及之前版本)
        /// </summary>
        //通道图象结构(SDK_V13及之前版本)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PICCFG
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sChanName;
            /// <summary>
            /// 只读 视频制式 1-NTSC 2-PAL
            /// </summary>
            public uint dwVideoFormat;
            /// <summary>
            /// 亮度,0-255
            /// </summary>
            public byte byBrightness;
            /// <summary>
            /// 对比度,0-255
            /// </summary>
            public byte byContrast;
            /// <summary>
            /// 饱和度,0-255
            /// </summary>
            public byte bySaturation;
            /// <summary>
            /// 色调,0-255
            /// </summary>
            public byte byHue;
            /// <summary>
            /// 显示通道名
            /// </summary>
            public uint dwShowChanName;
            /// <summary>
            /// 通道名称显示位置的x坐标
            /// </summary>
            public ushort wShowNameTopLeftX;
            /// <summary>
            /// 通道名称显示位置的y坐标
            /// </summary>
            public ushort wShowNameTopLeftY;
            /// <summary>
            /// 信号丢失报警
            /// </summary>
            public NET_DVR_VILOST struVILost;
            /// <summary>
            /// 移动侦测
            /// </summary>
            public NET_DVR_MOTION struMotion;
            /// <summary>
            /// 遮挡报警
            /// </summary>
            public NET_DVR_HIDEALARM struHideAlarm;
            /// <summary>
            /// 遮挡  区域大小704*576
            /// </summary>
            public uint dwEnableHide;
            /// <summary>
            /// 遮挡区域的x坐标
            /// </summary>
            public ushort wHideAreaTopLeftX;
            /// <summary>
            /// 遮挡区域的y坐标
            /// </summary>
            public ushort wHideAreaTopLeftY;
            /// <summary>
            /// 遮挡区域的宽
            /// </summary>
            public ushort wHideAreaWidth;
            /// <summary>
            /// 遮挡区域的高
            /// </summary>
            public ushort wHideAreaHeight;
            /// <summary>
            /// OSD
            /// </summary>
            public uint dwShowOsd;
            /// <summary>
            /// OSD的x坐标
            /// </summary>
            public ushort wOSDTopLeftX;
            /// <summary>
            /// OSD的y坐标
            /// </summary>
            public ushort wOSDTopLeftY;
            /// <summary>
            /// OSD类型(主要是年月日格式)
            /// </summary>
            public byte byOSDType;
            /// <summary>
            /// 0: XXXX-XX-XX 年月日
            /// 1: XX-XX-XXXX 月日年
            /// 2: XXXX年XX月XX日
            /// 3: XX月XX日XXXX年
            /// 4: XX-XX-XXXX 日月年
            /// 5: XX日XX月XXXX年
            /// </summary>
            public byte byDispWeek;
            /// <summary>
            /// OSD属性:透明，闪烁
            /// </summary>
            public byte byOSDAttrib;
            /// <summary>
            /// 0: 不显示OSD
            /// 1: 透明,闪烁
            /// 2: 透明,不闪烁
            /// 3: 闪烁,不透明
            /// 4: 不透明,不闪烁
            /// </summary>
            public byte reservedData2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND
        {
            public uint dwSize;
            public NET_DVR_STREAM_INFO struStreamInfo;
            /// <summary>
            /// 码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……（自定义码流类型需通过GET /ISAPI/Streaming/channels/<ID>/customStream获取当前通道已经添加的所有自定义码流ID。自定义码流为6~10，其索引值就是6~10）
            /// </summary>
            public uint dwStreamType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MULTI_STREAM_COMPRESSIONCFG
        {
            public uint dwSize;
            /// <summary>
            /// 码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
            /// </summary>
            public uint dwStreamType;
            /// <summary>
            /// 码流压缩参数
            /// </summary>
            public NET_DVR_COMPRESSION_INFO_V30 struStreamPara;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 80, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 码流压缩参数(子结构)(9000扩展)
        /// </summary>
        //码流压缩参数(子结构)(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_COMPRESSION_INFO_V30
        {
            /// <summary>
            /// 码流类型 0-视频流, 1-复合流, 表示事件压缩参数时最高位表示是否启用压缩参数
            /// </summary>
            public byte byStreamType;
            /// <summary>
            /// 分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）16-VGA（640*480） 17-UXGA（1600*1200） 18-SVGA （800*600）19-HD720p（1280*720）20-XVGA  21-HD900p
            /// </summary>
            public byte byResolution;
            /// <summary>
            /// 码率类型 0:变码率, 1:定码率
            /// </summary>
            public byte byBitrateType;
            /// <summary>
            /// 图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差
            /// </summary>
            public byte byPicQuality;
            /// <summary>
            /// 视频码率 0-保留 1-16K 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
            /// </summary>
            public uint dwVideoBitrate;
            /// <summary>
            /// 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
            /// 最高位(31位)置成1表示是自定义码流, 0-30位表示码流值。
            /// </summary>
            public uint dwVideoFrameRate;
            /// <summary>
            /// I帧间隔
            /// </summary>
            public ushort wIntervalFrameI;
            /// <summary>
            /// 2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题
            /// </summary>
            public byte byIntervalBPFrame;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byres1;
            /// <summary>
            /// 视频编码类型 0 hik264;1标准h264; 2标准mpeg4;
            /// </summary>
            public byte byVideoEncType;
            /// <summary>
            /// 音频编码类型 0－OggVorbis
            /// </summary>
            public byte byAudioEncType;
            /// <summary>
            /// 视频编码复杂度，0-低，1-中，2高,0xfe:自动，和源一致
            /// </summary>
            public byte byVideoEncComplexity;
            /// <summary>
            /// 0 - 不启用SVC功能；1- 启用SVC功能
            /// </summary>
            public byte byEnableSvc;
            /// <summary>
            /// 封装类型，1-裸流，2-RTP封装，3-PS封装，4-TS封装，5-私有，6-FLV，7-ASF，8-3GP,9-RTP+PS（国标：GB28181），0xff-无效
            /// </summary>
            public byte byFormatType;
            /// <summary>
            /// 音频码率0-默认，1-8Kbps, 2- 16Kbps, 3-32Kbps，4-64Kbps，5-128Kbps，6-192Kbps；(IPC5.1.0默认4-64Kbps)
            /// </summary>
            public byte byAudioBitRate;
            /// <summary>
            /// 这里保留音频的压缩参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byres;
        }

        /// <summary>
        /// 通道压缩参数(9000扩展)
        /// </summary>
        //通道压缩参数(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_COMPRESSIONCFG_V30
        {
            public uint dwSize;
            /// <summary>
            /// 录像 对应8000的普通
            /// </summary>
            public NET_DVR_COMPRESSION_INFO_V30 struNormHighRecordPara;
            /// <summary>
            /// 保留 char reserveData[28];
            /// </summary>
            public NET_DVR_COMPRESSION_INFO_V30 struRes;
            /// <summary>
            /// 事件触发压缩参数
            /// </summary>
            public NET_DVR_COMPRESSION_INFO_V30 struEventRecordPara;
            /// <summary>
            /// 网传(子码流)
            /// </summary>
            public NET_DVR_COMPRESSION_INFO_V30 struNetPara;
        }

        /// <summary>
        /// 码流压缩参数(子结构)
        /// </summary>
        //码流压缩参数(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_COMPRESSION_INFO
        {
            /// <summary>
            /// 码流类型0-视频流,1-复合流,表示压缩参数时最高位表示是否启用压缩参数
            /// </summary>
            public byte byStreamType;
            /// <summary>
            /// 分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(车载专用)
            /// </summary>
            public byte byResolution;
            /// <summary>
            /// 码率类型0:变码率，1:定码率
            /// </summary>
            public byte byBitrateType;
            /// <summary>
            /// 图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差
            /// </summary>
            public byte byPicQuality;
            /// <summary>
            /// 视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
            /// </summary>
            public uint dwVideoBitrate;
            /// <summary>
            /// 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
            /// 最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。
            /// </summary>
            public uint dwVideoFrameRate;
        }

        /// <summary>
        /// 通道压缩参数
        /// </summary>
        //通道压缩参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_COMPRESSIONCFG
        {
            public uint dwSize;
            /// <summary>
            /// 录像/事件触发录像
            /// </summary>
            public NET_DVR_COMPRESSION_INFO struRecordPara;
            /// <summary>
            /// 网传/保留
            /// </summary>
            public NET_DVR_COMPRESSION_INFO struNetPara;
        }

        /// <summary>
        /// 码流压缩参数(子结构)(扩展) 增加I帧间隔
        /// </summary>
        //码流压缩参数(子结构)(扩展) 增加I帧间隔
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_COMPRESSION_INFO_EX
        {
            /// <summary>
            /// 码流类型0-视频流, 1-复合流
            /// </summary>
            public byte byStreamType;
            /// <summary>
            /// 分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(车载专用)
            /// </summary>
            public byte byResolution;
            /// <summary>
            /// 码率类型0:变码率，1:定码率
            /// </summary>
            public byte byBitrateType;
            /// <summary>
            /// 图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差
            /// </summary>
            public byte byPicQuality;
            /// <summary>
            /// 视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
            /// </summary>
            public uint dwVideoBitrate;
            /// <summary>
            /// 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
            /// 最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。
            /// </summary>
            public uint dwVideoFrameRate;
            /// <summary>
            /// I帧间隔
            /// </summary>
            public ushort wIntervalFrameI;
            /// <summary>
            /// 2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题
            /// </summary>
            public byte byIntervalBPFrame;
            public byte byRes;
        }

        /// <summary>
        /// 通道压缩参数(扩展)
        /// </summary>
        //通道压缩参数(扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_COMPRESSIONCFG_EX
        {
            public uint dwSize;
            /// <summary>
            /// 录像
            /// </summary>
            public NET_DVR_COMPRESSION_INFO_EX struRecordPara;
            /// <summary>
            /// 网传
            /// </summary>
            public NET_DVR_COMPRESSION_INFO_EX struNetPara;
        }

        /// <summary>
        /// 时间段录像参数配置(子结构)
        /// </summary>
        //时间段录像参数配置(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_RECORDSCHED
        {
            public NET_DVR_SCHEDTIME struRecordTime;
            /// <summary>
            /// 0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警, 5:命令触发, 6: 智能录像
            /// </summary>
            public byte byRecordType;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 3)]
            public string reservedData;
        }

        /// <summary>
        /// 全天录像参数配置(子结构)
        /// </summary>
        //全天录像参数配置(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RECORDDAY
        {
            /// <summary>
            /// 是否全天录像 0-否 1-是
            /// </summary>
            public ushort wAllDayRecord;
            /// <summary>
            /// 录象类型 0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发, 6: 智能录像
            /// </summary>
            public byte byRecordType;
            public byte reservedData;
        }

        /// <summary>
        /// 时间段录像参数配置(子结构)
        /// </summary>
        //时间段录像参数配置(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RECORDSCHED_V40
        {
            public NET_DVR_SCHEDTIME struRecordTime;
            /// <summary>
            /// 录像类型，0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发,
            /// 6-智能报警录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件,14-智能交通事件,
            /// 15-越界侦测,16-区域入侵,17-声音异常,18-场景变更侦测,
            /// 19-智能侦测(越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测),20－人脸侦测,21-POS录像,
            /// 22-进入区域侦测, 23-离开区域侦测,24-徘徊侦测,25-人员聚集侦测,26-快速运动侦测,27-停车侦测,
            /// 28-物品遗留侦测,29-物品拿取侦测,30-火点检测，31-防破坏检测,32-打架斗殴事件(司法),33-起身事件(司法), 34-瞌睡事件(司法)
            /// 35-船只检测, 36-测温预警，37-测温报警，38-温差报警，39-离线测温报警,40-防区报警，41-紧急求助,42-业务咨询,43-起身检测,44-折线攀高,45-目标区域滞留超时，46-人脸抓拍，47-非法摆摊,48-目标抓拍,
            /// 49-剧烈运动，50高危目标岗位检测-离岗检测，51-起立，52人数变化
            /// </summary>
            public byte byRecordType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 31, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 全天录像参数配置(子结构)
        /// </summary>
        //全天录像参数配置(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RECORDDAY_V40
        {
            /// <summary>
            /// 是否全天录像 0-否 1-是
            /// </summary>
            public byte byAllDayRecord;
            /// <summary>
            /// 录像类型，0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发,
            /// 6-智能报警录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件,14-智能交通事件,
            /// 15-越界侦测,16-区域入侵,17-声音异常,18-场景变更侦测,
            /// 19-智能侦测(越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测),20－人脸侦测,21-POS录像,
            /// 22-进入区域侦测, 23-离开区域侦测,24-徘徊侦测,25-人员聚集侦测,26-快速运动侦测,27-停车侦测,
            /// 28-物品遗留侦测,29-物品拿取侦测,30-火点检测，31-防破坏检测,32-打架斗殴事件(司法),33-起身事件(司法), 34-瞌睡事件(司法)
            /// 35-船只检测, 36-测温预警，37-测温报警，38-温差报警，39-离线测温报警,40-防区报警，41-紧急求助,42-业务咨询,43-起身检测,44-折线攀高,45-目标区域滞留超时,46-人脸抓拍,47-非法摆摊,48-目标抓拍,
            /// 49-剧烈运动，50高危目标岗位检测-离岗检测，51-起立，52人数变化
            /// </summary>
            public byte byRecordType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 62, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RECORD_V40
        {
            public uint dwSize;
            /// <summary>
            /// 是否录像 0-否 1-是
            /// </summary>
            public uint dwRecord;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_RECORDDAY_V40[] struRecAllDay;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_RECORDSCHED_V40[] struRecordSched;
            /// <summary>
            /// 录象延时长度 0-5秒， 1-10秒， 2-30秒， 3-1分钟， 4-2分钟， 5-5分钟， 6-10分钟
            /// </summary>
            public uint dwRecordTime;
            /// <summary>
            /// 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录)
            /// </summary>
            public uint dwPreRecordTime;
            /// <summary>
            /// 录像保存的最长时间
            /// </summary>
            public uint dwRecorderDuration;
            /// <summary>
            /// 是否冗余录像,重要数据双备份：0/1
            /// </summary>
            public byte byRedundancyRec;
            /// <summary>
            /// 录像时复合流编码时是否记录音频数据：国外有此法规
            /// </summary>
            public byte byAudioRec;
            /// <summary>
            /// 0-主码流，1-子码流，2-主子码流同时 3-三码流
            /// </summary>
            public byte byStreamType;
            /// <summary>
            /// 0:不回传录像 1：回传录像
            /// </summary>
            public byte byPassbackRecord;
            /// <summary>
            /// 录像锁定时长，单位小时 0表示不锁定，0xffff表示永久锁定，录像段的时长大于锁定的持续时长的录像，将不会锁定
            /// </summary>
            public ushort wLockDuration;
            /// <summary>
            /// 0:录像不存档 1：录像存档
            /// </summary>
            public byte byRecordBackup;
            /// <summary>
            /// SVC抽帧类型：0-不抽，1-抽二分之一 2-抽四分之三
            /// </summary>
            public byte bySVCLevel;
            /// <summary>
            /// 录像调度，0-启用， 1-不启用; 启用时进行定时录像；不启用时不进行定时录像，但是录像计划仍在使用，比如移动侦测，回传都还在按这条录像计划进行
            /// </summary>
            public byte byRecordManage;
            /// <summary>
            /// 音频单独存储
            /// </summary>
            public byte byExtraSaveAudio;
            /// <summary>
            /// 开启智能录像功能后，算法库是自动启用智能录像算法，其功能为若录像中无目标出现，会降低码率、帧率，而目标出现时又恢复全码率及帧率，从而达到减少资源消耗的目的
            /// </summary>
            public byte byIntelligentRecord;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 125, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 通道录像参数配置(9000扩展)
        /// </summary>
        //通道录像参数配置(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RECORD_V30
        {
            public uint dwSize;
            /// <summary>
            /// 是否录像 0-否 1-是
            /// </summary>
            public uint dwRecord;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_RECORDDAY[] struRecAllDay;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_RECORDSCHED[] struRecordSched;
            /// <summary>
            /// 录象延时长度 0-5秒， 1-20秒， 2-30秒， 3-1分钟， 4-2分钟， 5-5分钟， 6-10分钟
            /// </summary>
            public uint dwRecordTime;
            /// <summary>
            /// 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录)
            /// </summary>
            public uint dwPreRecordTime;
            /// <summary>
            /// 录像保存的最长时间
            /// </summary>
            public uint dwRecorderDuration;
            /// <summary>
            /// 是否冗余录像,重要数据双备份：0/1
            /// </summary>
            public byte byRedundancyRec;
            /// <summary>
            /// 录像时复合流编码时是否记录音频数据：国外有此法规
            /// </summary>
            public byte byAudioRec;
            /// <summary>
            /// 0:主码流 1：子码流
            /// </summary>
            public byte byStreamType;
            /// <summary>
            /// 0:不回传录像 1：回传录像
            /// </summary>
            public byte byPassbackRecord;
            /// <summary>
            /// 录像锁定时长，单位小时 0表示不锁定，0xffff表示永久锁定，录像段的时长大于锁定的持续时长的录像，将不会锁定
            /// </summary>
            public ushort wLockDuration;
            /// <summary>
            /// 0:录像不存档 1：录像存档
            /// </summary>
            public byte byRecordBackup;
            /// <summary>
            /// SVC抽帧类型：0-不抽，1-抽二分之一 2-抽四分之三
            /// </summary>
            public byte bySVCLevel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byReserve;
        }

        /// <summary>
        /// 通道录像参数配置
        /// </summary>
        //通道录像参数配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RECORD
        {
            public uint dwSize;
            /// <summary>
            /// 是否录像 0-否 1-是
            /// </summary>
            public uint dwRecord;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_RECORDDAY[] struRecAllDay;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_RECORDSCHED[] struRecordSched;
            /// <summary>
            /// 录象时间长度
            /// </summary>
            public uint dwRecordTime;
            /// <summary>
            /// 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录)
            /// </summary>
            public uint dwPreRecordTime;
        }
        /// <summary>
        /// 操作数最大长度
        /// </summary>
        public const int MAX_OPERATE_INDEX_LEN = 32;

        /// <summary>
        /// 车牌颜色
        /// </summary>
        public enum VCA_PLATE_COLOR
        {
            /// <summary>
            /// 蓝色车牌
            /// </summary>
            VCA_BLUE_PLATE = 0,
            /// <summary>
            /// 黄色车牌
            /// </summary>
            VCA_YELLOW_PLATE,
            /// <summary>
            /// 白色车牌
            /// </summary>
            VCA_WHITE_PLATE,
            /// <summary>
            /// 黑色车牌
            /// </summary>
            VCA_BLACK_PLATE,
            /// <summary>
            /// 绿色车牌
            /// </summary>
            VCA_GREEN_PLATE,
            /// <summary>
            /// 民航黑色车牌
            /// </summary>
            VCA_BKAIR_PLATE,
            /// <summary>
            /// 红色车牌
            /// </summary>
            VCA_RED_PLATE,
            /// <summary>
            /// 橙色车牌
            /// </summary>
            VCA_ORANGE_PLATE,
            /// <summary>
            /// 棕色车牌
            /// </summary>
            VCA_BROWN_PLATE = 8,
            /// <summary>
            /// 其他
            /// </summary>
            VCA_OTHER = 0xff
        }

        /// <summary>
        /// 出入口名单的数据同步
        /// </summary>
        public struct NET_DVR_VEHICLE_CONTROL_LIST_INFO
        {
            public uint dwSize;
            /// <summary>
            /// 通道号0xff - 全部通道（ITC 默认是1）
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 数据流水号（平台维护的数据唯一值，客户端操作的时候，该值不会起效。该值主要用于数据增量同步）
            /// </summary>
            public uint dwDataIndex;
            /// <summary>
            /// 车牌号码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LICENSE_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sLicense;
            /// <summary>
            /// 名单属性（名单）0-允许名单，1-禁止名单
            /// </summary>
            public byte byListType;
            /// <summary>
            /// 车牌类型
            /// </summary>
            public byte byPlateType;
            /// <summary>
            /// 车牌颜色
            /// </summary>
            public byte byPlateColor;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 21, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 卡号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CARDNO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sCardNo;
            /// <summary>
            /// 有效开始时间
            /// </summary>
            public NET_DVR_TIME_V30 struStartTime;
            /// <summary>
            /// 有效结束时间
            /// </summary>
            public NET_DVR_TIME_V30 struStopTime;
            /// <summary>
            /// 操作数（平台同步表流水号不会重复，用于增量更新，代表同步到同步表的某一条记录了，存在相机内存，重启后会清0）2014-03-03
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_OPERATE_INDEX_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sOperateIndex;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 224, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }
        /// <summary>
        /// 卡号最大长度
        /// </summary>
        public const int MAX_CARDNO_LEN = 48;

        /// <summary>
        /// 车辆非授权名单信息获取条件结构体
        /// </summary>
        //车辆非授权名单信息获取条件结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VEHICLE_CONTROL_COND
        {
            public int dwChannel;
            /// <summary>
            /// 操作类型
            /// </summary>
            public int dwOperateType;
            /// <summary>
            /// 车牌号码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LICENSE_LEN, ArraySubType = UnmanagedType.Struct)]
            public byte[] sLicense;
            /// <summary>
            /// 卡号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CARDNO_LEN, ArraySubType = UnmanagedType.Struct)]
            public byte[] sCardNo;
            /// <summary>
            /// 名单属性0-允许名单，1-禁止名单，0xff-全部
            /// </summary>
            public byte byListType;
            /// <summary>
            /// 2014-02-25
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.Struct)]
            public byte[] byRes1;
            /// <summary>
            /// 数据流水号
            /// </summary>
            public int dwDataIndex;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 116, ArraySubType = UnmanagedType.Struct)]
            public byte[] byRes;
        }

        /// <summary>
        /// 云台协议表结构配置
        /// </summary>
        //云台协议表结构配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PTZ_PROTOCOL
        {
            /// <summary>
            /// 解码器类型值，从1开始连续递增
            /// </summary>
            public uint dwType;
            /// <summary>
            /// 解码器的描述符，和8000中的一致
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = DESC_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDescribe;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PTZCFG
        {
            public uint dwSize;
            /// <summary>
            /// 最大200中PTZ协议
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PTZ_PROTOCOL_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_PTZ_PROTOCOL[] struPtz;
            /// <summary>
            /// 有效的ptz协议数目，从0开始(即计算时加1)
            /// </summary>
            public uint dwPtzNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// *************************云台类型(end)*****************************
        /// 通道解码器(云台)参数配置(9000扩展)
        /// </summary>
        /***************************云台类型(end)******************************/

        //通道解码器(云台)参数配置(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DECODERCFG_V30
        {
            public uint dwSize;
            /// <summary>
            /// 波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
            /// </summary>
            public uint dwBaudRate;
            /// <summary>
            /// 数据有几位 0－5位，1－6位，2－7位，3－8位;
            /// </summary>
            public byte byDataBit;
            /// <summary>
            /// 停止位 0－1位，1－2位
            /// </summary>
            public byte byStopBit;
            /// <summary>
            /// 校验 0－无校验，1－奇校验，2－偶校验;
            /// </summary>
            public byte byParity;
            /// <summary>
            /// 0－无，1－软流控,2-硬流控
            /// </summary>
            public byte byFlowcontrol;
            /// <summary>
            /// 解码器类型, 从0开始，对应ptz协议列表
            /// </summary>
            public ushort wDecoderType;
            /// <summary>
            /// 解码器地址:0 - 255
            /// </summary>
            public ushort wDecoderAddress;
            /// <summary>
            /// 预置点是否设置,0-没有设置,1-设置
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_PRESET_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] bySetPreset;
            /// <summary>
            /// 巡航是否设置: 0-没有设置,1-设置
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CRUISE_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] bySetCruise;
            /// <summary>
            /// 是否设置,0-没有设置,1-设置
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TRACK_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] bySetTrack;
        }

        /// <summary>
        /// 通道解码器(云台)参数配置
        /// </summary>
        //通道解码器(云台)参数配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DECODERCFG
        {
            public uint dwSize;
            /// <summary>
            /// 波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
            /// </summary>
            public uint dwBaudRate;
            /// <summary>
            /// 数据有几位 0－5位，1－6位，2－7位，3－8位;
            /// </summary>
            public byte byDataBit;
            /// <summary>
            /// 停止位 0－1位，1－2位;
            /// </summary>
            public byte byStopBit;
            /// <summary>
            /// 校验 0－无校验，1－奇校验，2－偶校验;
            /// </summary>
            public byte byParity;
            /// <summary>
            /// 0－无，1－软流控,2-硬流控
            /// </summary>
            public byte byFlowcontrol;
            /// <summary>
            /// 解码器类型, 0－YouLi，1－LiLin-1016，2－LiLin-820，3－Pelco-p，4－DM DynaColor，5－HD600，6－JC-4116，7－Pelco-d WX，8－Pelco-d PICO
            /// </summary>
            public ushort wDecoderType;
            /// <summary>
            /// 解码器地址:0 - 255
            /// </summary>
            public ushort wDecoderAddress;
            /// <summary>
            /// 预置点是否设置,0-没有设置,1-设置
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_PRESET, ArraySubType = UnmanagedType.I1)]
            public byte[] bySetPreset;
            /// <summary>
            /// 巡航是否设置: 0-没有设置,1-设置
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CRUISE, ArraySubType = UnmanagedType.I1)]
            public byte[] bySetCruise;
            /// <summary>
            /// 是否设置,0-没有设置,1-设置
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TRACK, ArraySubType = UnmanagedType.I1)]
            public byte[] bySetTrack;
        }

        /// <summary>
        /// ppp参数配置(子结构)
        /// </summary>
        //ppp参数配置(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_PPPCFG_V30
        {
            /// <summary>
            /// 远端IP地址
            /// </summary>
            public NET_DVR_IPADDR struRemoteIP;
            /// <summary>
            /// 本地IP地址
            /// </summary>
            public NET_DVR_IPADDR struLocalIP;
            /// <summary>
            /// 本地IP地址掩码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sLocalIPMask;
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUsername;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// PPP模式, 0－主动，1－被动
            /// </summary>
            public byte byPPPMode;
            /// <summary>
            /// 是否回拨 ：0-否,1-是
            /// </summary>
            public byte byRedial;
            /// <summary>
            /// 回拨模式,0-由拨入者指定,1-预置回拨号码
            /// </summary>
            public byte byRedialMode;
            /// <summary>
            /// 数据加密,0-否,1-是
            /// </summary>
            public byte byDataEncrypt;
            /// <summary>
            /// MTU
            /// </summary>
            public uint dwMTU;
            /// <summary>
            /// 电话号码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = PHONENUMBER_LEN)]
            public string sTelephoneNumber;
        }

        /// <summary>
        /// ppp参数配置(子结构)
        /// </summary>
        //ppp参数配置(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_PPPCFG
        {
            /// <summary>
            /// 远端IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sRemoteIP;
            /// <summary>
            /// 本地IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sLocalIP;
            /// <summary>
            /// 本地IP地址掩码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sLocalIPMask;
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUsername;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// PPP模式, 0－主动，1－被动
            /// </summary>
            public byte byPPPMode;
            /// <summary>
            /// 是否回拨 ：0-否,1-是
            /// </summary>
            public byte byRedial;
            /// <summary>
            /// 回拨模式,0-由拨入者指定,1-预置回拨号码
            /// </summary>
            public byte byRedialMode;
            /// <summary>
            /// 数据加密,0-否,1-是
            /// </summary>
            public byte byDataEncrypt;
            /// <summary>
            /// MTU
            /// </summary>
            public uint dwMTU;
            /// <summary>
            /// 电话号码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = PHONENUMBER_LEN)]
            public string sTelephoneNumber;
        }

        /// <summary>
        /// RS232串口参数配置(9000扩展)
        /// </summary>
        //RS232串口参数配置(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SINGLE_RS232
        {
            /// <summary>
            /// 波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
            /// </summary>
            public uint dwBaudRate;
            /// <summary>
            /// 数据有几位 0－5位，1－6位，2－7位，3－8位
            /// </summary>
            public byte byDataBit;
            /// <summary>
            /// 停止位 0－1位，1－2位
            /// </summary>
            public byte byStopBit;
            /// <summary>
            /// 校验 0－无校验，1－奇校验，2－偶校验
            /// </summary>
            public byte byParity;
            /// <summary>
            /// 0－无，1－软流控,2-硬流控
            /// </summary>
            public byte byFlowcontrol;
            /// <summary>
            /// 工作模式，0－232串口用于PPP拨号，1－232串口用于参数控制，2－透明通道
            /// </summary>
            public uint dwWorkMode;
        }

        /// <summary>
        /// RS232串口参数配置(9000扩展)
        /// </summary>
        //RS232串口参数配置(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RS232CFG_V30
        {
            public uint dwSize;
            public NET_DVR_SINGLE_RS232 struRs232;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 84, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public NET_DVR_PPPCFG_V30 struPPPConfig;
        }

        /// <summary>
        /// RS232串口参数配置
        /// </summary>
        //RS232串口参数配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RS232CFG
        {
            public uint dwSize;
            /// <summary>
            /// 波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
            /// </summary>
            public uint dwBaudRate;
            /// <summary>
            /// 数据有几位 0－5位，1－6位，2－7位，3－8位;
            /// </summary>
            public byte byDataBit;
            /// <summary>
            /// 停止位 0－1位，1－2位;
            /// </summary>
            public byte byStopBit;
            /// <summary>
            /// 校验 0－无校验，1－奇校验，2－偶校验;
            /// </summary>
            public byte byParity;
            /// <summary>
            /// 0－无，1－软流控,2-硬流控
            /// </summary>
            public byte byFlowcontrol;
            /// <summary>
            /// 工作模式，0－窄带传输(232串口用于PPP拨号)，1－控制台(232串口用于参数控制)，2－透明通道
            /// </summary>
            public uint dwWorkMode;
            public NET_DVR_PPPCFG struPPPConfig;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PRESETCHAN_INFO
        {
            /// <summary>
            /// 启用预置点的通道
            /// </summary>
            public uint dwEnablePresetChan;
            /// <summary>
            /// 调用预置点通道对应的预置点序号, 0xfffffff表示不调用预置点。
            /// </summary>
            public uint dwPresetPointNo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CRUISECHAN_INFO
        {
            /// <summary>
            /// 启用巡航的通道
            /// </summary>
            public uint dwEnableCruiseChan;
            /// <summary>
            /// 巡航通道对应的巡航编号, 0xfffffff表示无效
            /// </summary>
            public uint dwCruiseNo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PTZTRACKCHAN_INFO
        {
            /// <summary>
            /// 启用花样扫描的通道
            /// </summary>
            public uint dwEnablePtzTrackChan;
            /// <summary>
            /// 花样扫描通道对应的编号, 0xfffffff表示无效
            /// </summary>
            public uint dwPtzTrackNo;
        }

        /// <summary>
        /// 报警输入参数配置(256路NVR扩展)
        /// </summary>
        //报警输入参数配置(256路NVR扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMINCFG_V40
        {
            public uint dwSize;
            /// <summary>
            /// 名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sAlarmInName;
            /// <summary>
            /// 报警器类型,0：常开,1：常闭
            /// </summary>
            public byte byAlarmType;
            /// <summary>
            /// 是否处理 0-不处理 1-处理
            /// </summary>
            public byte byAlarmInHandle;
            /// <summary>
            /// 报警输入触发智能识别通道
            /// </summary>
            public byte byChannel;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// 异常处理,异常处理方式的"或"结果
            /// </summary>
            public uint dwHandleType;
            /// <summary>
            /// 0x00: 无响应
            /// 0x01: 显示器上警告
            /// 0x02: 声音警告
            /// 0x04: 上传中心
            /// 0x08: 触发报警输出
            /// 0x10: 触发JPRG抓图并上传Email
            /// 0x20: 无线声光报警器联动
            /// 0x40: 联动电子地图(目前只有PCNVR支持)
            /// 0x200: 抓图并上传FTP
            /// </summary>
            public uint dwMaxRelAlarmOutChanNum;
            /// <summary>
            /// 触发的报警输出通道数 实际支持数
            /// </summary>
            public uint dwRelAlarmOutChanNum;
            /// <summary>
            /// 触发报警通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMOUT_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRelAlarmOut;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 触发的录像通道
            /// </summary>
            public uint dwMaxRecordChanNum;
            /// <summary>
            /// 当前实际已配置的关联录像通道数
            /// </summary>
            public uint dwCurRecordChanNum;
            /// <summary>
            /// 实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - dwCurRecordChanNum -1有效，如果中间遇到0xffffffff,则后续无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRelRecordChan;
            /// <summary>
            /// 最大可启用的云台控制总数(只读)
            /// </summary>
            public uint dwMaxEnablePtzCtrlNun;
            /// <summary>
            /// 当前已启用预置点的数目
            /// </summary>
            public uint dwEnablePresetChanNum;
            /// <summary>
            /// 启用的预置点信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_PRESETCHAN_INFO[] struPresetChanInfo;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 516, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 当前已启用巡航的通道数目
            /// </summary>
            public uint dwEnableCruiseChanNum;
            /// <summary>
            /// 启用巡航功能通道的信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CRUISECHAN_INFO[] struCruiseChanInfo;
            /// <summary>
            /// 当前已启用巡航的通道数目
            /// </summary>
            public uint dwEnablePtzTrackChanNum;
            /// <summary>
            /// 调用花样扫描的通道信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_PTZTRACKCHAN_INFO[] struPtzTrackInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 报警输入参数配置(9000扩展)
        /// </summary>
        //报警输入参数配置(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMINCFG_V30
        {
            public uint dwSize;
            /// <summary>
            /// 名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sAlarmInName;
            /// <summary>
            /// 报警器类型,0：常开,1：常闭
            /// </summary>
            public byte byAlarmType;
            /// <summary>
            /// 是否处理 0-不处理 1-处理
            /// </summary>
            public byte byAlarmInHandle;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 报警触发的录象通道,为1表示触发该通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
            /// <summary>
            /// 是否调用预置点 0-否,1-是
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byEnablePreset;
            /// <summary>
            /// 调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byPresetNo;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 192, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 是否调用巡航 0-否,1-是
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byEnableCruise;
            /// <summary>
            /// 巡航
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byCruiseNo;
            /// <summary>
            /// 是否调用 0-否,1-是
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byEnablePtzTrack;
            /// <summary>
            /// 调用的云台的序号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byPTZTrack;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct STRUCT_IO_ALARM
        {
            /// <summary>
            /// 发生报警的报警输入通道号，一次只有一个
            /// </summary>
            public uint dwAlarmInputNo;
            /// <summary>
            /// 触发的报警输出个数，用于后面计算变长数据部分中所有触发的报警输出通道号，四字节表示一个
            /// </summary>
            public uint dwTrigerAlarmOutNum;
            /// <summary>
            /// 触发的录像通道个数，用于后面计算变长数据部分中所有触发的录像通道号，四字节表示一个
            /// </summary>
            public uint dwTrigerRecordChanNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 116, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct STRUCT_ALARM_CHANNEL
        {
            /// <summary>
            /// 发生报警通道数据个数，用于后面计算变长数据部分中所有发生的报警通道号，四字节表示一个
            /// </summary>
            public uint dwAlarmChanNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 124, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct STRUCT_ALARM_HD
        {
            /// <summary>
            /// 发生报警的硬盘数据长度，用于后面计算变长数据部分中所有发生报警的硬盘号，四节表示一个
            /// </summary>
            public uint dwAlarmHardDiskNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 124, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayout(LayoutKind.Explicit)]
        public struct UNION_ALARMINFO_FIXED
        {
            [FieldOffset(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byUnionLen;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALRAM_FIXED_HEADER
        {
            /// <summary>
            /// 0-信号量报警,1-硬盘满,2-信号丢失，3－移动侦测，4－硬盘未格式化,5-写硬盘出错,6-遮挡报警，7-制式不匹配, 8-非法访问，9-视频信号异常，10-录像异常，11-智能场景变化，12-阵列异常，13-前端/录像分辨率不匹配
            /// </summary>
            public uint dwAlarmType;
            /// <summary>
            /// 发生报警的时间
            /// </summary>
            public NET_DVR_TIME_EX struAlarmTime;
            public UNION_ALARMINFO_FIXED uStruAlarm;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMINFO_V40
        {
            /// <summary>
            /// 报警固定部分
            /// </summary>
            public NET_DVR_ALRAM_FIXED_HEADER struAlarmFixedHeader;
            /// <summary>
            /// 报警可变部分内容
            /// </summary>
            public IntPtr pAlarmData;
        }

        /// <summary>
        /// 报警输入参数配置
        /// </summary>
        //报警输入参数配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMINCFG
        {
            public uint dwSize;
            /// <summary>
            /// 名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sAlarmInName;
            /// <summary>
            /// 报警器类型,0：常开,1：常闭
            /// </summary>
            public byte byAlarmType;
            /// <summary>
            /// 是否处理 0-不处理 1-处理
            /// </summary>
            public byte byAlarmInHandle;
            /// <summary>
            /// 报警输入触发智能识别通道
            /// </summary>
            public byte byChannel;
            public byte byRes;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION struAlarmHandleType;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 报警触发的录象通道,为1表示触发该通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
            /// <summary>
            /// 是否调用预置点 0-否,1-是
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byEnablePreset;
            /// <summary>
            /// 调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byPresetNo;
            /// <summary>
            /// 是否调用巡航 0-否,1-是
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byEnableCruise;
            /// <summary>
            /// 巡航
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byCruiseNo;
            /// <summary>
            /// 是否调用 0-否,1-是
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byEnablePtzTrack;
            /// <summary>
            /// 调用的云台的序号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byPTZTrack;
        }

        /// <summary>
        /// 模拟报警输入参数配置
        /// </summary>
        //模拟报警输入参数配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ANALOG_ALARMINCFG
        {
            public uint dwSize;
            /// <summary>
            /// 处理报警输入
            /// </summary>
            public byte byEnableAlarmHandle;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 模拟报警输入名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmInName;
            /// <summary>
            /// 模拟输入电压上限，实际值乘10，范围0~360
            /// </summary>
            public ushort wAlarmInUpper;
            /// <summary>
            /// 模拟输入电压下限，实际值乘10，范围0~360
            /// </summary>
            public ushort wAlarmInLower;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 被触发的录像通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 100, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 上传报警信息(9000扩展)
        /// </summary>
        //上传报警信息(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMINFO_V30
        {
            /// <summary>
            /// 0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 0xa-GPS定位信息(车载定制)
            /// </summary>
            public uint dwAlarmType;
            /// <summary>
            /// 报警输入端口
            /// </summary>
            public uint dwAlarmInputNumber;
            /// <summary>
            /// 触发的输出端口，为1表示对应输出
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMOUT_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmOutputNumber;
            /// <summary>
            /// 触发的录像通道，为1表示对应录像, dwAlarmRelateChannel[0]对应第1个通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmRelateChannel;
            /// <summary>
            /// dwAlarmType为2或3,6时，表示哪个通道，dwChannel[0]对应第1个通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byChannel;
            /// <summary>
            /// dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]对应第1个硬盘
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DISKNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byDiskNumber;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARM_HOT_SPARE
        {
            /// <summary>
            /// 结构体
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 报警原因   0-网络异常
            /// </summary>
            public uint dwExceptionCase;
            /// <summary>
            /// 产生异常的设备IP地址
            /// </summary>
            public NET_DVR_IPADDR struDeviceIP;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMINFO
        {
            /// <summary>
            /// 0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-串口状态, 0xa-GPS定位信息(车载定制)
            /// </summary>
            public int dwAlarmType;
            /// <summary>
            /// 报警输入端口, 当报警类型为9时该变量表示串口状态0表示正常， -1表示错误
            /// </summary>
            public int dwAlarmInputNumber;
            /// <summary>
            /// 触发的输出端口，哪一位为1表示对应哪一个输出
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMOUT, ArraySubType = UnmanagedType.U4)]
            public int[] dwAlarmOutputNumber;
            /// <summary>
            /// 触发的录像通道，哪一位为1表示对应哪一路录像, dwAlarmRelateChannel[0]对应第1个通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM, ArraySubType = UnmanagedType.U4)]
            public int[] dwAlarmRelateChannel;
            /// <summary>
            /// dwAlarmType为2或3,6时，表示哪个通道，dwChannel[0]位对应第1个通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM, ArraySubType = UnmanagedType.U4)]
            public int[] dwChannel;
            /// <summary>
            /// dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]位对应第1个硬盘
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DISKNUM, ArraySubType = UnmanagedType.U4)]
            public int[] dwDiskNumber;
        }

        /// <summary>
        /// IPC接入参数配置
        /// IP设备结构
        /// </summary>
        //////////////////////////////////////////////////////////////////////////////////////
        //IPC接入参数配置
        /* IP设备结构 */
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPDEVINFO
        {
            /// <summary>
            /// 该IP设备是否启用
            /// </summary>
            public uint dwEnable;
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDVRPort;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 34, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// ipc接入设备信息扩展，支持ip设备的域名添加
        /// </summary>
        //ipc接入设备信息扩展，支持ip设备的域名添加
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPDEVINFO_V31
        {
            /// <summary>
            /// 该IP设备是否有效
            /// </summary>
            public byte byEnable;
            public byte byProType;
            public byte byEnableQuickAdd;
            /// <summary>
            /// 保留字段，置0
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 设备域名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byDomain;
            /// <summary>
            /// IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDVRPort;
            /// <summary>
            /// 保留字段，置0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 34, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// IP通道匹配参数
        /// </summary>
        /* IP通道匹配参数 */
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPCHANINFO
        {
            /// <summary>
            /// 该通道是否在线
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// IP设备ID 取值1- MAX_IP_DEVICE
            /// </summary>
            public byte byIPID;
            /// <summary>
            /// 通道号
            /// </summary>
            public byte byChannel;
            /// <summary>
            /// IP设备ID的高8位
            /// </summary>
            public byte byIPIDHigh;
            /// <summary>
            /// 传输协议类型0-TCP/auto(具体有设备决定)，1-UDP 2-多播 3-仅TCP 4-auto
            /// </summary>
            public byte byTransProtocol;
            /// <summary>
            /// 保留,置0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 31, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// IP接入配置结构
        /// </summary>
        /* IP接入配置结构 */
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPPARACFG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// IP设备
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_DEVICE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPDEVINFO[] struIPDevInfo;
            /// <summary>
            /// 模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ANALOG_CHANNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byAnalogChanEnable;
            /// <summary>
            /// IP通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_CHANNEL, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPCHANINFO[] struIPChanInfo;
        }

        /// <summary>
        /// 扩展IP接入配置结构
        /// </summary>
        /* 扩展IP接入配置结构 */
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPPARACFG_V31
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// IP设备
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_DEVICE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPDEVINFO_V31[] struIPDevInfo;
            /// <summary>
            /// 模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ANALOG_CHANNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byAnalogChanEnable;
            /// <summary>
            /// IP通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_CHANNEL, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPCHANINFO[] struIPChanInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPSERVER_STREAM
        {
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public NET_DVR_IPADDR struIPServer;
            public ushort wPort;
            public ushort wDvrNameLen;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDVRName;
            public ushort wDVRSerialLen;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.U2)]
            public ushort[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SERIALNO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDVRSerialNumber;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byUserName;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPassWord;
            public byte byChannel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 流媒体服务器基本配置
        /// </summary>
        /*流媒体服务器基本配置*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_STREAM_MEDIA_SERVER_CFG
        {
            /// <summary>
            /// 是否启用流媒体服务器取流,0表示无效，非0表示有效
            /// </summary>
            public byte byValid;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public NET_DVR_IPADDR struDevIP;
            /// <summary>
            /// 流媒体服务器端口
            /// </summary>
            public ushort wDevPort;
            /// <summary>
            /// 传输协议类型 0-TCP，1-UDP
            /// </summary>
            public byte byTransmitType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 69, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 设备通道信息
        /// </summary>
        //设备通道信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEV_CHAN_INFO
        {
            /// <summary>
            /// DVR IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDVRPort;
            /// <summary>
            /// 通道号
            /// </summary>
            public byte byChannel;
            /// <summary>
            /// 传输协议类型0-TCP，1-UDP
            /// </summary>
            public byte byTransProtocol;
            /// <summary>
            /// 传输码流模式 0－主码流 1－子码流
            /// </summary>
            public byte byTransMode;
            /// <summary>
            /// 前端设备厂家类型,通过接口获取
            /// </summary>
            public byte byFactoryType;
            /// <summary>
            /// 设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
            /// </summary>
            public byte byDeviceType;
            /// <summary>
            /// 显示通道号,智能配置使用
            /// </summary>
            public byte byDispChan;
            /// <summary>
            /// 显示通道子通道号，智能配置时使用
            /// </summary>
            public byte bySubDispChan;
            /// <summary>
            /// ; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
            /// </summary>
            public byte byResolution;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 设备域名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byDomain;
            /// <summary>
            /// 布防主机登陆帐号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 布防主机密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PU_STREAM_CFG
        {
            public uint dwSize;
            public NET_DVR_STREAM_MEDIA_SERVER_CFG struStreamMediaSvrCfg;
            public NET_DVR_DEV_CHAN_INFO struDevChanInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DDNS_STREAM_CFG
        {
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public NET_DVR_IPADDR struStreamServer;
            public ushort wStreamServerPort;
            public byte byStreamServerTransmitType;
            public byte byRes2;
            public NET_DVR_IPADDR struIPServer;
            public ushort wIPServerPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sDVRName;
            public ushort wDVRNameLen;
            public ushort wDVRSerialLen;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SERIALNO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sDVRSerialNumber;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassWord;
            public ushort wDVRPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes4;
            public byte byChannel;
            public byte byTransProtocol;
            public byte byTransMode;
            public byte byFactoryType;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PU_STREAM_URL
        {
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 240, ArraySubType = UnmanagedType.I1)]
            public byte[] strURL;
            public byte byTransPortocol;
            public ushort wIPID;
            public byte byChannel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HKDDNS_STREAM
        {
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byDDNSDomain;
            public ushort wPort;
            public ushort wAliasLen;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlias;
            public ushort wDVRSerialLen;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SERIALNO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDVRSerialNumber;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byUserName;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPassWord;
            public byte byChannel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPCHANINFO_V40
        {
            /// <summary>
            /// 该通道是否在线
            /// </summary>
            public byte byEnable;
            public byte byRes1;
            /// <summary>
            /// IP设备ID
            /// </summary>
            public ushort wIPID;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 传输协议类型0-TCP，1-UDP
            /// </summary>
            public byte byTransProtocol;
            /// <summary>
            /// 传输码流模式 0－主码流 1－子码流
            /// </summary>
            public byte byTransMode;
            /// <summary>
            /// 前端设备厂家类型,通过接口获取
            /// </summary>
            public byte byFactoryType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 241, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayout(LayoutKind.Explicit)]
        public struct NET_DVR_GET_STREAM_UNION
        {
            [FieldOffset(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 492, ArraySubType = UnmanagedType.I1)]
            public byte[] byUnion;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_STREAM_MODE
        {
            /// <summary>
            /// 取流方式：0- 直接从设备取流；1- 从流媒体取流；2- 通过IPServer获得IP地址后取流；
            /// * 3- 通过IPServer找到设备，再通过流媒体取设备的流； 4- 通过流媒体由URL去取流；
            /// * 5- 通过hiDDNS域名连接设备然后从设备取流
            /// </summary>
            public byte byGetStreamType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public NET_DVR_GET_STREAM_UNION uGetStream;
        }

        /// <summary>
        /// V40扩展IP接入配置结构
        /// </summary>
        /* V40扩展IP接入配置结构 */
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPPARACFG_V40
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            public uint dwGroupNum;
            public uint dwAChanNum;
            public uint dwDChanNum;
            public uint dwStartDChan;
            /// <summary>
            /// 模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byAnalogChanEnable;
            /// <summary>
            /// IP设备
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_DEVICE_V40, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPDEVINFO_V31[] struIPDevInfo;
            /// <summary>
            /// IP通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_STREAM_MODE[] struStreamMode;
            /// <summary>
            /// 模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 为CVR扩展的报警类型
        /// </summary>
        //为CVR扩展的报警类型
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMINFO_DEV
        {
            /// <summary>
            /// 0-编码器(通道)信号量报警；1-私有卷二损坏；2- NVR服务退出；
            /// </summary>
            public uint dwAlarmType;
            /// <summary>
            /// 3-编码器状态异常；4-系统时钟异常；5-录像卷剩余容量过低；
            /// 6-编码器(通道)移动侦测报警；7-编码器(通道)遮挡报警。
            /// </summary>
            public NET_DVR_TIME struTime;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 数目
            /// </summary>
            public uint dwNumber;
            /// <summary>
            /// dwNumber个WORD; 每个WORD表示一个通道号，或者磁盘号, 无效时为0
            /// </summary>
            public IntPtr pNO;
        }

        /// <summary>
        /// 报警输出参数
        /// </summary>
        /* 报警输出参数 */
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPALARMOUTINFO
        {
            /// <summary>
            /// IP设备ID取值1- MAX_IP_DEVICE
            /// </summary>
            public byte byIPID;
            /// <summary>
            /// 报警输出号
            /// </summary>
            public byte byAlarmOut;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 18, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// IP报警输出配置结构
        /// </summary>
        /* IP报警输出配置结构 */
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPALARMOUTCFG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// IP报警输出
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_ALARMOUT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPALARMOUTINFO[] struIPAlarmOutInfo;
        }

        /// <summary>
        /// IP报警输出参数
        /// </summary>
        /* IP报警输出参数 */
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPALARMOUTINFO_V40
        {
            /// <summary>
            /// IP设备ID
            /// </summary>
            public uint dwIPID;
            /// <summary>
            /// IP设备ID对应的报警输出号
            /// </summary>
            public uint dwAlarmOut;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// IP报警输出
        /// </summary>
        /*IP报警输出*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPALARMOUTCFG_V40
        {
            /// <summary>
            /// 结构体长度
            /// </summary>
            public uint dwSize;
            public uint dwCurIPAlarmOutNum;
            /// <summary>
            /// IP报警输出
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_ALARMOUT_V40, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPALARMOUTINFO_V40[] struIPAlarmOutInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 报警输入参数
        /// </summary>
        /* 报警输入参数 */
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPALARMININFO
        {
            /// <summary>
            /// IP设备ID取值1- MAX_IP_DEVICE
            /// </summary>
            public byte byIPID;
            /// <summary>
            /// 报警输入号
            /// </summary>
            public byte byAlarmIn;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 18, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// IP报警输入配置结构
        /// </summary>
        /* IP报警输入配置结构 */
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPALARMINCFG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// IP报警输入
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_ALARMIN, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPALARMININFO[] struIPAlarmInInfo;
        }

        /// <summary>
        /// IP报警输入参数
        /// </summary>
        /* IP报警输入参数 */
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPALARMININFO_V40
        {
            /// <summary>
            /// IP设备ID
            /// </summary>
            public uint dwIPID;
            /// <summary>
            /// IP设备ID对应的报警输入号
            /// </summary>
            public uint dwAlarmIn;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// IP报警输入资源
        /// </summary>
        /*IP报警输入资源*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPALARMINCFG_V40
        {
            /// <summary>
            /// 结构体长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 当前报警输入口数
            /// </summary>
            public uint dwCurIPAlarmInNum;
            /// <summary>
            /// IP报警输入
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_ALARMIN_V40, ArraySubType = UnmanagedType.I1)]
            public NET_DVR_IPALARMININFO_V40[] struIPAlarmInInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// ipc alarm info
        /// </summary>
        //ipc alarm info
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPALARMINFO
        {
            /// <summary>
            /// IP设备
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_DEVICE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPDEVINFO[] struIPDevInfo;
            /// <summary>
            /// 模拟通道是否启用，0-未启用 1-启用
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ANALOG_CHANNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byAnalogChanEnable;
            /// <summary>
            /// IP通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_CHANNEL, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPCHANINFO[] struIPChanInfo;
            /// <summary>
            /// IP报警输入
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_ALARMIN, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPALARMININFO[] struIPAlarmInInfo;
            /// <summary>
            /// IP报警输出
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_ALARMOUT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPALARMOUTINFO[] struIPAlarmOutInfo;
        }

        /// <summary>
        /// ipc配置改变报警信息扩展 9000_1.1
        /// </summary>
        //ipc配置改变报警信息扩展 9000_1.1
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPALARMINFO_V31
        {
            /// <summary>
            /// IP设备
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_DEVICE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPDEVINFO_V31[] struIPDevInfo;
            /// <summary>
            /// 模拟通道是否启用，0-未启用 1-启用
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ANALOG_CHANNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byAnalogChanEnable;
            /// <summary>
            /// IP通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_CHANNEL, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPCHANINFO[] struIPChanInfo;
            /// <summary>
            /// IP报警输入
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_ALARMIN, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPALARMININFO[] struIPAlarmInInfo;
            /// <summary>
            /// IP报警输出
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_ALARMOUT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPALARMOUTINFO[] struIPAlarmOutInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPALARMINFO_V40
        {
            /// <summary>
            /// IP设备
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_DEVICE_V40, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPDEVINFO_V31[] struIPDevInfo;
            /// <summary>
            /// 模拟通道是否启用，0-未启用 1-启用
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byAnalogChanEnable;
            /// <summary>
            /// IP通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPCHANINFO[] struIPChanInfo;
            /// <summary>
            /// IP报警输入
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_ALARMIN, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPALARMININFO[] struIPAlarmInInfo;
            /// <summary>
            /// IP报警输出
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IP_ALARMOUT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPALARMOUTINFO[] struIPAlarmOutInfo;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        public enum HD_STAT
        {
            /// <summary>
            /// 正常
            /// </summary>
            HD_STAT_OK = 0,
            /// <summary>
            /// 未格式化
            /// </summary>
            HD_STAT_UNFORMATTED = 1,
            /// <summary>
            /// 错误
            /// </summary>
            HD_STAT_ERROR = 2,
            /// <summary>
            /// SMART状态
            /// </summary>
            HD_STAT_SMART_FAILED = 3,
            /// <summary>
            /// 不匹配
            /// </summary>
            HD_STAT_MISMATCH = 4,
            /// <summary>
            /// 休眠
            /// </summary>
            HD_STAT_IDLE = 5,
            /// <summary>
            /// 网络盘处于未连接状态
            /// </summary>
            NET_HD_STAT_OFFLINE = 6,
            /// <summary>
            /// 虚拟磁盘可扩容
            /// </summary>
            HD_RIADVD_EXPAND = 7,
            /// <summary>
            /// 硬盘正在修复(9000 2.0)
            /// </summary>
            HD_STAT_REPARING = 10,
            /// <summary>
            /// 硬盘正在格式化(9000 2.0)
            /// </summary>
            HD_STAT_FORMATING = 11
        }

        /// <summary>
        /// 本地硬盘信息配置
        /// </summary>
        //本地硬盘信息配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SINGLE_HD
        {
            /// <summary>
            /// 硬盘号, 取值0~MAX_DISKNUM_V30-1
            /// </summary>
            public uint dwHDNo;
            /// <summary>
            /// 硬盘容量(不可设置)
            /// </summary>
            public uint dwCapacity;
            /// <summary>
            /// 硬盘剩余空间(不可设置)
            /// </summary>
            public uint dwFreeSpace;
            /// <summary>
            /// 硬盘状态(不可设置) HD_STAT
            /// </summary>
            public uint dwHdStatus;
            /// <summary>
            /// 0-默认, 1-冗余; 2-只读
            /// </summary>
            public byte byHDAttr;
            /// <summary>
            /// 0-本地硬盘,1-ESATA硬盘,2-NAS硬盘
            /// </summary>
            public byte byHDType;
            /// <summary>
            /// 值 代表其ASCII字符
            /// </summary>
            public byte byDiskDriver;
            public byte byRes1;
            /// <summary>
            /// 属于哪个盘组 1-MAX_HD_GROUP
            /// </summary>
            public uint dwHdGroup;
            /// <summary>
            /// 是否循环利用 0：不循环利用，1：循环利用
            /// </summary>
            public byte byRecycling;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 按位表示 0-不支持 非0-支持
            /// </summary>
            public uint dwStorageType;
            /// <summary>
            /// dwStorageType & 0x1 表示是否是普通录像专用存储盘
            /// dwStorageType & 0x2  表示是否是抽帧录像专用存储盘
            /// dwStorageType & 0x4 表示是否是图片录像专用存储盘
            /// </summary>
            public uint dwPictureCapacity;
            /// <summary>
            /// 剩余图片空间(不可设置)，单位:MB
            /// </summary>
            public uint dwFreePictureSpace;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 104, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HDCFG
        {
            public uint dwSize;
            /// <summary>
            /// 硬盘数(不可设置)
            /// </summary>
            public uint dwHDCount;
            /// <summary>
            /// 硬盘相关操作都需要重启才能生效；
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DISKNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SINGLE_HD[] struHDInfo;
        }

        /// <summary>
        /// 本地盘组信息配置扩展
        /// </summary>
        //本地盘组信息配置扩展
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SINGLE_HDGROUP_V40
        {
            /// <summary>
            /// 盘组号(不可设置) 1-MAX_HD_GROUP
            /// </summary>
            public uint dwHDGroupNo;
            /// <summary>
            /// 触发的录像通道，按值表示，遇到0xffffffff时后续视为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRelRecordChan;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HDGROUP_CFG_V40
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 设备支持的最大盘组数-只读
            /// </summary>
            public uint dwMaxHDGroupNum;
            /// <summary>
            /// 当前配置的盘组数
            /// </summary>
            public uint dwCurHDGroupNum;
            /// <summary>
            /// 硬盘相关操作都需要重启才能生效；
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_HD_GROUP, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SINGLE_HDGROUP_V40[] struHDGroupAttr;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 本地盘组信息配置
        /// </summary>
        //本地盘组信息配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SINGLE_HDGROUP
        {
            /// <summary>
            /// 盘组号(不可设置) 1-MAX_HD_GROUP
            /// </summary>
            public uint dwHDGroupNo;
            /// <summary>
            /// 盘组对应的录像通道, 0-表示该通道不录象到该盘组，1-表示录象到该盘组
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byHDGroupChans;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HDGROUP_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 盘组总数(不可设置)
            /// </summary>
            public uint dwHDGroupCount;
            /// <summary>
            /// 硬盘相关操作都需要重启才能生效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_HD_GROUP, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SINGLE_HDGROUP[] struHDGroupAttr;
        }

        /// <summary>
        /// 配置缩放参数的结构
        /// </summary>
        //配置缩放参数的结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCALECFG
        {
            public uint dwSize;
            /// <summary>
            /// 主显示 0-不缩放，1-缩放
            /// </summary>
            public uint dwMajorScale;
            /// <summary>
            /// 辅显示 0-不缩放，1-缩放
            /// </summary>
            public uint dwMinorScale;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRes;
        }

        /// <summary>
        /// DVR报警输出(9000扩展)
        /// </summary>
        //DVR报警输出(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMOUTCFG_V30
        {
            public uint dwSize;
            /// <summary>
            /// 名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sAlarmOutName;
            /// <summary>
            /// 输出保持时间(-1为无限，手动关闭)
            /// </summary>
            public uint dwAlarmOutDelay;
            /// <summary>
            /// 0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmOutTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// DVR报警输出
        /// </summary>
        //DVR报警输出
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMOUTCFG
        {
            public uint dwSize;
            /// <summary>
            /// 名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sAlarmOutName;
            /// <summary>
            /// 输出保持时间(-1为无限，手动关闭)
            /// </summary>
            public uint dwAlarmOutDelay;
            /// <summary>
            /// 0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmOutTime;
        }

        /// <summary>
        /// DVR本地预览参数(9000扩展)
        /// </summary>
        //DVR本地预览参数(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PREVIEWCFG_V30
        {
            public uint dwSize;
            /// <summary>
            /// 预览数目,0-1画面,1-4画面,2-9画面,3-16画面,0xff:最大画面
            /// </summary>
            public byte byPreviewNumber;
            /// <summary>
            /// 是否声音预览,0-不预览,1-预览
            /// </summary>
            public byte byEnableAudio;
            /// <summary>
            /// 切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
            /// </summary>
            public ushort wSwitchTime;
            /// <summary>
            /// 切换顺序,如果lSwitchSeq[i]为 0xff表示不用
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_PREVIEW_MODE * MAX_WINDOW_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] bySwitchSeq;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// DVR本地预览参数
        /// </summary>
        //DVR本地预览参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PREVIEWCFG
        {
            public uint dwSize;
            /// <summary>
            /// 预览数目,0-1画面,1-4画面,2-9画面,3-16画面,0xff:最大画面
            /// </summary>
            public byte byPreviewNumber;
            /// <summary>
            /// 是否声音预览,0-不预览,1-预览
            /// </summary>
            public byte byEnableAudio;
            /// <summary>
            /// 切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
            /// </summary>
            public ushort wSwitchTime;
            /// <summary>
            /// 切换顺序,如果lSwitchSeq[i]为 0xff表示不用
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOW, ArraySubType = UnmanagedType.I1)]
            public byte[] bySwitchSeq;
        }

        /// <summary>
        /// DVR视频输出
        /// </summary>
        //DVR视频输出
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VGAPARA
        {
            /// <summary>
            /// 分辨率
            /// </summary>
            public ushort wResolution;
            /// <summary>
            /// 刷新频率
            /// </summary>
            public ushort wFreq;
            /// <summary>
            /// 亮度
            /// </summary>
            public uint dwBrightness;
        }

        /// <summary>
        /// MATRIX输出参数结构
        /// </summary>
        //MATRIX输出参数结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIXPARA_V30
        {
            /// <summary>
            /// 预览顺序, 0xff表示相应的窗口不预览
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ANALOG_CHANNUM, ArraySubType = UnmanagedType.U2)]
            public ushort[] wOrder;
            /// <summary>
            /// 预览切换时间
            /// </summary>
            public ushort wSwitchTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 14, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIXPARA
        {
            /// <summary>
            /// 显示视频通道号
            /// </summary>
            public ushort wDisplayLogo;
            /// <summary>
            /// 显示时间
            /// </summary>
            public ushort wDisplayOsd;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VOOUT
        {
            /// <summary>
            /// 输出制式,0-PAL,1-NTSC
            /// </summary>
            public byte byVideoFormat;
            /// <summary>
            /// 菜单与背景图象对比度
            /// </summary>
            public byte byMenuAlphaValue;
            /// <summary>
            /// 屏幕保护时间 0-从不,1-1分钟,2-2分钟,3-5分钟,4-10分钟,5-20分钟,6-30分钟
            /// </summary>
            public ushort wScreenSaveTime;
            /// <summary>
            /// 视频输出偏移
            /// </summary>
            public ushort wVOffset;
            /// <summary>
            /// 视频输出亮度
            /// </summary>
            public ushort wBrightness;
            /// <summary>
            /// 启动后视频输出模式(0:菜单,1:预览)
            /// </summary>
            public byte byStartMode;
            /// <summary>
            /// 是否启动缩放 (0-不启动, 1-启动)
            /// </summary>
            public byte byEnableScaler;
        }

        /// <summary>
        /// DVR视频输出(9000扩展)
        /// </summary>
        //DVR视频输出(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VIDEOOUT_V30
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_VIDEOOUT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_VOOUT[] struVOOut;
            /// <summary>
            /// VGA参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_VGA_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_VGAPARA[] struVGAPara;
            /// <summary>
            /// MATRIX参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_MATRIXOUT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_MATRIXPARA_V30[] struMatrixPara;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// DVR视频输出
        /// </summary>
        //DVR视频输出
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VIDEOOUT
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_VIDEOOUT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_VOOUT[] struVOOut;
            /// <summary>
            /// VGA参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_VGA, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_VGAPARA[] struVGAPara;
            /// <summary>
            /// MATRIX参数
            /// </summary>
            public NET_DVR_MATRIXPARA struMatrixPara;
        }

        /// <summary>
        /// 单用户参数(子结构)(扩展)
        /// </summary>
        //单用户参数(子结构)(扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_USER_INFO_V40
        {
            /// <summary>
            /// 用户名只能用16字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 本地权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RIGHT, ArraySubType = UnmanagedType.I1)]
            public byte[] byLocalRight;
            /// <summary>
            /// 数组0: 本地控制云台
            /// 数组1: 本地手动录象
            /// 数组2: 本地回放
            /// 数组3: 本地设置参数
            /// 数组4: 本地查看状态、日志
            /// 数组5: 本地高级操作(升级，格式化，重启，关机)
            /// 数组6: 本地查看参数
            /// 数组7: 本地管理模拟和IP camera
            /// 数组8: 本地备份
            /// 数组9: 本地关机/重启
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RIGHT, ArraySubType = UnmanagedType.I1)]
            public byte[] byRemoteRight;
            /// <summary>
            /// 数组0: 远程控制云台
            /// 数组1: 远程手动录象
            /// 数组2: 远程回放
            /// 数组3: 远程设置参数
            /// 数组4: 远程查看状态、日志
            /// 数组5: 远程高级操作(升级，格式化，重启，关机)
            /// 数组6: 远程发起语音对讲
            /// 数组7: 远程预览
            /// 数组8: 远程请求报警上传、报警输出
            /// 数组9: 远程控制，本地输出
            /// 数组10: 远程控制串口
            /// 数组11: 远程查看参数
            /// 数组12: 远程管理模拟和IP camera
            /// 数组13: 远程关机/重启
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwNetPreviewRight;
            /// <summary>
            /// 本地可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwLocalRecordRight;
            /// <summary>
            /// 远程可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwNetRecordRight;
            /// <summary>
            /// 本地可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwLocalPlaybackRight;
            /// <summary>
            /// 远程可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwNetPlaybackRight;
            /// <summary>
            /// 本地可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwLocalPTZRight;
            /// <summary>
            /// 远程可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwNetPTZRight;
            /// <summary>
            /// 本地备份权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwLocalBackupRight;
            /// <summary>
            /// 用户IP地址(为0时表示允许任何地址)
            /// </summary>
            public NET_DVR_IPADDR struUserIP;
            /// <summary>
            /// 物理地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMACAddr;
            /// <summary>
            /// 优先级，0xff-无，0--低，1--中，2--高
            /// </summary>
            public byte byPriority;
            /// <summary>
            /// 无……表示不支持优先级的设置
            /// 低……默认权限:包括本地和远程回放,本地和远程查看日志和状态,本地和远程关机/重启
            /// 中……包括本地和远程控制云台,本地和远程手动录像,本地和远程回放,语音对讲和远程预览、本地备份,本地/远程关机/重启
            /// 高……管理员
            /// </summary>
            public byte byAlarmOnRight;
            /// <summary>
            /// 报警输入口撤防权限 1-有权限，0-无权限
            /// </summary>
            public byte byAlarmOffRight;
            /// <summary>
            /// 报警输入口旁路权限 1-有权限，0-无权限
            /// </summary>
            public byte byBypassRight;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 118, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 单用户参数(子结构)(9000扩展)
        /// </summary>
        //单用户参数(子结构)(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_USER_INFO_V30
        {
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 本地权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RIGHT, ArraySubType = UnmanagedType.I1)]
            public byte[] byLocalRight;
            /// <summary>
            /// 数组0: 本地控制云台
            /// 数组1: 本地手动录象
            /// 数组2: 本地回放
            /// 数组3: 本地设置参数
            /// 数组4: 本地查看状态、日志
            /// 数组5: 本地高级操作(升级，格式化，重启，关机)
            /// 数组6: 本地查看参数
            /// 数组7: 本地管理模拟和IP camera
            /// 数组8: 本地备份
            /// 数组9: 本地关机/重启
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RIGHT, ArraySubType = UnmanagedType.I1)]
            public byte[] byRemoteRight;
            /// <summary>
            /// 数组0: 远程控制云台
            /// 数组1: 远程手动录象
            /// 数组2: 远程回放
            /// 数组3: 远程设置参数
            /// 数组4: 远程查看状态、日志
            /// 数组5: 远程高级操作(升级，格式化，重启，关机)
            /// 数组6: 远程发起语音对讲
            /// 数组7: 远程预览
            /// 数组8: 远程请求报警上传、报警输出
            /// 数组9: 远程控制，本地输出
            /// 数组10: 远程控制串口
            /// 数组11: 远程查看参数
            /// 数组12: 远程管理模拟和IP camera
            /// 数组13: 远程关机/重启
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byNetPreviewRight;
            /// <summary>
            /// 本地可以回放的通道 0-有权限，1-无权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byLocalPlaybackRight;
            /// <summary>
            /// 远程可以回放的通道 0-有权限，1-无权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byNetPlaybackRight;
            /// <summary>
            /// 本地可以录像的通道 0-有权限，1-无权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byLocalRecordRight;
            /// <summary>
            /// 远程可以录像的通道 0-有权限，1-无权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byNetRecordRight;
            /// <summary>
            /// 本地可以PTZ的通道 0-有权限，1-无权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byLocalPTZRight;
            /// <summary>
            /// 远程可以PTZ的通道 0-有权限，1-无权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byNetPTZRight;
            /// <summary>
            /// 本地备份权限通道 0-有权限，1-无权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byLocalBackupRight;
            /// <summary>
            /// 用户IP地址(为0时表示允许任何地址)
            /// </summary>
            public NET_DVR_IPADDR struUserIP;
            /// <summary>
            /// 物理地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMACAddr;
            /// <summary>
            /// 优先级，0xff-无，0--低，1--中，2--高
            /// </summary>
            public byte byPriority;
            /// <summary>
            /// 无……表示不支持优先级的设置
            /// 低……默认权限:包括本地和远程回放,本地和远程查看日志和状态,本地和远程关机/重启
            /// 中……包括本地和远程控制云台,本地和远程手动录像,本地和远程回放,语音对讲和远程预览
            /// 本地备份,本地/远程关机/重启
            /// 高……管理员
            /// </summary>
            public byte byAlarmOnRight;
            /// <summary>
            /// 报警输入口撤防权限
            /// </summary>
            public byte byAlarmOffRight;
            /// <summary>
            /// 报警输入口旁路权限
            /// </summary>
            public byte byBypassRight;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 14, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 单用户参数(SDK_V15扩展)(子结构)
        /// </summary>
        //单用户参数(SDK_V15扩展)(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_USER_INFO_EX
        {
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RIGHT, ArraySubType = UnmanagedType.U4)]
            public uint[] dwLocalRight;
            /// <summary>
            /// 数组0: 本地控制云台
            /// 数组1: 本地手动录象
            /// 数组2: 本地回放
            /// 数组3: 本地设置参数
            /// 数组4: 本地查看状态、日志
            /// 数组5: 本地高级操作(升级，格式化，重启，关机)
            /// </summary>
            public uint dwLocalPlaybackRight;
            /// <summary>
            /// 权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RIGHT, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRemoteRight;
            /// <summary>
            /// 数组0: 远程控制云台
            /// 数组1: 远程手动录象
            /// 数组2: 远程回放
            /// 数组3: 远程设置参数
            /// 数组4: 远程查看状态、日志
            /// 数组5: 远程高级操作(升级，格式化，重启，关机)
            /// 数组6: 远程发起语音对讲
            /// 数组7: 远程预览
            /// 数组8: 远程请求报警上传、报警输出
            /// 数组9: 远程控制，本地输出
            /// 数组10: 远程控制串口
            /// </summary>
            public uint dwNetPreviewRight;
            /// <summary>
            /// 远程可以回放的通道 bit0 -- channel 1
            /// </summary>
            public uint dwNetPlaybackRight;
            /// <summary>
            /// 用户IP地址(为0时表示允许任何地址)
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sUserIP;
            /// <summary>
            /// 物理地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMACAddr;
        }

        /// <summary>
        /// 单用户参数(子结构)
        /// </summary>
        //单用户参数(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_USER_INFO
        {
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RIGHT, ArraySubType = UnmanagedType.U4)]
            public uint[] dwLocalRight;
            /// <summary>
            /// 数组0: 本地控制云台
            /// 数组1: 本地手动录象
            /// 数组2: 本地回放
            /// 数组3: 本地设置参数
            /// 数组4: 本地查看状态、日志
            /// 数组5: 本地高级操作(升级，格式化，重启，关机)
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RIGHT, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRemoteRight;
            /// <summary>
            /// 数组0: 远程控制云台
            /// 数组1: 远程手动录象
            /// 数组2: 远程回放
            /// 数组3: 远程设置参数
            /// 数组4: 远程查看状态、日志
            /// 数组5: 远程高级操作(升级，格式化，重启，关机)
            /// 数组6: 远程发起语音对讲
            /// 数组7: 远程预览
            /// 数组8: 远程请求报警上传、报警输出
            /// 数组9: 远程控制，本地输出
            /// 数组10: 远程控制串口
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sUserIP;
            /// <summary>
            /// 物理地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMACAddr;
        }

        /// <summary>
        /// 单用户参数(子结构)(扩展)
        /// </summary>
        //单用户参数(子结构)(扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_USER_INFO_V51
        {
            /// <summary>
            /// 用户名只能用16字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 本地权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RIGHT, ArraySubType = UnmanagedType.I1)]
            public byte[] byLocalRight;
            /// <summary>
            /// 远程权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RIGHT, ArraySubType = UnmanagedType.I1)]
            public byte[] byRemoteRight;
            /// <summary>
            /// 远程可以预览的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwNetPreviewRight;
            /// <summary>
            /// 本地可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwLocalRecordRight;
            /// <summary>
            /// 远程可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwNetRecordRight;
            /// <summary>
            /// 本地可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwLocalPlaybackRight;
            /// <summary>
            /// 远程可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwNetPlaybackRight;
            /// <summary>
            /// 本地可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwLocalPTZRight;
            /// <summary>
            /// 远程可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwNetPTZRight;
            /// <summary>
            /// 本地备份权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwLocalBackupRight;
            /// <summary>
            /// 本地预览权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwLocalPreviewRight;
            /// <summary>
            /// 用户IP地址(为0时表示允许任何地址)
            /// </summary>
            public NET_DVR_IPADDR struUserIP;
            /// <summary>
            /// 物理地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMACAddr;
            /// <summary>
            /// 优先级，0xff-无，0--低，1--中，2--高
            /// </summary>
            public byte byPriority;
            /// <summary>
            /// 报警输入口布防权限 1-有权限，0-无权限
            /// </summary>
            public byte byAlarmOnRight;
            /// <summary>
            /// 报警输入口撤防权限 1-有权限，0-无权限
            /// </summary>
            public byte byAlarmOffRight;
            /// <summary>
            /// 报警输入口旁路权限 1-有权限，0-无权限
            /// </summary>
            public byte byBypassRight;
            /// <summary>
            /// 四字节对齐
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 信息发布专有权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RIGHT, ArraySubType = UnmanagedType.I1)]
            public byte[] byPublishRight;
            /// <summary>
            /// 密码有效期,仅管理员用户可以修改,单位：天，填0表示永久生效
            /// </summary>
            public uint dwPasswordValidity;
            /// <summary>
            /// 键盘密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byKeypadPassword;
            /// <summary>
            /// 用户操作类型，1-网络用户，2-键盘用户，3-网络用户+键盘用户
            /// </summary>
            public byte byUserOperateType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 1007, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_USER_V51
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 设备支持的最大用户数-只读
            /// </summary>
            public uint dwMaxUserNum;
            /// <summary>
            /// 用户参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_USERNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_USER_INFO_V51[] struUser;
            /// <summary>
            /// 登陆密码确认
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sloginPassword;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 240, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// DVR用户参数(扩展)
        /// </summary>
        //DVR用户参数(扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_USER_V40
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 设备支持的最大用户数-只读
            /// </summary>
            public uint dwMaxUserNum;
            /// <summary>
            /// 用户参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_USERNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_USER_INFO_V40[] struUser;
        }

        /// <summary>
        /// DVR用户参数(9000扩展)
        /// </summary>
        //DVR用户参数(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_USER_V30
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_USERNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_USER_INFO_V30[] struUser;
        }

        /// <summary>
        /// DVR用户参数(SDK_V15扩展)
        /// </summary>
        //DVR用户参数(SDK_V15扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_USER_EX
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_USERNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_USER_INFO_EX[] struUser;
        }

        /// <summary>
        /// DVR用户参数
        /// </summary>
        //DVR用户参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_USER
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_USERNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_USER_INFO[] struUser;
        }

        /// <summary>
        /// 异常参数配置扩展结构体
        /// </summary>
        //异常参数配置扩展结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_EXCEPTION_V40
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 设备支持的最大组数
            /// </summary>
            public uint dwMaxGroupNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_EXCEPTIONNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_HANDLEEXCEPTION_V41[] struExceptionHandle;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// DVR异常参数(9000扩展)
        /// </summary>
        //DVR异常参数(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_EXCEPTION_V30
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_EXCEPTIONNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_HANDLEEXCEPTION_V30[] struExceptionHandleType;
        }

        /// <summary>
        /// DVR异常参数
        /// </summary>
        //DVR异常参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_EXCEPTION
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_EXCEPTIONNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_HANDLEEXCEPTION[] struExceptionHandleType;
        }

        /// <summary>
        /// 通道状态(9000扩展)
        /// </summary>
        //通道状态(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CHANNELSTATE_V30
        {
            /// <summary>
            /// 通道是否在录像,0-不录像,1-录像
            /// </summary>
            public byte byRecordStatic;
            /// <summary>
            /// 连接的信号状态,0-正常,1-信号丢失
            /// </summary>
            public byte bySignalStatic;
            /// <summary>
            /// 通道硬件状态,0-正常,1-异常,例如DSP死掉
            /// </summary>
            public byte byHardwareStatic;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// 实际码率
            /// </summary>
            public uint dwBitRate;
            /// <summary>
            /// 客户端连接的个数
            /// </summary>
            public uint dwLinkNum;
            /// <summary>
            /// 客户端的IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LINK, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPADDR[] struClientIP;
            /// <summary>
            /// 如果该通道为IP接入，那么表示IP接入当前的连接数
            /// </summary>
            public uint dwIPLinkNum;
            /// <summary>
            /// 是否超出了单路6路连接数 0 - 未超出, 1-超出
            /// </summary>
            public byte byExceedMaxLink;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 当前的通道号，0xffffffff表示无效
            /// </summary>
            public uint dwChannelNo;
        }

        /// <summary>
        /// 通道状态
        /// </summary>
        //通道状态
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CHANNELSTATE
        {
            /// <summary>
            /// 通道是否在录像,0-不录像,1-录像
            /// </summary>
            public byte byRecordStatic;
            /// <summary>
            /// 连接的信号状态,0-正常,1-信号丢失
            /// </summary>
            public byte bySignalStatic;
            /// <summary>
            /// 通道硬件状态,0-正常,1-异常,例如DSP死掉
            /// </summary>
            public byte byHardwareStatic;
            /// <summary>
            /// 保留
            /// </summary>
            public byte reservedData;
            /// <summary>
            /// 实际码率
            /// </summary>
            public uint dwBitRate;
            /// <summary>
            /// 客户端连接的个数
            /// </summary>
            public uint dwLinkNum;
            /// <summary>
            /// 客户端的IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LINK, ArraySubType = UnmanagedType.U4)]
            public uint[] dwClientIP;
        }

        /// <summary>
        /// 硬盘状态
        /// </summary>
        //硬盘状态
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISKSTATE
        {
            /// <summary>
            /// 硬盘的容量
            /// </summary>
            public uint dwVolume;
            /// <summary>
            /// 硬盘的剩余空间
            /// </summary>
            public uint dwFreeSpace;
            /// <summary>
            /// 硬盘的状态,0-活动,1-休眠,2-不正常
            /// </summary>
            public uint dwHardDiskStatic;
        }

        /// <summary>
        /// 设备工作状态扩展结构体
        /// </summary>
        //设备工作状态扩展结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WORKSTATE_V40
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
            /// </summary>
            public uint dwDeviceStatic;
            /// <summary>
            /// 硬盘状态,一次最多只能获取33个硬盘信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DISKNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_DISKSTATE[] struHardDiskStatic;
            /// <summary>
            /// 通道的状态，从前往后顺序排列
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CHANNELSTATE_V30[] struChanStatic;
            /// <summary>
            /// 有报警的报警输入口，按值表示，按下标值顺序排列，值为0xffffffff时当前及后续值无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMIN_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwHasAlarmInStatic;
            /// <summary>
            /// 有报警输出的报警输出口，按值表示，按下标值顺序排列，值为0xffffffff时当前及后续值无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMOUT_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwHasAlarmOutStatic;
            /// <summary>
            /// 本地显示状态,0-正常,1-不正常
            /// </summary>
            public uint dwLocalDisplay;
            /// <summary>
            /// 按位表示语音通道的状态 0-未使用，1-使用中，第0位表示第1个语音通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_AUDIO_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byAudioInChanStatus;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 126, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_GETWORKSTATE_COND
        {
            /// <summary>
            /// 结构体长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 0-查找全部磁盘(但一次最多只能查找33个)，此时dwFindHardStatusNum无效
            /// </summary>
            public byte byFindHardByCond;
            /// <summary>
            /// 0-查找全部通道，此时dwFindChanNum无效
            /// </summary>
            public byte byFindChanByCond;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 要查找的硬盘号，按值表示，该值采用顺序排列， 遇到0xffffffff则认为后续无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DISKNUM_V30, ArraySubType = UnmanagedType.U4)]
            public uint[] dwFindHardStatus;
            /// <summary>
            /// 要查找的通道号，按值表示，该值采用顺序排列， 遇到0xffffffff则认为后续无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwFindChanNo;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// DVR工作状态(9000扩展)
        /// </summary>
        //DVR工作状态(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WORKSTATE_V30
        {
            /// <summary>
            /// 设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
            /// </summary>
            public uint dwDeviceStatic;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DISKNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_DISKSTATE[] struHardDiskStatic;
            /// <summary>
            /// 通道的状态
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CHANNELSTATE_V30[] struChanStatic;
            /// <summary>
            /// 报警端口的状态,0-没有报警,1-有报警
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMIN_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmInStatic;
            /// <summary>
            /// 报警输出端口的状态,0-没有输出,1-有报警输出
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMOUT_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmOutStatic;
            /// <summary>
            /// 本地显示状态,0-正常,1-不正常
            /// </summary>
            public uint dwLocalDisplay;
            /// <summary>
            /// 表示语音通道的状态 0-未使用，1-使用中, 0xff无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_AUDIO_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byAudioChanStatus;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 10, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// DVR工作状态
        /// </summary>
        //DVR工作状态
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WORKSTATE
        {
            /// <summary>
            /// 设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
            /// </summary>
            public uint dwDeviceStatic;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DISKNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_DISKSTATE[] struHardDiskStatic;
            /// <summary>
            /// 通道的状态
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CHANNELSTATE[] struChanStatic;
            /// <summary>
            /// 报警端口的状态,0-没有报警,1-有报警
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMIN, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmInStatic;
            /// <summary>
            /// 报警输出端口的状态,0-没有输出,1-有报警输出
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMOUT, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmOutStatic;
            /// <summary>
            /// 本地显示状态,0-正常,1-不正常
            /// </summary>
            public uint dwLocalDisplay;
        }

        /// <summary>
        /// 日志信息(9000扩展)
        /// </summary>
        //日志信息(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_LOG_V30
        {
            public NET_DVR_TIME strLogTime;
            /// <summary>
            /// 主类型 1-报警; 2-异常; 3-操作; 0xff-全部
            /// </summary>
            public uint dwMajorType;
            /// <summary>
            /// 次类型 0-全部;
            /// </summary>
            public uint dwMinorType;
            /// <summary>
            /// 操作面板的用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NAMELEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPanelUser;
            /// <summary>
            /// 网络操作的用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NAMELEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sNetUser;
            /// <summary>
            /// 远程主机地址
            /// </summary>
            public NET_DVR_IPADDR struRemoteHostAddr;
            /// <summary>
            /// 参数类型
            /// </summary>
            public uint dwParaType;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 硬盘号
            /// </summary>
            public uint dwDiskNumber;
            /// <summary>
            /// 报警输入端口
            /// </summary>
            public uint dwAlarmInPort;
            /// <summary>
            /// 报警输出端口
            /// </summary>
            public uint dwAlarmOutPort;
            public uint dwInfoLen;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = LOG_INFO_LEN)]
            public string sInfo;
        }

        /// <summary>
        /// 日志信息
        /// </summary>
        //日志信息
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_LOG
        {
            public NET_DVR_TIME strLogTime;
            /// <summary>
            /// 主类型 1-报警; 2-异常; 3-操作; 0xff-全部
            /// </summary>
            public uint dwMajorType;
            /// <summary>
            /// 次类型 0-全部;
            /// </summary>
            public uint dwMinorType;
            /// <summary>
            /// 操作面板的用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NAMELEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPanelUser;
            /// <summary>
            /// 网络操作的用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NAMELEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sNetUser;
            /// <summary>
            /// 远程主机地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sRemoteHostAddr;
            /// <summary>
            /// 参数类型
            /// </summary>
            public uint dwParaType;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 硬盘号
            /// </summary>
            public uint dwDiskNumber;
            /// <summary>
            /// 报警输入端口
            /// </summary>
            public uint dwAlarmInPort;
            /// <summary>
            /// 报警输出端口
            /// </summary>
            public uint dwAlarmOutPort;
        }

        /// <summary>
        /// **********************动环报警管理主机日志查找 begin***********************************************
        /// </summary>
        /************************动环报警管理主机日志查找 begin************************************************/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMHOST_SEARCH_LOG_PARAM
        {
            /// <summary>
            /// 主类型
            /// </summary>
            public ushort wMajorType;
            /// <summary>
            /// 次类型
            /// </summary>
            public ushort wMinorType;
            /// <summary>
            /// 开始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 结束时间
            /// </summary>
            public NET_DVR_TIME struEndTime;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMHOST_LOG_RET
        {
            /// <summary>
            /// 日志时间
            /// </summary>
            public NET_DVR_TIME struLogTime;
            /// <summary>
            /// 操作用户
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 操作IP地址
            /// </summary>
            public NET_DVR_IPADDR struIPAddr;
            /// <summary>
            /// 主类型
            /// </summary>
            public ushort wMajorType;
            /// <summary>
            /// 次类型
            /// </summary>
            public ushort wMinorType;
            /// <summary>
            /// 操作参数
            /// </summary>
            public ushort wParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 10, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 描述信息长度
            /// </summary>
            public uint dwInfoLen;
            /// <summary>
            /// 描述信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = LOG_INFO_LEN)]
            public string sInfo;
        }

        /// <summary>
        /// ***********************动环报警管理主机日志查找 end**********************************************
        /// 报警输出状态(9000扩展)
        /// </summary>
        /*************************动环报警管理主机日志查找 end***********************************************/

        //报警输出状态(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMOUTSTATUS_V30
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMOUT_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] Output;
        }

        /// <summary>
        /// 报警输出状态
        /// </summary>
        //报警输出状态
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMOUTSTATUS
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] Output;
        }
        /// <summary>
        /// ATM专用
        /// **************************ATM(begin)**************************
        /// </summary>
        public const int NCR = 0;
        public const int DIEBOLD = 1;
        public const int WINCOR_NIXDORF = 2;
        public const int SIEMENS = 3;
        public const int OLIVETTI = 4;
        public const int FUJITSU = 5;
        public const int HITACHI = 6;
        public const int SMI = 7;
        public const int IBM = 8;
        public const int BULL = 9;
        public const int YiHua = 10;
        public const int LiDe = 11;
        public const int GDYT = 12;
        public const int Mini_Banl = 13;
        public const int GuangLi = 14;
        public const int DongXin = 15;
        public const int ChenTong = 16;
        public const int NanTian = 17;
        public const int XiaoXing = 18;
        public const int GZYY = 19;
        public const int QHTLT = 20;
        public const int DRS918 = 21;
        public const int KALATEL = 22;
        public const int NCR_2 = 23;
        public const int NXS = 24;

        /// <summary>
        /// 交易信息
        /// </summary>
        //交易信息
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_TRADEINFO
        {
            public ushort m_Year;
            public ushort m_Month;
            public ushort m_Day;
            public ushort m_Hour;
            public ushort m_Minute;
            public ushort m_Second;
            /// <summary>
            /// 设备名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] DeviceName;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannelNumer;
            /// <summary>
            /// 卡号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] CardNumber;
            /// <summary>
            /// 交易类型
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 12)]
            public string cTradeType;
            /// <summary>
            /// 交易金额
            /// </summary>
            public uint dwCash;
        }

        /// <summary>
        /// 帧格式
        /// </summary>
        /*帧格式*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FRAMETYPECODE
        {
            /// <summary>
            /// 代码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] code;
        }

        /// <summary>
        /// ATM参数
        /// </summary>
        //ATM参数
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_FRAMEFORMAT
        {
            public uint dwSize;
            /// <summary>
            /// ATM IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sATMIP;
            /// <summary>
            /// ATM类型
            /// </summary>
            public uint dwATMType;
            /// <summary>
            /// 输入方式	0-网络侦听 1-网络接收 2-串口直接输入 3-串口ATM命令输入
            /// </summary>
            public uint dwInputMode;
            /// <summary>
            /// 报文标志位的起始位置
            /// </summary>
            public uint dwFrameSignBeginPos;
            /// <summary>
            /// 报文标志位的长度
            /// </summary>
            public uint dwFrameSignLength;
            /// <summary>
            /// 报文标志位的内容
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byFrameSignContent;
            /// <summary>
            /// 卡号长度信息的起始位置
            /// </summary>
            public uint dwCardLengthInfoBeginPos;
            /// <summary>
            /// 卡号长度信息的长度
            /// </summary>
            public uint dwCardLengthInfoLength;
            /// <summary>
            /// 卡号信息的起始位置
            /// </summary>
            public uint dwCardNumberInfoBeginPos;
            /// <summary>
            /// 卡号信息的长度
            /// </summary>
            public uint dwCardNumberInfoLength;
            /// <summary>
            /// 交易类型的起始位置
            /// </summary>
            public uint dwBusinessTypeBeginPos;
            /// <summary>
            /// 交易类型的长度
            /// </summary>
            public uint dwBusinessTypeLength;
            /// <summary>
            /// 类型
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 10, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_FRAMETYPECODE[] frameTypeCode;
        }

        /// <summary>
        /// SDK_V31 ATM
        /// 过滤设置
        /// </summary>
        //SDK_V31 ATM
        /*过滤设置*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FILTER
        {
            /// <summary>
            /// 0,不启用;1,启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 0,ASCII;1,HEX
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 报文标志位的起始位置
            /// </summary>
            public byte byFrameBeginPos;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 1, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 过滤字符串
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byFilterText;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 起始标识设置
        /// </summary>
        /*起始标识设置*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IDENTIFICAT
        {
            /// <summary>
            /// 0,ASCII;1,HEX
            /// </summary>
            public byte byStartMode;
            /// <summary>
            /// 0,ASCII;1,HEX
            /// </summary>
            public byte byEndMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 起始字符
            /// </summary>
            public NET_DVR_FRAMETYPECODE struStartCode;
            /// <summary>
            /// 结束字符
            /// </summary>
            public NET_DVR_FRAMETYPECODE struEndCode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        /// <summary>
        /// 报文信息位置
        /// </summary>
        /*报文信息位置*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PACKAGE_LOCATION
        {
            /// <summary>
            /// 0,token;1,fix
            /// </summary>
            public byte byOffsetMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// mode为1的时候使用
            /// </summary>
            public uint dwOffsetPos;
            /// <summary>
            /// 标志位
            /// </summary>
            public NET_DVR_FRAMETYPECODE struTokenCode;
            /// <summary>
            /// 标志位多少次出现
            /// </summary>
            public byte byMultiplierValue;
            /// <summary>
            /// 附加的偏移量
            /// </summary>
            public byte byEternOffset;
            /// <summary>
            /// 0,ASCII;1,HEX
            /// </summary>
            public byte byCodeMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 9, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 报文信息长度
        /// </summary>
        /*报文信息长度*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PACKAGE_LENGTH
        {
            /// <summary>
            /// 长度类型，0,variable;1,fix;2,get from package(设置卡号长度使用)
            /// </summary>
            public byte byLengthMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// mode为1的时候使用
            /// </summary>
            public uint dwFixLength;
            public uint dwMaxLength;
            public uint dwMinLength;
            /// <summary>
            /// 终结符0,ASCII;1,HEX
            /// </summary>
            public byte byEndMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 终结符
            /// </summary>
            public NET_DVR_FRAMETYPECODE struEndCode;
            /// <summary>
            /// lengthMode为2的时候使用，卡号长度在报文中的位置
            /// </summary>
            public uint dwLengthPos;
            /// <summary>
            /// lengthMode为2的时候使用，卡号长度的长度
            /// </summary>
            public uint dwLengthLen;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }

        /// <summary>
        /// OSD 叠加的位置
        /// </summary>
        /*OSD 叠加的位置*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_OSD_POSITION
        {
            /// <summary>
            /// 叠加风格，共2种；0，不显示；1，Custom
            /// </summary>
            public byte byPositionMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// x坐标，positionmode为Custom时使用
            /// </summary>
            public uint dwPos_x;
            /// <summary>
            /// y坐标，positionmode为Custom时使用
            /// </summary>
            public uint dwPos_y;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 日期显示格式
        /// </summary>
        /*日期显示格式*/
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_DATE_FORMAT
        {
            /// <summary>
            /// Month,0.mm;1.mmm;2.mmmm
            /// </summary>
            public byte byItem1;
            /// <summary>
            /// Day,0.dd;
            /// </summary>
            public byte byItem2;
            /// <summary>
            /// Year,0.yy;1.yyyy
            /// </summary>
            public byte byItem3;
            /// <summary>
            /// 0~5，3个item的排列组合
            /// </summary>
            public byte byDateForm;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 分隔符
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 4)]
            public string chSeprator;
            /// <summary>
            /// 显示分隔符
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 4)]
            public string chDisplaySeprator;
            /// <summary>
            /// lili mode by lili
            /// 0~5，3个item的排列组合
            /// </summary>
            public byte byDisplayForm;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 27, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
        }

        /// <summary>
        /// 时间显示格式
        /// </summary>
        /*时间显示格式*/
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVRT_TIME_FORMAT
        {
            /// <summary>
            /// 1. HH MM SS;0. HH MM
            /// </summary>
            public byte byTimeForm;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 23, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// lili mode
            /// 0,12;1,24
            /// </summary>
            public byte byHourMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 报文分隔符，暂时没用
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 4)]
            public string chSeprator;
            /// <summary>
            /// 显示分隔符
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 4)]
            public string chDisplaySeprator;
            /// <summary>
            /// 0~5，3个item的排列组合
            /// </summary>
            public byte byDisplayForm;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
            /// <summary>
            /// lili mode
            /// 0,12;1,24
            /// </summary>
            public byte byDisplayHourMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 19, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes4;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_OVERLAY_CHANNEL
        {
            /// <summary>
            /// 叠加的通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byChannel;
            /// <summary>
            /// 叠加延时时间
            /// </summary>
            public uint dwDelayTime;
            /// <summary>
            /// 是否启用叠加延时，在无退卡命令时启用
            /// </summary>
            public byte byEnableDelayTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ATM_PACKAGE_ACTION
        {
            public NET_DVR_PACKAGE_LOCATION struPackageLocation;
            public NET_DVR_OSD_POSITION struOsdPosition;
            /// <summary>
            /// 交易类型等对应的码
            /// </summary>
            public NET_DVR_FRAMETYPECODE struActionCode;
            /// <summary>
            /// 叠加字符前的字符
            /// </summary>
            public NET_DVR_FRAMETYPECODE struPreCode;
            /// <summary>
            /// 交易类型等对应的码0,ASCII;1,HEX
            /// </summary>
            public byte byActionCodeMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ATM_PACKAGE_DATE
        {
            public NET_DVR_PACKAGE_LOCATION struPackageLocation;
            public NET_DVR_DATE_FORMAT struDateForm;
            public NET_DVR_OSD_POSITION struOsdPosition;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ATM_PACKAGE_TIME
        {
            public NET_DVR_PACKAGE_LOCATION location;
            public NET_DVRT_TIME_FORMAT struTimeForm;
            public NET_DVR_OSD_POSITION struOsdPosition;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ATM_PACKAGE_OTHERS
        {
            public NET_DVR_PACKAGE_LOCATION struPackageLocation;
            public NET_DVR_PACKAGE_LENGTH struPackageLength;
            public NET_DVR_OSD_POSITION struOsdPosition;
            /// <summary>
            /// 叠加字符前的字符
            /// </summary>
            public NET_DVR_FRAMETYPECODE struPreCode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
        }

        /// <summary>
        /// 用户自定义协议
        /// </summary>
        //用户自定义协议
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ATM_USER_DEFINE_PROTOCOL
        {
            /// <summary>
            /// 报文标志
            /// </summary>
            public NET_DVR_IDENTIFICAT struIdentification;
            /// <summary>
            /// 数据包过滤设置
            /// </summary>
            public NET_DVR_FILTER struFilter;
            /// <summary>
            /// 叠加卡号设置
            /// </summary>
            public NET_DVR_ATM_PACKAGE_OTHERS struCardNoPara;
            /// <summary>
            /// 叠加交易行为设置 0-9 依次对应InCard OutCard OverLay SetTime GetStatus Query WithDraw Deposit ChanPass Transfer
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ACTION_TYPE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ATM_PACKAGE_ACTION[] struTradeActionPara;
            /// <summary>
            /// 叠加交易金额设置
            /// </summary>
            public NET_DVR_ATM_PACKAGE_OTHERS struAmountPara;
            /// <summary>
            /// 叠加交易序号设置
            /// </summary>
            public NET_DVR_ATM_PACKAGE_OTHERS struSerialNoPara;
            /// <summary>
            /// 叠加通道设置
            /// </summary>
            public NET_DVR_OVERLAY_CHANNEL struOverlayChan;
            /// <summary>
            /// 叠加日期，保留
            /// </summary>
            public NET_DVR_ATM_PACKAGE_DATE struRes1;
            /// <summary>
            /// 叠加时间，保留
            /// </summary>
            public NET_DVR_ATM_PACKAGE_TIME struRes2;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 124, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ATM_FRAMEFORMAT_V30
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 是否启用0,不启用;1,启用
            /// </summary>
            public byte byEnable;
            public byte byInputMode;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 34, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// ATM 机IP 网络监听时使用
            /// </summary>
            public NET_DVR_IPADDR struAtmIp;
            /// <summary>
            /// 网络协议方式时是使用
            /// </summary>
            public ushort wAtmPort;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// ATM协议类型，从NET_DVR_ATM_PROTOCOL结构中获取，如果类型为自定义时使用用户自定义协议
            /// </summary>
            public uint dwAtmType;
            /// <summary>
            /// 用户自定义协议，当ATM类型为自定时需要使用该定义
            /// </summary>
            public NET_DVR_ATM_USER_DEFINE_PROTOCOL struAtmUserDefineProtocol;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }

        /// <summary>
        /// 协议信息数据结构
        /// </summary>
        //协议信息数据结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ATM_PROTO_TYPE
        {
            /// <summary>
            /// ATM协议类型，同时作为索引序号 ATM 配置中的dwAtmType 自定义时为1025
            /// </summary>
            public uint dwAtmType;
            /// <summary>
            /// ATM协议简单描述
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = ATM_DESC_LEN)]
            public string chDesc;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_ATM_PROTO_LIST
        {
            /// <summary>
            /// 协议列表的个数
            /// </summary>
            public uint dwAtmProtoNum;
            /// <summary>
            /// 协议列表信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ATM_PROTOCOL_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ATM_PROTO_TYPE[] struAtmProtoType;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ATM_PROTOCOL
        {
            public uint dwSize;
            /// <summary>
            /// 网络监听协议描述
            /// </summary>
            public NET_DVR_ATM_PROTO_LIST struNetListenList;
            /// <summary>
            /// 串口监听协议描述
            /// </summary>
            public NET_DVR_ATM_PROTO_LIST struSerialListenList;
            /// <summary>
            /// 网络协议描述
            /// </summary>
            public NET_DVR_ATM_PROTO_LIST struNetProtoList;
            /// <summary>
            /// 串口协议描述
            /// </summary>
            public NET_DVR_ATM_PROTO_LIST struSerialProtoList;
            /// <summary>
            /// 自定义协议
            /// </summary>
            public NET_DVR_ATM_PROTO_TYPE struCustomProto;
        }

        /// <summary>
        /// ***************************DS-6001D/F(begin)**************************
        /// DS-6001D Decoder
        /// </summary>
        /*****************************DS-6001D/F(begin)***************************/
        //DS-6001D Decoder
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DECODERINFO
        {
            /// <summary>
            /// 解码设备连接的服务器IP
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byEncoderIP;
            /// <summary>
            /// 解码设备连接的服务器的用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byEncoderUser;
            /// <summary>
            /// 解码设备连接的服务器的密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byEncoderPasswd;
            /// <summary>
            /// 解码设备连接服务器的连接模式
            /// </summary>
            public byte bySendMode;
            /// <summary>
            /// 解码设备连接的服务器的通道号
            /// </summary>
            public byte byEncoderChannel;
            /// <summary>
            /// 解码设备连接的服务器的端口号
            /// </summary>
            public ushort wEncoderPort;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] reservedData;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DECODERSTATE
        {
            /// <summary>
            /// 解码设备连接的服务器IP
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byEncoderIP;
            /// <summary>
            /// 解码设备连接的服务器的用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byEncoderUser;
            /// <summary>
            /// 解码设备连接的服务器的密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byEncoderPasswd;
            /// <summary>
            /// 解码设备连接的服务器的通道号
            /// </summary>
            public byte byEncoderChannel;
            /// <summary>
            /// 解码设备连接的服务器的连接模式
            /// </summary>
            public byte bySendMode;
            /// <summary>
            /// 解码设备连接的服务器的端口号
            /// </summary>
            public ushort wEncoderPort;
            /// <summary>
            /// 解码设备连接服务器的状态
            /// </summary>
            public uint dwConnectState;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] reservedData;
        }
        /// <summary>
        /// 解码设备控制码定义
        /// </summary>
        public const int NET_DEC_STARTDEC = 1;
        public const int NET_DEC_STOPDEC = 2;
        public const int NET_DEC_STOPCYCLE = 3;
        public const int NET_DEC_CONTINUECYCLE = 4;

        /// <summary>
        /// 连接的通道配置
        /// </summary>
        /*连接的通道配置*/
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_DECCHANINFO
        {
            /// <summary>
            /// DVR IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sDVRIP;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDVRPort;
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 通道号
            /// </summary>
            public byte byChannel;
            /// <summary>
            /// 连接模式
            /// </summary>
            public byte byLinkMode;
            /// <summary>
            /// 连接类型 0－主码流 1－子码流
            /// </summary>
            public byte byLinkType;
        }

        /// <summary>
        /// 每个解码通道的配置
        /// </summary>
        /*每个解码通道的配置*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DECINFO
        {
            /// <summary>
            /// 每路解码通道上的循环通道数量, 最多4通道 0表示没有解码
            /// </summary>
            public byte byPoolChans;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DECPOOLNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_DECCHANINFO[] struchanConInfo;
            /// <summary>
            /// 是否轮巡 0-否 1-是
            /// </summary>
            public byte byEnablePoll;
            /// <summary>
            /// 轮巡时间 0-保留 1-10秒 2-15秒 3-20秒 4-30秒 5-45秒 6-1分钟 7-2分钟 8-5分钟
            /// </summary>
            public byte byPoolTime;
        }

        /// <summary>
        /// 整个设备解码配置
        /// </summary>
        /*整个设备解码配置*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DECCFG
        {
            public uint dwSize;
            /// <summary>
            /// 解码通道的数量
            /// </summary>
            public uint dwDecChanNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DECNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_DECINFO[] struDecInfo;
        }

        /// <summary>
        /// 2005-08-01
        /// 解码设备透明通道设置
        /// </summary>
        //2005-08-01
        /* 解码设备透明通道设置 */
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_PORTINFO
        {
            /// <summary>
            /// 是否启动透明通道 0－不启用 1－启用
            /// </summary>
            public uint dwEnableTransPort;
            /// <summary>
            /// DVR IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sDecoderIP;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDecoderPort;
            /// <summary>
            /// 配置前端DVR是从485/232输出，1表示232串口,2表示485串口
            /// </summary>
            public ushort wDVRTransPort;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 4)]
            public string cReserve;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PORTCFG
        {
            public uint dwSize;
            /// <summary>
            /// 数组0表示232 数组1表示485
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TRANSPARENTNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_PORTINFO[] struTransPortInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct bytime
        {
            public uint dwChannel;
            /// <summary>
            /// 请求视频用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 按时间回放的开始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 按时间回放的结束时间
            /// </summary>
            public NET_DVR_TIME struStopTime;
        }

        /// <summary>
        /// 控制网络文件回放
        /// </summary>
        /* 控制网络文件回放 */
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_PLAYREMOTEFILE
        {
            public uint dwSize;
            /// <summary>
            /// DVR IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sDecoderIP;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDecoderPort;
            /// <summary>
            /// 回放下载模式 1－按名字 2－按时间
            /// </summary>
            public ushort wLoadMode;
        }

        /// <summary>
        /// 当前设备解码连接状态
        /// </summary>
        /*当前设备解码连接状态*/
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_DECCHANSTATUS
        {
            /// <summary>
            /// 工作方式：1：轮巡、2：动态连接解码、3：文件回放下载 4：按时间回放下载
            /// </summary>
            public uint dwWorkType;
            /// <summary>
            /// 连接的设备ip
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sDVRIP;
            /// <summary>
            /// 连接端口号
            /// </summary>
            public ushort wDVRPort;
            /// <summary>
            /// 通道号
            /// </summary>
            public byte byChannel;
            /// <summary>
            /// 连接模式
            /// </summary>
            public byte byLinkMode;
            /// <summary>
            /// 连接类型 0－主码流 1－子码流
            /// </summary>
            public uint dwLinkType;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DECSTATUS
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DECNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_DECCHANSTATUS[] struTransPortInfo;
        }

        /// <summary>
        /// ***************************DS-6001D/F(end)**************************
        /// 单字符参数(子结构)
        /// </summary>
        /*****************************DS-6001D/F(end)***************************/

        //单字符参数(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_SHOWSTRINGINFO
        {
            /// <summary>
            /// 预览的图象上是否显示字符,0-不显示,1-显示 区域大小704*576,单个字符的大小为32*32
            /// </summary>
            public ushort wShowString;
            /// <summary>
            /// 该行字符的长度，不能大于44个字符
            /// </summary>
            public ushort wStringSize;
            /// <summary>
            /// 字符显示位置的x坐标
            /// </summary>
            public ushort wShowStringTopLeftX;
            /// <summary>
            /// 字符名称显示位置的y坐标
            /// </summary>
            public ushort wShowStringTopLeftY;
            /// <summary>
            /// 要显示的字符内容
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 44)]
            public string sString;
        }

        /// <summary>
        /// 叠加字符(9000扩展)
        /// </summary>
        //叠加字符(9000扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SHOWSTRING_V30
        {
            public uint dwSize;
            /// <summary>
            /// 要显示的字符内容
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_STRINGNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SHOWSTRINGINFO[] struStringInfo;
        }

        /// <summary>
        /// 叠加字符扩展(8条字符)
        /// </summary>
        //叠加字符扩展(8条字符)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SHOWSTRING_EX
        {
            public uint dwSize;
            /// <summary>
            /// 要显示的字符内容
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_STRINGNUM_EX, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SHOWSTRINGINFO[] struStringInfo;
        }

        /// <summary>
        /// 叠加字符
        /// </summary>
        //叠加字符
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SHOWSTRING
        {
            public uint dwSize;
            /// <summary>
            /// 要显示的字符内容
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_STRINGNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SHOWSTRINGINFO[] struStringInfo;
        }

        /// <summary>
        /// **************************DS9000新增结构(begin)*****************************
        /// EMAIL参数结构
        /// 与原结构体有差异
        /// </summary>
        /****************************DS9000新增结构(begin)******************************/
        /*EMAIL参数结构*/
        //与原结构体有差异
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct struReceiver
        {
            /// <summary>
            /// 收件人姓名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sName;
            /// <summary>
            /// 收件人地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_EMAIL_ADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sAddress;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_EMAILCFG_V30
        {
            public uint dwSize;
            /// <summary>
            /// 账号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sAccount;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_EMAIL_PWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// smtp服务器
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_EMAIL_ADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sSmtpServer;
            /// <summary>
            /// pop3服务器
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_EMAIL_ADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPop3Server;
            /// <summary>
            /// 最多可以设置3个收件人
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.Struct)]
            public struReceiver[] struStringInfo;
            /// <summary>
            /// 是否带附件
            /// </summary>
            public byte byAttachment;
            /// <summary>
            /// 发送服务器要求身份验证
            /// </summary>
            public byte bySmtpServerVerify;
            /// <summary>
            /// mail interval
            /// </summary>
            public byte byMailInterval;
            /// <summary>
            /// ssl是否启用9000_1.1
            /// </summary>
            public byte byEnableSSL;
            /// <summary>
            /// gmail的465，普通的为25
            /// </summary>
            public ushort wSmtpPort;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 74, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// DVR实现巡航数据结构
        /// </summary>
        /*DVR实现巡航数据结构*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CRUISE_PARA
        {
            public uint dwSize;
            /// <summary>
            /// 预置点号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = CRUISE_MAX_PRESET_NUMS, ArraySubType = UnmanagedType.I1)]
            public byte[] byPresetNo;
            /// <summary>
            /// 巡航速度
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = CRUISE_MAX_PRESET_NUMS, ArraySubType = UnmanagedType.I1)]
            public byte[] byCruiseSpeed;
            /// <summary>
            /// 停留时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = CRUISE_MAX_PRESET_NUMS, ArraySubType = UnmanagedType.U2)]
            public ushort[] wDwellTime;
            /// <summary>
            /// 是否启用
            /// </summary>
            public byte byEnableThisCruise;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 15, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
        }

        /// <summary>
        /// **************************DS9000新增结构(end)*****************************
        /// 时间点
        /// </summary>
        /****************************DS9000新增结构(end)******************************/
        //时间点
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TIMEPOINT
        {
            /// <summary>
            /// 月 0-11表示1-12个月
            /// </summary>
            public uint dwMonth;
            /// <summary>
            /// 第几周 0－第1周 1－第2周 2－第3周 3－第4周 4－最后一周
            /// </summary>
            public uint dwWeekNo;
            /// <summary>
            /// 星期几 0－星期日 1－星期一 2－星期二 3－星期三 4－星期四 5－星期五 6－星期六
            /// </summary>
            public uint dwWeekDate;
            /// <summary>
            /// 小时	开始时间0－23 结束时间1－23
            /// </summary>
            public uint dwHour;
            /// <summary>
            /// 分	0－59
            /// </summary>
            public uint dwMin;
        }

        /// <summary>
        /// 夏令时参数
        /// </summary>
        //夏令时参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ZONEANDDST
        {
            public uint dwSize;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 是否启用夏时制 0－不启用 1－启用
            /// </summary>
            public uint dwEnableDST;
            /// <summary>
            /// 夏令时偏移值，30min, 60min, 90min, 120min, 以分钟计，传递原始数值
            /// </summary>
            public byte byDSTBias;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 夏时制开始时间
            /// </summary>
            public NET_DVR_TIMEPOINT struBeginPoint;
            /// <summary>
            /// 夏时制停止时间
            /// </summary>
            public NET_DVR_TIMEPOINT struEndPoint;
        }

        /// <summary>
        /// 图片质量
        /// </summary>
        //图片质量
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_JPEGPARA
        {
            /// <summary>
            /// 注意：当图像压缩分辨率为VGA时，支持0=CIF, 1=QCIF, 2=D1抓图，
            /// 当分辨率为3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA,7=XVGA, 8=HD900p
            /// 仅支持当前分辨率的抓图
            /// </summary>
            public ushort wPicSize;
            /// <summary>
            /// 图片质量系数 0-最好 1-较好 2-一般
            /// </summary>
            public ushort wPicQuality;
        }

        /// <summary>
        /// aux video out parameter
        /// 辅助输出参数配置
        /// </summary>
        /* aux video out parameter */
        //辅助输出参数配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AUXOUTCFG
        {
            public uint dwSize;
            /// <summary>
            /// 选择报警弹出大报警通道切换时间：1画面的输出通道: 0:主输出/1:辅1/2:辅2/3:辅3/4:辅4
            /// </summary>
            public uint dwAlarmOutChan;
            /// <summary>
            /// :1秒 - 10:10秒
            /// </summary>
            public uint dwAlarmChanSwitchTime;
            /// <summary>
            /// 辅助输出切换时间: 0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_AUXOUT, ArraySubType = UnmanagedType.U4)]
            public uint[] dwAuxSwitchTime;
            /// <summary>
            /// 辅助输出预览顺序, 0xff表示相应的窗口不预览
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_AUXOUT * MAX_WINDOW, ArraySubType = UnmanagedType.I1)]
            public byte[] byAuxOrder;
        }

        /// <summary>
        /// ntp
        /// </summary>
        //ntp
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_NTPPARA
        {
            /// <summary>
            /// Domain Name or IP addr of NTP server
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] sNTPServer;
            /// <summary>
            /// adjust time interval(hours)
            /// </summary>
            public ushort wInterval;
            /// <summary>
            /// enable NPT client 0-no，1-yes
            /// </summary>
            public byte byEnableNTP;
            /// <summary>
            /// 与国际标准时间的 小时偏移-12 ... +13
            /// </summary>
            public byte cTimeDifferenceH;
            /// <summary>
            /// 与国际标准时间的 分钟偏移0, 30, 45
            /// </summary>
            public byte cTimeDifferenceM;
            public byte res1;
            /// <summary>
            /// ntp server port 9000新增 设备默认为123
            /// </summary>
            public ushort wNtpPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] res2;
        }

        /// <summary>
        /// ddns
        /// </summary>
        //ddns
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DDNSPARA
        {
            /// <summary>
            /// DDNS账号用户名/密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUsername;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 域名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] sDomainName;
            /// <summary>
            /// 是否应用 0-否，1-是
            /// </summary>
            public byte byEnableDDNS;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 15, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DDNSPARA_EX
        {
            /// <summary>
            /// 0-Hikvision DNS 1－Dyndns 2－PeanutHull(花生壳)
            /// </summary>
            public byte byHostIndex;
            /// <summary>
            /// 是否应用DDNS 0-否，1-是
            /// </summary>
            public byte byEnableDDNS;
            /// <summary>
            /// DDNS端口号
            /// </summary>
            public ushort wDDNSPort;
            /// <summary>
            /// DDNS用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUsername;
            /// <summary>
            /// DDNS密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 设备配备的域名地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] sDomainName;
            /// <summary>
            /// DDNS 对应的服务器地址，可以是IP地址或域名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] sServerName;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 9000扩展
        /// </summary>
        //9000扩展
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct struDDNS
        {
            /// <summary>
            /// DDNS账号用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUsername;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 设备配备的域名地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] sDomainName;
            /// <summary>
            /// DDNS协议对应的服务器地址，可以是IP地址或域名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] sServerName;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDDNSPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 10, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DDNSPARA_V30
        {
            public byte byEnableDDNS;
            /// <summary>
            /// 0-Hikvision DNS(保留) 1－Dyndns 2－PeanutHull(花生壳)
            /// </summary>
            public byte byHostIndex;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DDNS_NUMS, ArraySubType = UnmanagedType.Struct)]
            public struDDNS[] struDDNS;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// email
        /// </summary>
        //email
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_EMAILPARA
        {
            /// <summary>
            /// 邮件账号/密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] sUsername;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] sSmtpServer;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] sPop3Server;
            /// <summary>
            /// email
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] sMailAddr;
            /// <summary>
            /// 上传报警/异常等的email
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] sEventMailAddr1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] sEventMailAddr2;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
        }

        /// <summary>
        /// 网络参数配置
        /// </summary>
        //网络参数配置
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_NETAPPCFG
        {
            public uint dwSize;
            /// <summary>
            /// DNS服务器地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sDNSIp;
            /// <summary>
            /// NTP参数
            /// </summary>
            public NET_DVR_NTPPARA struNtpClientParam;
            /// <summary>
            /// DDNS参数
            /// </summary>
            public NET_DVR_DDNSPARA struDDNSClientParam;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 464, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
        }

        /// <summary>
        /// nfs结构配置
        /// </summary>
        //nfs结构配置
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_SINGLE_NFS
        {
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sNfsHostIPAddr;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PATHNAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sNfsDirectory;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_NFSCFG
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NFS_DISK, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SINGLE_NFS[] struNfsDiskParam;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ISCSI_CFG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// VRM 监听端口
            /// </summary>
            public ushort wVrmPort;
            /// <summary>
            /// 是否启用 ISCSI存储
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 69, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// VRM ip地址 16位
            /// </summary>
            public NET_DVR_IPADDR struVrmAddr;
            /// <summary>
            /// nvt index Code
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 64)]
            public string chNvtIndexCode;
        }

        /// <summary>
        /// 巡航点配置(HIK IP快球专用)
        /// </summary>
        //巡航点配置(HIK IP快球专用)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CRUISE_POINT
        {
            /// <summary>
            /// 预置点
            /// </summary>
            public byte PresetNum;
            /// <summary>
            /// 停留时间
            /// </summary>
            public byte Dwell;
            /// <summary>
            /// 速度
            /// </summary>
            public byte Speed;
            /// <summary>
            /// 保留
            /// </summary>
            public byte Reserve;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CRUISE_RET
        {
            /// <summary>
            /// 最大支持32个巡航点
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CRUISE_POINT[] struCruisePoint;
        }

        /// <summary>
        /// **********************************多路解码器(begin)**************************************
        /// </summary>
        /************************************多路解码器(begin)***************************************/
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_NETCFG_OTHER
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sFirstDNSIP;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sSecondDNSIP;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string sRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MATRIX_DECINFO
        {
            /// <summary>
            /// DVR IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sDVRIP;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDVRPort;
            /// <summary>
            /// 通道号
            /// </summary>
            public byte byChannel;
            /// <summary>
            /// 传输协议类型 0-TCP, 1-UDP
            /// </summary>
            public byte byTransProtocol;
            /// <summary>
            /// 传输码流模式 0－主码流 1－子码流
            /// </summary>
            public byte byTransMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 布防主机登陆帐号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 布防主机密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
        }

        /// <summary>
        /// 启动/停止动态解码
        /// </summary>
        //启动/停止动态解码
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_DYNAMIC_DEC
        {
            public uint dwSize;
            /// <summary>
            /// 动态解码通道信息
            /// </summary>
            public NET_DVR_MATRIX_DECINFO struDecChanInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MATRIX_DEC_CHAN_STATUS
        {
            public uint dwSize;
            /// <summary>
            /// 解码通道状态 0－休眠 1－正在连接 2－已连接 3-正在解码
            /// </summary>
            public uint dwIsLinked;
            /// <summary>
            /// Stream copy rate, X kbits/second
            /// </summary>
            public uint dwStreamCpRate;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 64)]
            public string cRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MATRIX_DEC_CHAN_INFO
        {
            public uint dwSize;
            /// <summary>
            /// 解码通道信息
            /// </summary>
            public NET_DVR_MATRIX_DECINFO struDecChanInfo;
            /// <summary>
            /// 0-动态解码 1－循环解码 2－按时间回放 3－按文件回放
            /// </summary>
            public uint dwDecState;
            /// <summary>
            /// 按时间回放开始时间
            /// </summary>
            public NET_DVR_TIME StartTime;
            /// <summary>
            /// 按时间回放停止时间
            /// </summary>
            public NET_DVR_TIME StopTime;
            /// <summary>
            /// 按文件回放文件名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string sFileName;
        }

        /// <summary>
        /// 连接的通道配置 2007-11-05
        /// </summary>
        //连接的通道配置 2007-11-05
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_DECCHANINFO
        {
            /// <summary>
            /// 是否启用 0－否 1－启用
            /// </summary>
            public uint dwEnable;
            /// <summary>
            /// 轮循解码通道信息
            /// </summary>
            public NET_DVR_MATRIX_DECINFO struDecChanInfo;
        }

        /// <summary>
        /// 2007-11-05 新增每个解码通道的配置
        /// </summary>
        //2007-11-05 新增每个解码通道的配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_LOOP_DECINFO
        {
            public uint dwSize;
            /// <summary>
            /// 轮巡时间
            /// </summary>
            public uint dwPoolTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CYCLE_CHAN, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_MATRIX_DECCHANINFO[] struchanConInfo;
        }

        /// <summary>
        /// 2007-12-22
        /// </summary>
        //2007-12-22
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct TTY_CONFIG
        {
            /// <summary>
            /// 波特率
            /// </summary>
            public byte baudrate;
            /// <summary>
            /// 数据位
            /// </summary>
            public byte databits;
            /// <summary>
            /// 停止位
            /// </summary>
            public byte stopbits;
            /// <summary>
            /// 奇偶校验位
            /// </summary>
            public byte parity;
            /// <summary>
            /// 流控
            /// </summary>
            public byte flowcontrol;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MATRIX_TRAN_CHAN_INFO
        {
            /// <summary>
            /// 当前透明通道是否打开 0：关闭 1：打开
            /// </summary>
            public byte byTranChanEnable;
            /// <summary>
            /// 多路解码器本地有1个485串口，1个232串口都可以作为透明通道,设备号分配如下：
            /// 0 RS485
            /// 1 RS232 Console
            /// </summary>
            public byte byLocalSerialDevice;
            /// <summary>
            /// 远程串口输出还是两个,一个RS232，一个RS485
            /// 1表示232串口
            /// 2表示485串口
            /// </summary>
            public byte byRemoteSerialDevice;
            /// <summary>
            /// 保留
            /// </summary>
            public byte res1;
            /// <summary>
            /// Remote Device IP
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sRemoteDevIP;
            /// <summary>
            /// Remote Net Communication Port
            /// </summary>
            public ushort wRemoteDevPort;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] res2;
            public TTY_CONFIG RemoteSerialDevCfg;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_TRAN_CHAN_CONFIG
        {
            public uint dwSize;
            /// <summary>
            /// 设置哪路232透明通道是全双工的 取值1到MAX_SERIAL_NUM
            /// </summary>
            public byte by232IsDualChan;
            /// <summary>
            /// 设置哪路485透明通道是全双工的 取值1到MAX_SERIAL_NUM
            /// </summary>
            public byte by485IsDualChan;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
            /// <summary>
            /// 同时支持建立MAX_SERIAL_NUM个透明通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SERIAL_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_MATRIX_TRAN_CHAN_INFO[] struTranInfo;
        }

        /// <summary>
        /// 2007-12-24 Merry Christmas Eve...
        /// </summary>
        //2007-12-24 Merry Christmas Eve...
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MATRIX_DEC_REMOTE_PLAY
        {
            public uint dwSize;
            /// <summary>
            /// DVR IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sDVRIP;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDVRPort;
            /// <summary>
            /// 通道号
            /// </summary>
            public byte byChannel;
            public byte byReserve;
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 0－按文件 1－按时间
            /// </summary>
            public uint dwPlayMode;
            public NET_DVR_TIME StartTime;
            public NET_DVR_TIME StopTime;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string sFileName;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL
        {
            public uint dwSize;
            /// <summary>
            /// 播放命令 见文件播放命令
            /// </summary>
            public uint dwPlayCmd;
            /// <summary>
            /// 播放命令参数
            /// </summary>
            public uint dwCmdParam;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS
        {
            public uint dwSize;
            /// <summary>
            /// 当前播放的媒体文件长度
            /// </summary>
            public uint dwCurMediaFileLen;
            /// <summary>
            /// 当前播放文件的播放位置
            /// </summary>
            public uint dwCurMediaFilePosition;
            /// <summary>
            /// 当前播放文件的总时间
            /// </summary>
            public uint dwCurMediaFileDuration;
            /// <summary>
            /// 当前已经播放的时间
            /// </summary>
            public uint dwCurPlayTime;
            /// <summary>
            /// 当前播放文件的总帧数
            /// </summary>
            public uint dwCurMediaFIleFrames;
            /// <summary>
            /// 当前传输的数据类型，19-文件头，20-流数据， 21-播放结束标志
            /// </summary>
            public uint dwCurDataType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 72, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
        }

        /// <summary>
        /// 2009-4-11 added by likui 多路解码器new
        /// </summary>
        //2009-4-11 added by likui 多路解码器new
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_PASSIVEMODE
        {
            /// <summary>
            /// 传输协议，0-TCP, 1-UDP, 2-MCAST
            /// </summary>
            public ushort wTransProtol;
            /// <summary>
            /// UDP端口, TCP时默认
            /// </summary>
            public ushort wPassivePort;
            public NET_DVR_IPADDR struMcastIP;
            /// <summary>
            /// 数据播放模式:REAL_TIME_STREAM(1)实时流,RECORD_STREAM(2)文件流
            /// </summary>
            public byte byStreamType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_TRAN_CHAN_INFO_V30
        {
            /// <summary>
            /// 当前透明通道是否打开 0：关闭 1：打开
            /// </summary>
            public byte byTranChanEnable;
            /// <summary>
            /// 多路解码器本地有1个485串口，1个232串口都可以作为透明通道,设备号分配如下：
            /// 0 RS485
            /// 1 RS232 Console
            /// </summary>
            public byte byLocalSerialDevice;
            /// <summary>
            /// 远程串口输出还是两个,一个RS232，一个RS485
            /// 1表示232串口
            /// 2表示485串口
            /// </summary>
            public byte byRemoteSerialDevice;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// Remote Device IP
            /// </summary>
            public NET_DVR_IPADDR struRemoteDevIP;
            /// <summary>
            /// Remote Net Communication Port
            /// </summary>
            public ushort wRemoteDevPort;
            /// <summary>
            /// 透明通道建立成功标志，0-没有成功，1-建立成功
            /// </summary>
            public byte byIsEstablished;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byRes2;
            public TTY_CONFIG RemoteSerialDevCfg;
            /// <summary>
            /// 32BYTES
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byUsername;
            /// <summary>
            /// 16BYTES
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPassword;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30
        {
            public uint dwSize;
            /// <summary>
            /// 设置哪路232透明通道是全双工的 取值1到MAX_SERIAL_NUM
            /// </summary>
            public byte by232IsDualChan;
            /// <summary>
            /// 设置哪路485透明通道是全双工的 取值1到MAX_SERIAL_NUM
            /// </summary>
            public byte by485IsDualChan;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] vyRes;
            /// <summary>
            /// 同时支持建立MAX_SERIAL_NUM个透明通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SERIAL_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_MATRIX_TRAN_CHAN_INFO[] struTranInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_CHAN_INFO_V30
        {
            /// <summary>
            /// 是否启用 0－否 1－启用
            /// </summary>
            public uint dwEnable;
            public NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg;
            /// <summary>
            /// 轮循解码通道信息
            /// </summary>
            public NET_DVR_DEV_CHAN_INFO struDevChanInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_LOOP_DECINFO_V30
        {
            public uint dwSize;
            public uint dwPoolTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CYCLE_CHAN_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_MATRIX_CHAN_INFO_V30[] struchanConInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MATRIX_DEC_CHAN_INFO_V30
        {
            public uint dwSize;
            /// <summary>
            /// 流媒体服务器配置
            /// </summary>
            public NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg;
            /// <summary>
            /// 解码通道信息
            /// </summary>
            public NET_DVR_DEV_CHAN_INFO struDevChanInfo;
            /// <summary>
            /// 0-动态解码 1－循环解码 2－按时间回放 3－按文件回放
            /// </summary>
            public uint dwDecState;
            /// <summary>
            /// 按时间回放开始时间
            /// </summary>
            public NET_DVR_TIME StartTime;
            /// <summary>
            /// 按时间回放停止时间
            /// </summary>
            public NET_DVR_TIME StopTime;
            /// <summary>
            /// 按文件回放文件名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string sFileName;
            /// <summary>
            /// 取流模式:1-主动，2-被动
            /// </summary>
            public uint dwGetStreamMode;
            public NET_DVR_MATRIX_PASSIVEMODE struPassiveMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 流媒体服务器基本配置
        /// </summary>
        /*流媒体服务器基本配置*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_STREAM_MEDIA_SERVER
        {
            /// <summary>
            /// 是否启用流媒体服务器取流,0表示无效，非0表示有效
            /// </summary>
            public byte byValid;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 设备IP地址或者域名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = MAX_DOMAIN_NAME)]
            public string byAddress;
            /// <summary>
            /// 流媒体服务器端口
            /// </summary>
            public ushort wDevPort;
            /// <summary>
            /// 传输协议类型 0-TCP，1-UDP
            /// </summary>
            public byte byTransmitType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 设备通道信息
        /// </summary>
        //设备通道信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEV_CHAN_INFO_EX
        {
            /// <summary>
            /// 通道类型：0-普通通道，1-零通道，2-流ID，3-本地输入源
            /// </summary>
            public byte byChanType;
            /// <summary>
            /// 流ID，通道类型 byChanType 为 2 时有效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = STREAM_ID_LEN)]
            public string byStreamId;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 通道类型 byChanType为 0、1、3 时有效（如果通道类型为本地输入源，该参数值表示本地输入源索引）
            /// </summary>
            public uint dwChannel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 设备IP地址或者域名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = MAX_DOMAIN_NAME)]
            public string byAddress;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDVRPort;
            /// <summary>
            /// 该参数无效，通道号见dwChannel
            /// </summary>
            public byte byChannel;
            /// <summary>
            /// 传输协议类型0-TCP，1-UDP
            /// </summary>
            public byte byTransProtocol;
            /// <summary>
            /// 传输码流模式 0－主码流 1－子码流
            /// </summary>
            public byte byTransMode;
            /// <summary>
            /// 前端设备厂家类型,通过接口获取
            /// </summary>
            public byte byFactoryType;
            /// <summary>
            /// 设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
            /// </summary>
            public byte byDeviceType;
            /// <summary>
            /// 显示通道号,智能配置使用
            /// </summary>
            public byte byDispChan;
            /// <summary>
            /// 显示通道子通道号，智能配置时使用
            /// </summary>
            public byte bySubDispChan;
            /// <summary>
            /// ; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
            /// </summary>
            public byte byResolution;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 布防主机登陆帐号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = NAME_LEN)]
            public string sUserName;
            /// <summary>
            /// 布防主机密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = PASSWD_LEN)]
            public string sPassword;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_DEC_STREAM_DEV_EX
        {
            /// <summary>
            /// 流媒体服务器配置
            /// </summary>
            public NET_DVR_STREAM_MEDIA_SERVER struStreamMediaSvrCfg;
            /// <summary>
            /// 解码通道信息
            /// </summary>
            public NET_DVR_DEV_CHAN_INFO_EX struDevChanInfo;
        }

        /// <summary>
        /// 动态域名参数配置
        /// </summary>
        //动态域名参数配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEV_DDNS_INFO
        {
            /// <summary>
            /// 设备域名(IPServer或hiDDNS时可填设备序列号或者别名)
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = MAX_DOMAIN_NAME)]
            public string byDevAddress;
            /// <summary>
            /// 传输协议类型：0- TCP，1- UDP，2- 多播
            /// </summary>
            public byte byTransProtocol;
            /// <summary>
            /// 传输码流模式 0－主码流 1－子码流
            /// </summary>
            public byte byTransMode;
            /// <summary>
            /// 域名服务器类型：0- IPServer，1- Dyndns，2- PeanutHull(花生壳)，3- NO-IP，4- hiDDNS
            /// </summary>
            public byte byDdnsType;
            public byte byRes1;
            /// <summary>
            /// DDNS服务器地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = MAX_DOMAIN_NAME)]
            public string byDdnsAddress;
            /// <summary>
            /// DDNS服务器端口号
            /// </summary>
            public ushort wDdnsPort;
            /// <summary>
            /// 通道类型：0-普通通道，1-零通道，2-流ID
            /// </summary>
            public byte byChanType;
            /// <summary>
            /// 前端设备厂家类型,通过接口NET_DVR_GetIPCProtoList获取
            /// </summary>
            public byte byFactoryType;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 流ID，通道类型 byChanType 为 2 时有效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = STREAM_ID_LEN)]
            public string byStreamId;
            /// <summary>
            /// 布防主机登陆帐号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = NAME_LEN)]
            public string sUserName;
            /// <summary>
            /// 布防主机密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = PASSWD_LEN)]
            public string sPassword;
            /// <summary>
            /// 设备端口号
            /// </summary>
            public ushort wDevPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 动态域名取流配置
        /// </summary>
        //动态域名取流配置
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_DEC_DDNS_DEV
        {
            /// <summary>
            /// 流媒体服务器配置
            /// </summary>
            public NET_DVR_DEV_DDNS_INFO struDdnsInfo;
            /// <summary>
            /// 解码通道信息
            /// </summary>
            public NET_DVR_STREAM_MEDIA_SERVER struMediaServer;
        }

        /// <summary>
        /// 取流模式配置联合体
        /// </summary>
        //取流模式配置联合体
        [StructLayout(LayoutKind.Explicit)]
        public struct NET_DVR_DEC_STREAM_MODE
        {
            /// <summary>
            /// 联合体大小
            /// </summary>
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 300, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MATRIX_DEC_CHAN_INFO_V41
        {
            public uint dwSize;
            /// <summary>
            /// 取流模式：0- 无效，1- 通过IP或域名取流，2- 通过URL取流，3- 通过动态域名解析向设备取流
            /// </summary>
            public byte byStreamMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 取流信息
            /// </summary>
            public NET_DVR_DEC_STREAM_MODE uDecStreamMode;
            /// <summary>
            /// 解码状态：0-动态解码，1－循环解码，2－按时间回放，3－按文件回放
            /// </summary>
            public uint dwPlayMode;
            /// <summary>
            /// 按时间回放开始时间
            /// </summary>
            public NET_DVR_TIME StartTime;
            /// <summary>
            /// 按时间回放停止时间
            /// </summary>
            public NET_DVR_TIME StopTime;
            /// <summary>
            /// 按文件回放文件名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string sFileName;
            /// <summary>
            /// 取流模式:1-主动，2-被动
            /// </summary>
            public uint dwGetStreamMode;
            public NET_DVR_MATRIX_PASSIVEMODE struPassiveMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        /// <summary>
        /// 支持的最大分辨率数目
        /// </summary>
        public const int MAX_RESOLUTIONNUM = 64;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_ABILITY
        {
            public uint dwSize;
            public byte byDecNums;
            public byte byStartChan;
            public byte byVGANums;
            public byte byBNCNums;
            /// <summary>
            /// VGA支持的窗口模式
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8 * 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byVGAWindowMode;
            /// <summary>
            /// BNC支持的窗口模式
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byBNCWindowMode;
            public byte byDspNums;
            /// <summary>
            /// HDMI显示通道个数（从25开始）
            /// </summary>
            public byte byHDMINums;
            /// <summary>
            /// DVI显示通道个数（从29开始）
            /// </summary>
            public byte byDVINums;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 13, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 按照上面的枚举定义,一个字节代表一个分辨率是//否支持，1：支持，0：不支持
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RESOLUTIONNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] bySupportResolution;
            /// <summary>
            /// HDMI支持的窗口模式
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4 * 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byHDMIWindowMode;
            /// <summary>
            /// DVI支持的窗口模式
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4 * 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byDVIWindowMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 上传logo结构
        /// </summary>
        //上传logo结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISP_LOGOCFG
        {
            /// <summary>
            /// 图片显示区域X坐标
            /// </summary>
            public uint dwCorordinateX;
            /// <summary>
            /// 图片显示区域Y坐标
            /// </summary>
            public uint dwCorordinateY;
            /// <summary>
            /// 图片宽
            /// </summary>
            public ushort wPicWidth;
            /// <summary>
            /// 图片高
            /// </summary>
            public ushort wPicHeight;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 是否闪烁1-闪烁，0-不闪烁
            /// </summary>
            public byte byFlash;
            /// <summary>
            /// 是否半透明1-半透明，0-不半透明
            /// </summary>
            public byte byTranslucent;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// LOGO大小，包括BMP的文件头
            /// </summary>
            public uint dwLogoSize;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PICTURECFG
        {
            /// <summary>
            /// 大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 1-底图，2-GIF图片，3-CAD图片 4-输出口图片
            /// </summary>
            public byte byUseType;
            /// <summary>
            /// 序号
            /// </summary>
            public byte bySequence;
            /// <summary>
            /// 图片叠加使能，是否在上传图片包含图片叠加参数 1-包含叠加参数，0-不包含
            /// </summary>
            public byte byOverlayEnabled;
            public byte byRes;
            public NET_DVR_BASEMAP_CFG struBasemapCfg;
            /// <summary>
            /// 图片名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPicName;
            /// <summary>
            /// 墙号（1字节墙号+1字节通道输出+2字节窗口号）
            /// </summary>
            public uint dwVideoWall;
            /// <summary>
            /// 图片闪烁使能，1-闪烁，0-不闪烁
            /// </summary>
            public byte byFlash;
            /// <summary>
            /// 图片半透明使能，1-半透明，0-不半透明
            /// </summary>
            public byte byTranslucent;
            /// <summary>
            /// 图片显示使能，1-显示，0-隐藏
            /// </summary>
            public byte byShowEnabled;
            /// <summary>
            /// 图片类型，1-bmp，2-jpg，3-png，……
            /// </summary>
            public byte byPictureType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_OUTPUT_PIC_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 图片序号
            /// </summary>
            public uint dwOutputPicNo;
            /// <summary>
            /// logo是否显示，1-显示，0-隐藏
            /// </summary>
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// logo位置，输出口范围总大小为1920*1920
            /// </summary>
            public NET_DVR_RECTCFG_EX struRect;
            /// <summary>
            /// 是否闪烁1-闪烁，0-不闪烁
            /// </summary>
            public byte byFlash;
            /// <summary>
            /// 是否半透明1-半透明，0-不半透明
            /// </summary>
            public byte byTranslucent;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 输出口图片窗口号（1字节设备号+1字节输出口号+2字节输出口图片窗口号）,获取全部时有效
            /// </summary>
            public uint dwOutputPicWinNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 28, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }
        /// <summary>
        /// 输出口OSD长度
        /// </summary>
        public const int MAX_OSD_LEN = 64;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_OUTPUT_OSD_CFG
        {
            public uint dwSize;
            /// <summary>
            /// OSD是否显示，0-不显示，1-显示
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 字体大小，1-大，2-中，3-小
            /// </summary>
            public byte byFontSize;
            /// <summary>
            /// OSD颜色配置，0-默认， 1-黑，2-白，3-红，4-绿，5-蓝
            /// </summary>
            public byte byOSDColor;
            public byte byRes1;
            /// <summary>
            /// OSD内容
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_OSD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byOsdContent;
            /// <summary>
            /// OSD位置，输出口范围总大小为1920*1920
            /// </summary>
            public NET_DVR_RECTCFG_EX struRect;
            /// <summary>
            /// 输出口OSD窗口号（1字节设备号+1字节输出口号+2字节OSD窗口号），获取所有时有效
            /// </summary>
            public uint dwOsdWinNo;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        /// <summary>
        /// 编码类型
        /// </summary>
        public const int NET_DVR_ENCODER_UNKOWN = 0;
        /// <summary>
        /// HIK 264
        /// </summary>
        public const int NET_DVR_ENCODER_H264 = 1;
        /// <summary>
        /// Standard H264
        /// </summary>
        public const int NET_DVR_ENCODER_S264 = 2;
        /// <summary>
        /// MPEG4
        /// </summary>
        public const int NET_DVR_ENCODER_MPEG4 = 3;
        /// <summary>
        /// Original Stream
        /// </summary>
        public const int NET_DVR_ORIGINALSTREAM = 4;
        /// <summary>
        /// *Picture*/
        /// </summary>
        public const int NET_DVR_PICTURE = 5;
        public const int NET_DVR_ENCODER_MJPEG = 6;
        public const int NET_DVR_ECONDER_MPEG2 = 7;
        /// <summary>
        /// 打包格式
        /// </summary>
        public const int NET_DVR_STREAM_TYPE_UNKOWN = 0;
        /// <summary>
        /// 海康自定义打包格式
        /// </summary>
        public const int NET_DVR_STREAM_TYPE_HIKPRIVT = 1;
        /// <summary>
        /// TS打包
        /// </summary>
        public const int NET_DVR_STREAM_TYPE_TS = 7;
        /// <summary>
        /// PS打包
        /// </summary>
        public const int NET_DVR_STREAM_TYPE_PS = 8;
        /// <summary>
        /// RTP打包
        /// </summary>
        public const int NET_DVR_STREAM_TYPE_RTP = 9;

        /// <summary>
        /// 解码通道状态
        /// </summary>
        /*解码通道状态*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_CHAN_STATUS
        {
            /// <summary>
            /// 当前状态:0:未启动，1：启动解码
            /// </summary>
            public byte byDecodeStatus;
            /// <summary>
            /// 码流类型
            /// </summary>
            public byte byStreamType;
            /// <summary>
            /// 打包方式
            /// </summary>
            public byte byPacketType;
            /// <summary>
            /// 接收缓冲使用率
            /// </summary>
            public byte byRecvBufUsage;
            /// <summary>
            /// 解码缓冲使用率
            /// </summary>
            public byte byDecBufUsage;
            /// <summary>
            /// 视频解码帧率
            /// </summary>
            public byte byFpsDecV;
            /// <summary>
            /// 音频解码帧率
            /// </summary>
            public byte byFpsDecA;
            /// <summary>
            /// DSP CPU使用率
            /// </summary>
            public byte byCpuLoad;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 解码的视频帧
            /// </summary>
            public uint dwDecodedV;
            /// <summary>
            /// 解码的音频帧
            /// </summary>
            public uint dwDecodedA;
            /// <summary>
            /// 解码器当前的图像大小,宽
            /// </summary>
            public ushort wImgW;
            /// <summary>
            /// 高
            /// </summary>
            public ushort wImgH;
            /// <summary>
            /// 视频制式:0-NON,NTSC--1,PAL--2
            /// </summary>
            public byte byVideoFormat;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 获取全部解码通道状态时有效，设置时可填0
            /// </summary>
            public uint dwDecChan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }
        /// <summary>
        /// 显示通道状态
        /// </summary>
        public const int NET_DVR_MAX_DISPREGION = 16;

        /// <summary>
        /// VGA分辨率，目前能用的是：VGA_THS8200_MODE_XGA_60HZ、VGA_THS8200_MODE_SXGA_60HZ、
        /// </summary>
        public enum VGA_MODE
        {
            /// <summary>
            /// VGA
            /// </summary>
            VGA_NOT_AVALIABLE,
            /// <summary>
            /// (800*600)
            /// </summary>
            VGA_THS8200_MODE_SVGA_60HZ,
            /// <summary>
            /// (800*600)
            /// </summary>
            VGA_THS8200_MODE_SVGA_75HZ,
            /// <summary>
            /// (1024*768)
            /// </summary>
            VGA_THS8200_MODE_XGA_60HZ,
            /// <summary>
            /// (1024*768)
            /// </summary>
            VGA_THS8200_MODE_XGA_75HZ,
            /// <summary>
            /// (1280*1024)
            /// </summary>
            VGA_THS8200_MODE_SXGA_60HZ,
            /// <summary>
            /// (1280*720)
            /// </summary>
            VGA_THS8200_MODE_720P_60HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            VGA_THS8200_MODE_1080I_60HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            VGA_THS8200_MODE_1080P_30HZ,
            /// <summary>
            /// (1600*1200)
            /// </summary>
            VGA_THS8200_MODE_UXGA_30HZ,
            /// <summary>
            /// HDMI
            /// </summary>
            HDMI_SII9134_MODE_XGA_60HZ,
            /// <summary>
            /// (1280*1024)
            /// </summary>
            HDMI_SII9134_MODE_SXGA_60HZ,
            /// <summary>
            /// (1280*960)
            /// </summary>
            HDMI_SII9134_MODE_SXGA2_60HZ,
            /// <summary>
            /// (1280*720)
            /// </summary>
            HDMI_SII9134_MODE_720P_60HZ,
            /// <summary>
            /// (1280*720)
            /// </summary>
            HDMI_SII9134_MODE_720P_50HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            HDMI_SII9134_MODE_1080I_60HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            HDMI_SII9134_MODE_1080I_50HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            HDMI_SII9134_MODE_1080P_25HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            HDMI_SII9134_MODE_1080P_30HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            HDMI_SII9134_MODE_1080P_50HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            HDMI_SII9134_MODE_1080P_60HZ,
            /// <summary>
            /// (1600*1200)
            /// </summary>
            HDMI_SII9134_MODE_UXGA_60HZ,
            /// <summary>
            /// DVI
            /// </summary>
            DVI_SII9134_MODE_XGA_60HZ,
            /// <summary>
            /// (1280*1024)
            /// </summary>
            DVI_SII9134_MODE_SXGA_60HZ,
            /// <summary>
            /// (1280*960)
            /// </summary>
            DVI_SII9134_MODE_SXGA2_60HZ,
            /// <summary>
            /// (1280*720)
            /// </summary>
            DVI_SII9134_MODE_720P_60HZ,
            /// <summary>
            /// (1280*720)
            /// </summary>
            DVI_SII9134_MODE_720P_50HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            DVI_SII9134_MODE_1080I_60HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            DVI_SII9134_MODE_1080I_50HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            DVI_SII9134_MODE_1080P_25HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            DVI_SII9134_MODE_1080P_30HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            DVI_SII9134_MODE_1080P_50HZ,
            /// <summary>
            /// (1920*1080)
            /// </summary>
            DVI_SII9134_MODE_1080P_60HZ,
            /// <summary>
            /// (1600*1200)
            /// </summary>
            DVI_SII9134_MODE_UXGA_60HZ,
            VGA_DECSVR_MODE_SXGA2_60HZ,
            HDMI_DECSVR_MODE_1080P_24HZ,
            DVI_DECSVR_MODE_1080P_24HZ,
            YPbPr_DECSVR_MODE_720P_60HZ,
            YPbPr_DECSVR_MODE_1080I_60HZ
        }
        /// <summary>
        /// 低帧率定义
        /// </summary>
        public const int LOW_DEC_FPS_1_2 = 51;
        public const int LOW_DEC_FPS_1_4 = 52;
        public const int LOW_DEC_FPS_1_8 = 53;
        public const int LOW_DEC_FPS_1_16 = 54;

        /// <summary>
        /// 视频制式标准
        /// </summary>
        public enum VIDEO_STANDARD
        {
            VS_NON = 0,
            VS_NTSC = 1,
            VS_PAL = 2
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct UNION_VIDEOPLATFORM
        {
            /// <summary>
            /// 各个子窗口对应解码通道所对应的解码子系统的槽位号(对于视频综合平台中解码子系统有效)
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS, ArraySubType = UnmanagedType.I1)]
            public byte[] byJoinDecoderId;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct UNION_NOTVIDEOPLATFORM
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VGA_DISP_CHAN_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 音频是否开启,0-否，1-是
            /// </summary>
            public byte byAudio;
            /// <summary>
            /// 音频开启子窗口
            /// </summary>
            public byte byAudioWindowIdx;
            /// <summary>
            /// VGA的分辨率
            /// </summary>
            public byte byVgaResolution;
            /// <summary>
            /// 视频制式，1:NTSC,2:PAL,0-NON
            /// </summary>
            public byte byVedioFormat;
            /// <summary>
            /// 画面模式，从能力集里获取，目前支持1,2,4,9,16
            /// </summary>
            public uint dwWindowMode;
            /// <summary>
            /// 各个子窗口关联的解码通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS, ArraySubType = UnmanagedType.I1)]
            public byte[] byJoinDecChan;
            /// <summary>
            /// 是否处于放大状态，0：不放大，1：放大
            /// </summary>
            public byte byEnlargeStatus;
            /// <summary>
            /// 放大的子窗口号
            /// </summary>
            public byte byEnlargeSubWindowIndex;
            /// <summary>
            /// 区分共用体，0-视频综合平台内部解码器显示通道配置，1-其他解码器显示通道配置
            /// </summary>
            public byte byUnionType;
            /// <summary>
            /// 显示模式，0---真实显示，1---缩放显示( 针对BNC )
            /// </summary>
            public byte byScale;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISP_CHAN_STATUS
        {
            /// <summary>
            /// 显示状态：0：未显示，1：启动显示
            /// </summary>
            public byte byDispStatus;
            /// <summary>
            /// VGA/BNC
            /// </summary>
            public byte byBVGA;
            /// <summary>
            /// 视频制式:1:NTSC,2:PAL,0-NON
            /// </summary>
            public byte byVideoFormat;
            /// <summary>
            /// 当前画面模式
            /// </summary>
            public byte byWindowMode;
            /// <summary>
            /// 各个子窗口关联的解码通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS, ArraySubType = UnmanagedType.I1)]
            public byte[] byJoinDecChan;
            /// <summary>
            /// 每个子画面的显示帧率
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_DVR_MAX_DISPREGION, ArraySubType = UnmanagedType.I1)]
            public byte[] byFpsDisp;
            /// <summary>
            /// 屏幕模式0-普通 1-大屏
            /// </summary>
            public byte byScreenMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 31, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        /// <summary>
        /// 多路解码器最大解码通道数
        /// </summary>
        public const int MAX_DECODECHANNUM = 32;
        /// <summary>
        /// 多路解码器最大显示通道数
        /// </summary>
        public const int MAX_DISPCHANNUM = 24;

        /// <summary>
        /// 解码器设备状态
        /// </summary>
        /*解码器设备状态*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DECODER_WORK_STATUS
        {
            public uint dwSize;
            /// <summary>
            /// 解码通道状态
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DECODECHANNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_MATRIX_CHAN_STATUS[] struDecChanStatus;
            /// <summary>
            /// 显示通道状态
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DISPCHANNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_DISP_CHAN_STATUS[] struDispChanStatus;
            /// <summary>
            /// 报警输入状态
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ANALOG_ALARMIN, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmInStatus;
            /// <summary>
            /// 报警输出状态
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ANALOG_ALARMOUT, ArraySubType = UnmanagedType.I1)]
            public byte[] byAalarmOutStatus;
            /// <summary>
            /// 语音对讲状态
            /// </summary>
            public byte byAudioInChanStatus;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 127, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 2009-12-1 增加被动解码播放控制
        /// </summary>
        //2009-12-1 增加被动解码播放控制
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PASSIVEDECODE_CONTROL
        {
            public uint dwSize;
            /// <summary>
            /// 播放命令 见文件播放命令
            /// </summary>
            public uint dwPlayCmd;
            /// <summary>
            /// 播放命令参数
            /// </summary>
            public uint dwCmdParam;
            /// <summary>
            /// Reverse
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 被动解码暂停(仅文件流有效)
        /// </summary>
        public const int PASSIVE_DEC_PAUSE = 1;
        /// <summary>
        /// 恢复被动解码(仅文件流有效)
        /// </summary>
        public const int PASSIVE_DEC_RESUME = 2;
        /// <summary>
        /// 快速被动解码(仅文件流有效)
        /// </summary>
        public const int PASSIVE_DEC_FAST = 3;
        /// <summary>
        /// 慢速被动解码(仅文件流有效)
        /// </summary>
        public const int PASSIVE_DEC_SLOW = 4;
        /// <summary>
        /// 正常被动解码(仅文件流有效)
        /// </summary>
        public const int PASSIVE_DEC_NORMAL = 5;
        /// <summary>
        /// 被动解码单帧播放(保留)
        /// </summary>
        public const int PASSIVE_DEC_ONEBYONE = 6;
        /// <summary>
        /// 音频开启
        /// </summary>
        public const int PASSIVE_DEC_AUDIO_ON = 7;
        /// <summary>
        /// 音频关闭
        /// </summary>
        public const int PASSIVE_DEC_AUDIO_OFF = 8;
        /// <summary>
        /// 清空缓冲区
        /// </summary>
        public const int PASSIVE_DEC_RESETBUFFER = 9;

        /// <summary>
        /// 2009-12-16 增加控制解码器解码通道缩放
        /// </summary>
        //2009-12-16 增加控制解码器解码通道缩放
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_DECCHAN_CONTROL
        {
            public uint dwSize;
            /// <summary>
            /// 解码通道显示缩放控制,1表示缩放显示，0表示真实显示
            /// </summary>
            public byte byDecChanScaleStatus;
            /// <summary>
            /// 解码延时，0-默认，1-实时性好，2-实时性较好，3-实时性中，流畅性中，4-流畅性较好，5-流畅性好，0xff-自动调整
            /// </summary>
            public byte byDecodeDelay;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 66, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// **********************************多路解码器(end)**************************************
        /// **********************************视频综合平台(begin)**************************************
        /// </summary>
        public const int MAX_SUBSYSTEM_NUM = 80;
        /// <summary>
        /// 一个矩阵系统中最多子系统数量
        /// </summary>
        public const int MAX_SUBSYSTEM_NUM_V40 = 120;
        /// <summary>
        /// 最大序列号长度
        /// </summary>
        public const int MAX_SERIALLEN = 36;
        /// <summary>
        /// 最大计划切换组
        /// </summary>
        public const int MAX_LOOPPLANNUM = 16;
        /// <summary>
        /// 计划解码每天时间段数
        /// </summary>
        public const int DECODE_TIMESEGMENT = 4;
        /// <summary>
        /// 最大域名长度
        /// </summary>
        public const int MAX_DOMAIN_NAME = 64;
        /// <summary>
        /// 9000设备最大硬盘数/* 最多33个硬盘(包括16个内置SATA硬盘、1个eSATA硬盘和16个NFS盘) */
        /// </summary>
        public const int MAX_DISKNUM_V30 = 33;
        /// <summary>
        /// 每周天数
        /// </summary>
        public const int MAX_DAYS = 7;
        public const int MAX_DISPNUM_V41 = 32;
        public const int MAX_WINDOWS_NUM = 12;
        public const int MAX_VOUTNUM = 32;
        public const int MAX_SUPPORT_RES = 32;
        public const int MAX_BIGSCREENNUM = 100;
        /// <summary>
        /// 视频综合平台能力集
        /// </summary>
        public const int VIDEOPLATFORM_ABILITY = 0x210;
        /// <summary>
        /// 解码器能力集
        /// </summary>
        public const int MATRIXDECODER_ABILITY_V41 = 0x260;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SUBSYSTEMINFO
        {
            /// <summary>
            /// 子系统类型，1-解码用子系统，2-编码用子系统，0-NULL（此参数只能获取）
            /// </summary>
            public byte bySubSystemType;
            /// <summary>
            /// 子系统通道数（此参数只能获取）
            /// </summary>
            public byte byChan;
            /// <summary>
            /// 注册类型，1-直连，2-DNS，3-花生壳
            /// </summary>
            public byte byLoginType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// IP地址（可修改）
            /// </summary>
            public NET_DVR_IPADDR struSubSystemIP;
            /// <summary>
            /// 子系统端口号（可修改）
            /// </summary>
            public ushort wSubSystemPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 子网掩码
            /// </summary>
            public NET_DVR_IPADDR struSubSystemIPMask;
            /// <summary>
            /// 网关地址
            /// </summary>
            public NET_DVR_IPADDR struGatewayIpAddr;
            /// <summary>
            /// 用户名 （此参数只能获取）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码（此参数只能获取）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 域名(可修改)
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = MAX_DOMAIN_NAME)]
            public string sDomainName;
            /// <summary>
            /// DNS域名或IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = MAX_DOMAIN_NAME)]
            public string sDnsAddress;
            /// <summary>
            /// 序列号（此参数只能获取）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SERIALNO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sSerialNumber;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALLSUBSYSTEMINFO
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SUBSYSTEM_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SUBSYSTEMINFO[] struSubSystemInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LOOPPLAN_SUBCFG
        {
            public uint dwSize;
            /// <summary>
            /// 轮询间隔，单位：秒
            /// </summary>
            public uint dwPoolTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CYCLE_CHAN_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_MATRIX_CHAN_INFO_V30[] struChanConInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMMODECFG
        {
            public uint dwSize;
            /// <summary>
            /// 报警触发类型，1-轮询，2-保持
            /// </summary>
            public byte byAlarmMode;
            /// <summary>
            /// 轮询时间, 单位：秒
            /// </summary>
            public ushort wLoopTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 9, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CODESPLITTERINFO
        {
            public uint dwSize;
            /// <summary>
            /// 码分器IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// 码分器端口号
            /// </summary>
            public ushort wPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 码分器485号
            /// </summary>
            public byte byChan;
            /// <summary>
            /// 485口地址
            /// </summary>
            public byte by485Port;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 14, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ASSOCIATECFG
        {
            /// <summary>
            /// 关联类型，1-报警
            /// </summary>
            public byte byAssociateType;
            /// <summary>
            /// 报警延时，0－5秒；1－10秒；2－30秒；3－1分钟；4－2分钟；5－5分钟；6－10分钟；
            /// </summary>
            public ushort wAlarmDelay;
            /// <summary>
            /// 报警号，具体的值由应用赋，相同的报警赋相同的值
            /// </summary>
            public byte byAlarmNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DYNAMICDECODE
        {
            public uint dwSize;
            /// <summary>
            /// 触发动态解码关联结构
            /// </summary>
            public NET_DVR_ASSOCIATECFG struAssociateCfg;
            /// <summary>
            /// 动态解码结构
            /// </summary>
            public NET_DVR_PU_STREAM_CFG struPuStreamCfg;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DECODESCHED
        {
            public NET_DVR_SCHEDTIME struSchedTime;
            /// <summary>
            /// 0-无，1-轮询解码，2-动态解码
            /// </summary>
            public byte byDecodeType;
            /// <summary>
            /// 轮询组号
            /// </summary>
            public byte byLoopGroup;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 动态解码
            /// </summary>
            public NET_DVR_PU_STREAM_CFG struDynamicDec;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLANDECODE
        {
            public uint dwSize;
            /// <summary>
            /// 周一作为开始，和9000一致
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * DECODE_TIMESEGMENT, ArraySubType = UnmanagedType.I1)]
            public NET_DVR_DECODESCHED[] struDecodeSched;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byres;
        }

        /// <summary>
        /// **********************************视频综合平台(end)**************************************
        /// </summary>
        /************************************视频综合平台(end)***************************************/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VIDEOPLATFORM_ABILITY
        {
            public uint dwSize;
            /// <summary>
            /// 编码子系统数量
            /// </summary>
            public byte byCodeSubSystemNums;
            /// <summary>
            /// 解码子系统数量
            /// </summary>
            public byte byDecodeSubSystemNums;
            /// <summary>
            /// 显示通道支持的窗口模式
            /// </summary>
            [System.Runtime.InteropServices.MarshalAsAttribute(System.Runtime.InteropServices.UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = System.Runtime.InteropServices.UnmanagedType.I1)]
            public byte[] byWindowMode;
            [System.Runtime.InteropServices.MarshalAsAttribute(System.Runtime.InteropServices.UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = System.Runtime.InteropServices.UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SUBSYSTEM_ABILITY
        {
            /// <summary>
            /// 子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，9-V6子系统，0-NULL（此参数只能获取）
            /// </summary>
            public byte bySubSystemType;
            /// <summary>
            /// 子系统通道数
            /// </summary>
            public byte byChanNum;
            /// <summary>
            /// 子系统起始通道数
            /// </summary>
            public byte byStartChan;
            /// <summary>
            /// 槽位号
            /// </summary>
            public byte bySlotNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public struDecoderSystemAbility _struAbility;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct struDecoderSystemAbility
        {
            /// <summary>
            /// VGA显示通道个数（从1开始）
            /// </summary>
            public byte byVGANums;
            /// <summary>
            /// BNC显示通道个数（从9开始）
            /// </summary>
            public byte byBNCNums;
            /// <summary>
            /// HDMI显示通道个数（从25开始）
            /// </summary>
            public byte byHDMINums;
            /// <summary>
            /// DVI显示通道个数（从29开始）
            /// </summary>
            public byte byDVINums;
            /// <summary>
            /// 大屏拼接中，做主屏时所支持图层数
            /// </summary>
            public byte byLayerNums;
            /// <summary>
            /// 畅显功能，0-不支持，1-支持
            /// </summary>
            public byte bySpartan;
            /// <summary>
            /// 解码子系统类型，0-普通型,1-增强型(普通型分屏时前4窗口需使用自身资源，增强型无此限制，增强型最多可被其他子系统借16路D1解码资源
            /// </summary>
            public byte byDecType;
            /// <summary>
            /// 增强型被大屏关联为子屏后资源可被借用，普通型则不能被借用)
            /// </summary>
            public byte byOutputSwitch;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 39, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 解码板类型  0-普通解码板 1-解码板
            /// </summary>
            public byte byDecoderType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 152, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct struAbility
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 200, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VIDEOPLATFORM_ABILITY_V40
        {
            public uint dwSize;
            public byte byCodeSubSystemNums;
            /// <summary>
            /// 解码子系统数量
            /// </summary>
            public byte byDecodeSubSystemNums;
            /// <summary>
            /// 是否支持NAT，0-不支持，1-支持
            /// </summary>
            public byte bySupportNat;
            /// <summary>
            /// 级联输入子系统数量
            /// </summary>
            public byte byInputSubSystemNums;
            /// <summary>
            /// 级联输出子系统数量
            /// </summary>
            public byte byOutputSubSystemNums;
            /// <summary>
            /// 码分子系统数量
            /// </summary>
            public byte byCodeSpitterSubSystemNums;
            /// <summary>
            /// 报警子系统数量
            /// </summary>
            public byte byAlarmHostSubSystemNums;
            /// <summary>
            /// 所支持最多组成大屏的个数
            /// </summary>
            public byte bySupportBigScreenNum;
            /// <summary>
            /// 智能子系统数量
            /// </summary>
            public byte byVCASubSystemNums;
            /// <summary>
            /// V6子系统数量
            /// </summary>
            public byte byV6SubSystemNums;
            /// <summary>
            /// V6解码子系统数量
            /// </summary>
            public byte byV6DecoderSubSystemNums;
            /// <summary>
            /// 大屏拼接的模式：m×n
            /// </summary>
            public byte bySupportBigScreenX;
            public byte bySupportBigScreenY;
            /// <summary>
            /// 支持场景模式的个数
            /// </summary>
            public byte bySupportSceneNums;
            /// <summary>
            /// 智能支持的通道使用模式，0-使用解码通道，1-使用显示通道及子通道号
            /// </summary>
            public byte byVcaSupportChanMode;
            /// <summary>
            /// 所支持的大屏的屏幕最大个数
            /// </summary>
            public byte bySupportScreenNums;
            /// <summary>
            /// 所支持的图层数，0xff-无效
            /// </summary>
            public byte bySupportLayerNums;
            /// <summary>
            /// 是否支持预览,1-不支持，0-支持
            /// </summary>
            public byte byNotSupportPreview;
            /// <summary>
            /// 是否支持存储,1-不支持，0-支持
            /// </summary>
            public byte byNotSupportStorage;
            /// <summary>
            /// 上传logo模式，0-上传给解码通道，1-上传给显示通道
            /// </summary>
            public byte byUploadLogoMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SUBSYSTEM_NUM_V40, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SUBSYSTEM_ABILITY[] struSubSystemAbility;
            /// <summary>
            /// 485串口个数
            /// </summary>
            public byte by485Nums;
            /// <summary>
            /// 232串口个数
            /// </summary>
            public byte by232Nums;
            /// <summary>
            /// 起始通道
            /// </summary>
            public byte bySerieStartChan;
            /// <summary>
            /// 大屏模式，0-主屏由客户端分配，1-主屏由设备端分配
            /// </summary>
            public byte byScreenMode;
            /// <summary>
            /// 设备版本，0-B10/B11/B12，1-B20
            /// </summary>
            public byte byDevVersion;
            /// <summary>
            /// 所支持的底图数，底图号从1开始
            /// </summary>
            public byte bySupportBaseMapNums;
            /// <summary>
            /// 每个屏大小的基准值，B20使用
            /// </summary>
            public ushort wBaseLengthX;
            public ushort wBaseLengthY;
            /// <summary>
            /// 是否支持图片回显，0-不支持，1-支持
            /// </summary>
            public byte bySupportPictureTrans;
            /// <summary>
            /// 是否支持智能解码资源预分配，0-不支持，1-支持
            /// </summary>
            public byte bySupportPreAllocDec;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 628, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SINGLESCREENCFG
        {
            /// <summary>
            /// 屏幕序号，0xff表示不用此屏,64-T解码器第一个表示主屏
            /// </summary>
            public byte byScreenSeq;
            /// <summary>
            /// 解码子系统槽位号,解码器此值没有用
            /// </summary>
            public byte bySubSystemNum;
            /// <summary>
            /// 解码子系统上对应显示通道号，64-T解码器中该值表示解码器的显示通道号
            /// </summary>
            public byte byDispNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 9, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_BIGSCREENCFG
        {
            public uint dwSize;
            /// <summary>
            /// 大屏拼接使能，0-不使能，1-使能
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 大屏拼接模式
            /// </summary>
            public byte byModeX;
            public byte byModeY;
            /// <summary>
            /// 综合平台的解码板中该值表示主屏槽位号，64-T解码器中该值表示解码通道号
            /// </summary>
            public byte byMainDecodeSystem;
            /// <summary>
            /// 主屏所用显示通道号，1.1netra版本新增，netra解码器有两个显示通道，都能够作为主屏。64-T中该值无效
            /// </summary>
            public byte byMainDecoderDispChan;
            /// <summary>
            /// 大屏每个子屏制式相同 1:NTSC,2:PAL
            /// </summary>
            public byte byVideoStandard;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 大屏每个子屏分辨率相同
            /// </summary>
            public uint dwResolution;
            /// <summary>
            /// 大屏拼接从屏幕信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_BIGSCREENNUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SINGLESCREENCFG[] struFollowSingleScreen;
            /// <summary>
            /// 起始坐标必须为基准坐标的整数倍
            /// </summary>
            public ushort wBigScreenX;
            /// <summary>
            /// 大屏在电视墙中起始Y坐标
            /// </summary>
            public ushort wBigScreenY;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// **********************************视频综合平台(end)**************************************
        /// </summary>
        /************************************视频综合平台(end)***************************************/

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_EMAILCFG
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string sUserName;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string sPassWord;
            /// <summary>
            /// 字符串中的第一个字符和最后一个字符不能是"@",并且字符串中要有"@"字符
            /// Sender
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string sFromName;
            /// <summary>
            /// Sender address
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 48)]
            public string sFromAddr;
            /// <summary>
            /// Receiver1
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string sToName1;
            /// <summary>
            /// Receiver2
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string sToName2;
            /// <summary>
            /// Receiver address1
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 48)]
            public string sToAddr1;
            /// <summary>
            /// Receiver address2
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 48)]
            public string sToAddr2;
            /// <summary>
            /// Email server address
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string sEmailServer;
            /// <summary>
            /// Email server type: 0-SMTP, 1-POP, 2-IMTP…
            /// </summary>
            public byte byServerType;
            /// <summary>
            /// Email server authentication method: 1-enable, 0-disable
            /// </summary>
            public byte byUseAuthen;
            /// <summary>
            /// enable attachment
            /// </summary>
            public byte byAttachment;
            /// <summary>
            /// mail interval 0-2s, 1-3s, 2-4s. 3-5s
            /// </summary>
            public byte byMailinterval;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_COMPRESSIONCFG_NEW
        {
            public uint dwSize;
            /// <summary>
            /// 定时录像
            /// </summary>
            public NET_DVR_COMPRESSION_INFO_EX struLowCompression;
            /// <summary>
            /// 事件触发录像
            /// </summary>
            public NET_DVR_COMPRESSION_INFO_EX struEventCompression;
        }

        /// <summary>
        /// 云台预置点信息
        /// </summary>
        //云台预置点信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PRESET_NAME
        {
            public uint dwSize;
            public ushort wPresetNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byName;
            public ushort wPanPos;
            public ushort wTiltPos;
            public ushort wZoomPos;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 58, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 球机位置信息
        /// </summary>
        //球机位置信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PTZPOS
        {
            /// <summary>
            /// 获取时该字段无效
            /// </summary>
            public ushort wAction;
            /// <summary>
            /// 水平参数
            /// </summary>
            public ushort wPanPos;
            /// <summary>
            /// 垂直参数
            /// </summary>
            public ushort wTiltPos;
            /// <summary>
            /// 变倍参数
            /// </summary>
            public ushort wZoomPos;
        }

        /// <summary>
        /// 球机范围信息
        /// </summary>
        //球机范围信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PTZSCOPE
        {
            /// <summary>
            /// 水平参数min
            /// </summary>
            public ushort wPanPosMin;
            /// <summary>
            /// 水平参数max
            /// </summary>
            public ushort wPanPosMax;
            /// <summary>
            /// 垂直参数min
            /// </summary>
            public ushort wTiltPosMin;
            /// <summary>
            /// 垂直参数max
            /// </summary>
            public ushort wTiltPosMax;
            /// <summary>
            /// 变倍参数min
            /// </summary>
            public ushort wZoomPosMin;
            /// <summary>
            /// 变倍参数max
            /// </summary>
            public ushort wZoomPosMax;
        }

        /// <summary>
        /// rtsp配置 ipcamera专用
        /// </summary>
        //rtsp配置 ipcamera专用
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RTSPCFG
        {
            /// <summary>
            /// 长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// rtsp服务器侦听端口
            /// </summary>
            public ushort wPort;
            /// <summary>
            /// 预留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 54, ArraySubType = UnmanagedType.I1)]
            public byte[] byReserve;
        }

        /// <summary>
        /// ******************************接口参数结构(begin)********************************
        /// NET_DVR_Login()参数结构
        /// </summary>
        /********************************接口参数结构(begin)*********************************/

        //NET_DVR_Login()参数结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEVICEINFO
        {
            /// <summary>
            /// 序列号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SERIALNO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sSerialNumber;
            /// <summary>
            /// DVR报警输入个数
            /// </summary>
            public byte byAlarmInPortNum;
            /// <summary>
            /// DVR报警输出个数
            /// </summary>
            public byte byAlarmOutPortNum;
            /// <summary>
            /// DVR硬盘个数
            /// </summary>
            public byte byDiskNum;
            /// <summary>
            /// DVR类型, 1:DVR 2:ATM DVR 3:DVS ......
            /// </summary>
            public byte byDVRType;
            /// <summary>
            /// DVR 通道个数
            /// </summary>
            public byte byChanNum;
            /// <summary>
            /// 起始通道号,例如DVS-1,DVR - 1
            /// </summary>
            public byte byStartChan;
        }

        /// <summary>
        /// NET_DVR_Login_V30()参数结构
        /// </summary>
        //NET_DVR_Login_V30()参数结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEVICEINFO_V30
        {
            /// <summary>
            /// 序列号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SERIALNO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sSerialNumber;
            /// <summary>
            /// 报警输入个数
            /// </summary>
            public byte byAlarmInPortNum;
            /// <summary>
            /// 报警输出个数
            /// </summary>
            public byte byAlarmOutPortNum;
            /// <summary>
            /// 硬盘个数
            /// </summary>
            public byte byDiskNum;
            /// <summary>
            /// 设备类型, 1:DVR 2:ATM DVR 3:DVS ......
            /// </summary>
            public byte byDVRType;
            /// <summary>
            /// 模拟通道个数
            /// </summary>
            public byte byChanNum;
            /// <summary>
            /// 起始通道号,例如DVS-1,DVR - 1
            /// </summary>
            public byte byStartChan;
            /// <summary>
            /// 语音通道数
            /// </summary>
            public byte byAudioChanNum;
            /// <summary>
            /// 最大数字通道个数，低位
            /// </summary>
            public byte byIPChanNum;
            /// <summary>
            /// 零通道编码个数 //2010-01-16
            /// </summary>
            public byte byZeroChanNum;
            /// <summary>
            /// 主码流传输协议类型 0-private, 1-rtsp,2-同时支持private和rtsp
            /// </summary>
            public byte byMainProto;
            /// <summary>
            /// 子码流传输协议类型0-private, 1-rtsp,2-同时支持private和rtsp
            /// </summary>
            public byte bySubProto;
            /// <summary>
            /// 能力，位与结果为0表示不支持，1表示支持，
            /// </summary>
            public byte bySupport;
            /// <summary>
            /// bySupport & 0x1, 表示是否支持智能搜索
            /// bySupport & 0x2, 表示是否支持备份
            /// bySupport & 0x4, 表示是否支持压缩参数能力获取
            /// bySupport & 0x8, 表示是否支持多网卡
            /// bySupport & 0x10, 表示支持远程SADP
            /// bySupport & 0x20, 表示支持Raid卡功能
            /// bySupport & 0x40, 表示支持IPSAN 目录查找
            /// bySupport & 0x80, 表示支持rtp over rtsp
            /// </summary>
            public byte bySupport1;
            /// <summary>
            /// bySupport1 & 0x1, 表示是否支持snmp v30
            /// bySupport1 & 0x2, 支持区分回放和下载
            /// bySupport1 & 0x4, 是否支持布防优先级
            /// bySupport1 & 0x8, 智能设备是否支持布防时间段扩展
            /// bySupport1 & 0x10, 表示是否支持多磁盘数（超过33个）
            /// bySupport1 & 0x20, 表示是否支持rtsp over http
            /// bySupport1 & 0x80, 表示是否支持车牌新报警信息2012-9-28, 且还表示是否支持NET_DVR_IPPARACFG_V40结构体
            /// </summary>
            public byte bySupport2;
            /// <summary>
            /// 设备型号
            /// </summary>
            public ushort wDevType;
            /// <summary>
            /// 能力集扩展，位与结果为0表示不支持，1表示支持
            /// </summary>
            public byte bySupport3;
            /// <summary>
            /// bySupport3 & 0x1, 表示是否多码流
            /// bySupport3 & 0x4 表示支持按组配置， 具体包含 通道图像参数、报警输入参数、IP报警输入、输出接入参数、
            /// 用户参数、设备工作状态、JPEG抓图、定时和时间抓图、硬盘盘组管理
            /// bySupport3 & 0x8为1 表示支持使用TCP预览、UDP预览、多播预览中的"延时预览"字段来请求延时预览（后续都将使用这种方式请求延时预览）。而当bySupport3 & 0x8为0时，将使用 "私有延时预览"协议。
            /// bySupport3 & 0x10 表示支持"获取报警主机主要状态（V40）"。
            /// bySupport3 & 0x20 表示是否支持通过DDNS域名解析取流
            /// </summary>
            public byte byMultiStreamProto;
            /// <summary>
            /// 起始数字通道号,0表示无效
            /// </summary>
            public byte byStartDChan;
            /// <summary>
            /// 起始数字对讲通道号，区别于模拟对讲通道号，0表示无效
            /// </summary>
            public byte byStartDTalkChan;
            /// <summary>
            /// 数字通道个数，高位
            /// </summary>
            public byte byHighDChanNum;
            public byte bySupport4;
            /// <summary>
            /// 支持语种能力,按位表示,每一位0-不支持,1-支持
            /// </summary>
            public byte byLanguageType;
            /// <summary>
            /// byLanguageType 等于0 表示 老设备
            /// byLanguageType & 0x1表示支持中文
            /// byLanguageType & 0x2表示支持英文
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 9, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct NET_DVR_DEVICEINFO_V40
        {
            public NET_DVR_DEVICEINFO_V30 struDeviceV30;
            /// <summary>
            /// 设备支持锁定功能，该字段由SDK根据设备返回值来赋值的。bySupportLock为1时，dwSurplusLockTime和byRetryLoginTime有效
            /// </summary>
            public byte bySupportLock;
            /// <summary>
            /// 剩余可尝试登陆的次数，用户名，密码错误时，此参数有效
            /// </summary>
            public byte byRetryLoginTime;
            /// <summary>
            /// admin密码安全等级0-无效，1-默认密码，2-有效密码,3-风险较高的密码。当用户的密码为出厂默认密码（12345）或者风险较高的密码时，上层客户端需要提示用户更改密码。
            /// </summary>
            public byte byPasswordLevel;
            /// <summary>
            /// 代理类型，0-不使用代理, 1-使用socks5代理, 2-使用EHome代理
            /// </summary>
            public byte byProxyType;
            /// <summary>
            /// 剩余时间，单位秒，用户锁定时，此参数有效
            /// </summary>
            public uint dwSurplusLockTime;
            /// <summary>
            /// 字符编码类型（SDK所有接口返回的字符串编码类型，透传接口除外）：0- 无字符编码信息(老设备)，1- GB2312(简体中文)，2- GBK，3- BIG5(繁体中文)，4- Shift_JIS(日文)，5- EUC-KR(韩文)，6- UTF-8，7- ISO8859-1，8- ISO8859-2，9- ISO8859-3，…，依次类推，21- ISO8859-15(西欧)
            /// </summary>
            public byte byCharEncodeType;
            /// <summary>
            /// 支持v50版本的设备参数获取，设备名称和设备类型名称长度扩展为64字节
            /// </summary>
            public byte bySupportDev5;
            /// <summary>
            /// 能力集扩展，位与结果：0- 不支持，1- 支持
            /// </summary>
            public byte bySupport;
            /// <summary>
            /// bySupport & 0x1:  保留
            /// bySupport & 0x2:  0-不支持变化上报 1-支持变化上报
            /// </summary>
            public byte byLoginMode;
            public int dwOEMCode;
            /// <summary>
            /// 该用户密码剩余有效天数，单位：天，返回负值，表示密码已经超期使用，例如“-3表示密码已经超期使用3天”
            /// </summary>
            public int iResidualValidity;
            /// <summary>
            /// iResidualValidity字段是否有效，0-无效，1-有效
            /// </summary>
            public byte byResidualValidity;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 243, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        public const int NET_DVR_DEV_ADDRESS_MAX_LEN = 129;
        public const int NET_DVR_LOGIN_USERNAME_MAX_LEN = 64;
        public const int NET_DVR_LOGIN_PASSWD_MAX_LEN = 64;

        public delegate void LOGINRESULTCALLBACK(int lUserID, int dwResult, IntPtr lpDeviceInfo, IntPtr pUser);

        [StructLayout(LayoutKind.Sequential)]
        public struct NET_DVR_USER_LOGIN_INFO
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_DVR_DEV_ADDRESS_MAX_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sDeviceAddress;
            public byte byUseTransport;
            public ushort wPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_DVR_LOGIN_USERNAME_MAX_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_DVR_LOGIN_PASSWD_MAX_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            public LOGINRESULTCALLBACK cbLoginResult;
            public IntPtr pUser;
            public bool bUseAsynLogin;
            /// <summary>
            /// 0:不使用代理，1：使用标准代理，2：使用EHome代理
            /// </summary>
            public byte byProxyType;
            /// <summary>
            /// 0-不进行转换，默认,1-接口上输入输出全部使用UTC时间,SDK完成UTC时间与设备时区的转换,2-接口上输入输出全部使用平台本地时间，SDK完成平台本地时间与设备时区的转换
            /// </summary>
            public byte byUseUTCTime;
            /// <summary>
            /// 0-Private, 1-ISAPI, 2-自适应
            /// </summary>
            public byte byLoginMode;
            /// <summary>
            /// 0-不适用tls，1-使用tls 2-自适应
            /// </summary>
            public byte byHttps;
            /// <summary>
            /// 代理服务器序号，添加代理服务器信息时，相对应的服务器数组下表值
            /// </summary>
            public int iProxyID;
            /// <summary>
            /// 认证方式，0-不认证，1-双向认证，2-单向认证；认证仅在使用TLS的时候生效;
            /// </summary>
            public byte byVerifyMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 119, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }

        /// <summary>
        /// sdk网络环境枚举变量，用于远程升级
        /// </summary>
        public enum SDK_NETWORK_ENVIRONMENT
        {
            LOCAL_AREA_NETWORK = 0,
            WIDE_AREA_NETWORK
        }

        /// <summary>
        /// 显示模式
        /// </summary>
        public enum DISPLAY_MODE
        {
            NORMALMODE = 0,
            OVERLAYMODE
        }

        /// <summary>
        /// 发送模式
        /// </summary>
        public enum SEND_MODE
        {
            PTOPTCPMODE = 0,
            PTOPUDPMODE,
            MULTIMODE,
            RTPMODE,
            RESERVEDMODE
        }

        /// <summary>
        /// 抓图模式
        /// </summary>
        public enum CAPTURE_MODE
        {
            /// <summary>
            /// BMP模式
            /// </summary>
            BMP_MODE = 0,
            /// <summary>
            /// JPEG模式
            /// </summary>
            JPEG_MODE = 1
        }

        /// <summary>
        /// 实时声音模式
        /// </summary>
        public enum REALSOUND_MODE
        {
            /// <summary>
            /// 独占模式
            /// </summary>
            MONOPOLIZE_MODE = 1,
            /// <summary>
            /// 共享模式
            /// </summary>
            SHARE_MODE = 2
        }

        public struct NET_DVR_CLIENTINFO
        {
            /// <summary>
            /// 通道号
            /// </summary>
            public Int32 lChannel;
            /// <summary>
            /// 最高位(31)为0表示主码流，为1表示子码流，0－30位表示码流连接方式: 0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-音视频分开(TCP)
            /// </summary>
            public Int32 lLinkMode;
            /// <summary>
            /// 播放窗口的句柄,为NULL表示不播放图象
            /// </summary>
            public IntPtr hPlayWnd;
            /// <summary>
            /// 多播组地址
            /// </summary>
            public string sMultiCastIP;
        }

        /// <summary>
        /// SDK状态信息(9000新增)
        /// </summary>
        //SDK状态信息(9000新增)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SDKSTATE
        {
            /// <summary>
            /// 当前login用户数
            /// </summary>
            public uint dwTotalLoginNum;
            /// <summary>
            /// 当前realplay路数
            /// </summary>
            public uint dwTotalRealPlayNum;
            /// <summary>
            /// 当前回放或下载路数
            /// </summary>
            public uint dwTotalPlayBackNum;
            /// <summary>
            /// 当前建立报警通道路数
            /// </summary>
            public uint dwTotalAlarmChanNum;
            /// <summary>
            /// 当前硬盘格式化路数
            /// </summary>
            public uint dwTotalFormatNum;
            /// <summary>
            /// 当前日志或文件搜索路数
            /// </summary>
            public uint dwTotalFileSearchNum;
            /// <summary>
            /// 当前日志或文件搜索路数
            /// </summary>
            public uint dwTotalLogSearchNum;
            /// <summary>
            /// 当前透明通道路数
            /// </summary>
            public uint dwTotalSerialNum;
            /// <summary>
            /// 当前升级路数
            /// </summary>
            public uint dwTotalUpgradeNum;
            /// <summary>
            /// 当前语音转发路数
            /// </summary>
            public uint dwTotalVoiceComNum;
            /// <summary>
            /// 当前语音广播路数
            /// </summary>
            public uint dwTotalBroadCastNum;
            /// <summary>
            /// 当前网络监听路数
            /// </summary>
            public uint dwTotalListenNum;
            /// <summary>
            /// 当前邮件计数路数
            /// </summary>
            public uint dwEmailTestNum;
            /// <summary>
            /// 当前文件备份路数
            /// </summary>
            public uint dwBackupNum;
            /// <summary>
            /// 当前审讯上传路数
            /// </summary>
            public uint dwTotalInquestUploadNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRes;
        }

        /// <summary>
        /// SDK功能支持信息(9000新增)
        /// </summary>
        //SDK功能支持信息(9000新增)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SDKABL
        {
            /// <summary>
            /// 最大login用户数 MAX_LOGIN_USERS
            /// </summary>
            public uint dwMaxLoginNum;
            /// <summary>
            /// 最大realplay路数 WATCH_NUM
            /// </summary>
            public uint dwMaxRealPlayNum;
            /// <summary>
            /// 最大回放或下载路数 WATCH_NUM
            /// </summary>
            public uint dwMaxPlayBackNum;
            /// <summary>
            /// 最大建立报警通道路数 ALARM_NUM
            /// </summary>
            public uint dwMaxAlarmChanNum;
            /// <summary>
            /// 最大硬盘格式化路数 SERVER_NUM
            /// </summary>
            public uint dwMaxFormatNum;
            /// <summary>
            /// 最大文件搜索路数 SERVER_NUM
            /// </summary>
            public uint dwMaxFileSearchNum;
            /// <summary>
            /// 最大日志搜索路数 SERVER_NUM
            /// </summary>
            public uint dwMaxLogSearchNum;
            /// <summary>
            /// 最大透明通道路数 SERVER_NUM
            /// </summary>
            public uint dwMaxSerialNum;
            /// <summary>
            /// 最大升级路数 SERVER_NUM
            /// </summary>
            public uint dwMaxUpgradeNum;
            /// <summary>
            /// 最大语音转发路数 SERVER_NUM
            /// </summary>
            public uint dwMaxVoiceComNum;
            /// <summary>
            /// 最大语音广播路数 MAX_CASTNUM
            /// </summary>
            public uint dwMaxBroadCastNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 10, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRes;
        }

        /// <summary>
        /// 报警设备信息
        /// </summary>
        //报警设备信息
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_ALARMER
        {
            /// <summary>
            /// userid是否有效 0-无效，1-有效
            /// </summary>
            public byte byUserIDValid;
            /// <summary>
            /// 序列号是否有效 0-无效，1-有效
            /// </summary>
            public byte bySerialValid;
            /// <summary>
            /// 版本号是否有效 0-无效，1-有效
            /// </summary>
            public byte byVersionValid;
            /// <summary>
            /// 设备名字是否有效 0-无效，1-有效
            /// </summary>
            public byte byDeviceNameValid;
            /// <summary>
            /// MAC地址是否有效 0-无效，1-有效
            /// </summary>
            public byte byMacAddrValid;
            /// <summary>
            /// login端口是否有效 0-无效，1-有效
            /// </summary>
            public byte byLinkPortValid;
            /// <summary>
            /// 设备IP是否有效 0-无效，1-有效
            /// </summary>
            public byte byDeviceIPValid;
            /// <summary>
            /// socket ip是否有效 0-无效，1-有效
            /// </summary>
            public byte bySocketIPValid;
            /// <summary>
            /// NET_DVR_Login()返回值, 布防时有效
            /// </summary>
            public int lUserID;
            /// <summary>
            /// 序列号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SERIALNO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sSerialNumber;
            /// <summary>
            /// 版本信息 高16位表示主版本，低16位表示次版本
            /// </summary>
            public uint dwDeviceVersion;
            /// <summary>
            /// 设备名字
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sDeviceName;
            /// <summary>
            /// MAC地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMacAddr;
            /// <summary>
            /// link port
            /// </summary>
            public ushort wLinkPort;
            /// <summary>
            /// IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] sDeviceIP;
            /// <summary>
            /// 报警主动上传时的socket IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] sSocketIP;
            /// <summary>
            /// Ip协议 0-IPV4, 1-IPV6
            /// </summary>
            public byte byIpProtocol;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 硬解码显示区域参数(子结构)
        /// </summary>
        //硬解码显示区域参数(子结构)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISPLAY_PARA
        {
            public int bToScreen;
            public int bToVideoOut;
            public int nLeft;
            public int nTop;
            public int nWidth;
            public int nHeight;
            public int nReserved;
        }

        /// <summary>
        /// 硬解码预览参数
        /// </summary>
        //硬解码预览参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CARDINFO
        {
            /// <summary>
            /// 通道号
            /// </summary>
            public int lChannel;
            /// <summary>
            /// 最高位(31)为0表示主码流，为1表示子，0－30位表示码流连接方式:0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-电话线，5－128k宽带，6－256k宽带，7－384k宽带，8－512k宽带；
            /// </summary>
            public int lLinkMode;
            [MarshalAsAttribute(UnmanagedType.LPStr)]
            public string sMultiCastIP;
            public NET_DVR_DISPLAY_PARA struDisplayPara;
        }

        /// <summary>
        /// 录象文件参数
        /// </summary>
        //录象文件参数
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_FIND_DATA
        {
            /// <summary>
            /// 文件名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 100)]
            public string sFileName;
            /// <summary>
            /// 文件的开始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 文件的结束时间
            /// </summary>
            public NET_DVR_TIME struStopTime;
            /// <summary>
            /// 文件的大小
            /// </summary>
            public uint dwFileSize;
        }

        /// <summary>
        /// 录象文件参数(9000)
        /// </summary>
        //录象文件参数(9000)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_FINDDATA_V30
        {
            /// <summary>
            /// 文件名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 100)]
            public string sFileName;
            /// <summary>
            /// 文件的开始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 文件的结束时间
            /// </summary>
            public NET_DVR_TIME struStopTime;
            /// <summary>
            /// 文件的大小
            /// </summary>
            public uint dwFileSize;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string sCardNum;
            /// <summary>
            /// 9000设备支持,1表示此文件已经被锁定,0表示正常的文件
            /// </summary>
            public byte byLocked;
            /// <summary>
            /// 文件类型:0－定时录像,1-移动侦测 ，2－报警触发，
            /// </summary>
            public byte byFileType;
            /// <summary>
            /// 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警,14-智能交通事件
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 录象文件参数(cvr)
        /// </summary>
        //录象文件参数(cvr)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_FINDDATA_V40
        {
            /// <summary>
            /// 文件名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 100)]
            public string sFileName;
            /// <summary>
            /// 文件的开始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 文件的结束时间
            /// </summary>
            public NET_DVR_TIME struStopTime;
            /// <summary>
            /// 文件的大小
            /// </summary>
            public uint dwFileSize;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string sCardNum;
            /// <summary>
            /// 9000设备支持,1表示此文件已经被锁定,0表示正常的文件
            /// </summary>
            public byte byLocked;
            /// <summary>
            /// 文件类型:0－定时录像,1-移动侦测 ，2－报警触发，
            /// </summary>
            public byte byFileType;
            /// <summary>
            /// 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警,14-智能交通事件
            /// </summary>
            public byte byQuickSearch;
            public byte byRes;
            /// <summary>
            /// 文件索引号
            /// </summary>
            public uint dwFileIndex;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        /// <summary>
        /// 录象文件参数(带卡号)
        /// </summary>
        //录象文件参数(带卡号)
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_FINDDATA_CARD
        {
            /// <summary>
            /// 文件名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 100)]
            public string sFileName;
            /// <summary>
            /// 文件的开始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 文件的结束时间
            /// </summary>
            public NET_DVR_TIME struStopTime;
            /// <summary>
            /// 文件的大小
            /// </summary>
            public uint dwFileSize;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string sCardNum;
        }

        /// <summary>
        /// 录象文件查找条件结构
        /// </summary>
        //录象文件查找条件结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FILECOND
        {
            /// <summary>
            /// 通道号
            /// </summary>
            public int lChannel;
            /// <summary>
            /// 录象文件类型0xff－全部，0－定时录像,1-移动侦测 ，2－报警触发，
            /// </summary>
            public uint dwFileType;
            /// <summary>
            /// 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像
            /// </summary>
            public uint dwIsLocked;
            /// <summary>
            /// 是否使用卡号
            /// </summary>
            public uint dwUseCardNo;
            /// <summary>
            /// 卡号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] sCardNumber;
            /// <summary>
            /// 开始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 结束时间
            /// </summary>
            public NET_DVR_TIME struStopTime;
        }

        /// <summary>
        /// 云台区域选择放大缩小(HIK 快球专用)
        /// </summary>
        //云台区域选择放大缩小(HIK 快球专用)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_POINT_FRAME
        {
            /// <summary>
            /// 方框起始点的x坐标
            /// </summary>
            public int xTop;
            /// <summary>
            /// 方框结束点的y坐标
            /// </summary>
            public int yTop;
            /// <summary>
            /// 方框结束点的x坐标
            /// </summary>
            public int xBottom;
            /// <summary>
            /// 方框结束点的y坐标
            /// </summary>
            public int yBottom;
            /// <summary>
            /// 保留
            /// </summary>
            public int bCounter;
        }

        /// <summary>
        /// 语音对讲参数
        /// </summary>
        //语音对讲参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_COMPRESSION_AUDIO
        {
            /// <summary>
            /// 音频编码类型 0-G722; 1-G711
            /// </summary>
            public byte byAudioEncType;
            /// <summary>
            /// 这里保留音频的压缩参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] byres;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AUDIOENC_INFO
        {
            /// <summary>
            /// 输入一帧数据大小(BYTES)，由GetInfoParam函数返回
            /// </summary>
            public uint in_frame_size;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.U4)]
            public int[] reserved;
        }

        /// <summary>
        /// 音频编码
        /// </summary>
        // 音频编码
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AUDIOENC_PROCESS_PARAM
        {
            /// <summary>
            /// 输入buf
            /// </summary>
            public IntPtr in_buf;
            /// <summary>
            /// 输出buf
            /// </summary>
            public IntPtr out_buf;
            /// <summary>
            /// 编码一帧后的BYTE数
            /// </summary>
            public uint out_frame_size;
            /// <summary>
            /// 重置开关
            /// </summary>
            public int g726enc_reset;
            /// <summary>
            /// g711编码类型,0 - U law, 1- A law
            /// </summary>
            public int g711_type;
            /// <summary>
            /// 音频编码模式，AMR编码配置
            /// </summary>
            public int enc_mode;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.U4)]
            public int[] reserved;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_AP_INFO
        {
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = IW_ESSID_MAX_SIZE)]
            public string sSsid;
            /// <summary>
            /// 0 mange 模式;1 ad-hoc模式，参见NICMODE
            /// </summary>
            public uint dwMode;
            /// <summary>
            /// 0 不加密；1 wep加密；2 wpa-psk;3 wpa-Enterprise，参见WIFISECURITY
            /// </summary>
            public uint dwSecurity;
            /// <summary>
            /// 1-11表示11个通道
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 0-100信号由最弱变为最强
            /// </summary>
            public uint dwSignalStrength;
            /// <summary>
            /// 速率,单位是0.01mbps
            /// </summary>
            public uint dwSpeed;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AP_INFO_LIST
        {
            public uint dwSize;
            /// <summary>
            /// 无线AP数量，不超过20
            /// </summary>
            public uint dwCount;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = WIFI_MAX_AP_COUNT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_AP_INFO[] struApInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_WIFIETHERNET
        {
            /// <summary>
            /// IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sIpAddress;
            /// <summary>
            /// 掩码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sIpMask;
            /// <summary>
            /// 物理地址，只用来显示
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMACAddr;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] bRes;
            /// <summary>
            /// 是否启动dhcp  0不启动 1启动
            /// </summary>
            public uint dwEnableDhcp;
            /// <summary>
            /// 如果启动dhcp是否自动获取dns,0不自动获取 1自动获取；对于有线如果启动dhcp目前自动获取dns
            /// </summary>
            public uint dwAutoDns;
            /// <summary>
            /// 第一个dns域名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sFirstDns;
            /// <summary>
            /// 第二个dns域名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sSecondDns;
            /// <summary>
            /// 网关地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sGatewayIpAddr;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] bRes2;
        }

        /// <summary>
        /// WPA-enterprise/WPA2-enterpris模式适用
        /// </summary>
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct UNION_EAP_TTLS
        {
            /// <summary>
            /// EAPOL版本，0-版本1，1-版本2
            /// </summary>
            public byte byEapolVersion;
            /// <summary>
            /// 内部认证方式，0-PAP，1-MSCHAPV2
            /// </summary>
            public byte byAuthType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 匿名身份
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byAnonyIdentity;
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPassword;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 44, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// WPA-enterprise/WPA2-enterpris模式适用
        /// </summary>
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct UNION_EAP_PEAP
        {
            /// <summary>
            /// EAPOL版本，0-版本1，1-版本2
            /// </summary>
            public byte byEapolVersion;
            /// <summary>
            /// 内部认证方式，0-GTC，1-MD5，2-MSCHAPV2
            /// </summary>
            public byte byAuthType;
            /// <summary>
            /// PEAP版本，0-版本0，1-版本1
            /// </summary>
            public byte byPeapVersion;
            /// <summary>
            /// PEAP标签，0-老标签，1-新标签
            /// </summary>
            public byte byPeapLabel;
            /// <summary>
            /// 匿名身份
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byAnonyIdentity;
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPassword;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 44, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct UNION_EAP_TLS
        {
            /// <summary>
            /// EAPOL版本，0-版本1，1-版本2
            /// </summary>
            public byte byEapolVersion;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 身份
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byIdentity;
            /// <summary>
            /// 私钥密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPrivateKeyPswd;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 76, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct WIFI_AUTH_PARAM
        {
            /// <summary>
            /// WPA-enterprise/WPA2-enterpris模式适用
            /// </summary>
            [FieldOffsetAttribute(0)]
            public UNION_EAP_TTLS EAP_TTLS;
            /// <summary>
            /// WPA-enterprise/WPA2-enterpris模式适用
            /// </summary>
            [FieldOffsetAttribute(0)]
            public UNION_EAP_PEAP EAP_PEAP;
            [FieldOffsetAttribute(0)]
            public UNION_EAP_TLS EAP_TLS;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct UNION_WEP
        {
            /// <summary>
            /// 0 -开放式 1-共享式
            /// </summary>
            public uint dwAuthentication;
            /// <summary>
            /// 0 -64位；1- 128位；2-152位
            /// </summary>
            public uint dwKeyLength;
            /// <summary>
            /// 0 16进制;1 ASCI
            /// </summary>
            public uint dwKeyType;
            /// <summary>
            /// 0 索引：0---3表示用哪一个密钥
            /// </summary>
            public uint dwActive;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = WIFI_WEP_MAX_KEY_COUNT * WIFI_WEP_MAX_KEY_LENGTH)]
            public string sKeyInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct UNION_WPA_PSK
        {
            /// <summary>
            /// 8-63个ASCII字符
            /// </summary>
            public uint dwKeyLength;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = WIFI_WPA_PSK_MAX_KEY_LENGTH)]
            public string sKeyInfo;
            /// <summary>
            /// WPA/WPA2模式下加密类型,0-AES, 1-TKIP
            /// </summary>
            public byte byEncryptType;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct UNION_WPA_WPA2
        {
            /// <summary>
            /// 加密类型,0-AES, 1-TKIP
            /// </summary>
            public byte byEncryptType;
            /// <summary>
            /// 认证类型，0-EAP_TTLS,1-EAP_PEAP,2-EAP_TLS
            /// </summary>
            public byte byAuthType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public WIFI_AUTH_PARAM auth_param;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_WIFI_CFG_EX
        {
            /// <summary>
            /// wifi网口
            /// </summary>
            public NET_DVR_WIFIETHERNET struEtherNet;
            /// <summary>
            /// SSID
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = IW_ESSID_MAX_SIZE)]
            public string sEssid;
            /// <summary>
            /// 0 mange 模式;1 ad-hoc模式，参见
            /// </summary>
            public uint dwMode;
            /// <summary>
            /// 0 不加密；1 wep加密；2 wpa-psk;
            /// </summary>
            public uint dwSecurity;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WIFI_CFG
        {
            public uint dwSize;
            public NET_DVR_WIFI_CFG_EX struWifiCfg;
        }

        /// <summary>
        /// wifi连接状态
        /// </summary>
        //wifi连接状态
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WIFI_CONNECT_STATUS
        {
            public uint dwSize;
            /// <summary>
            /// 1-已连接，2-未连接，3-正在连接
            /// </summary>
            public byte byCurStatus;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// byCurStatus = 2时有效,1-用户名或密码错误,2-无此路由器,3-未知错误
            /// </summary>
            public uint dwErrorCode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 244, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WIFI_WORKMODE
        {
            public uint dwSize;
            /// <summary>
            /// 0 自动切换模式　1 有线模式
            /// </summary>
            public uint dwNetworkInterfaceMode;
        }
        /// <summary>
        /// 智能控制信息
        /// </summary>
        public const int MAX_VCA_CHAN = 16;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_CTRLINFO
        {
            /// <summary>
            /// 是否开启智能
            /// </summary>
            public byte byVCAEnable;
            /// <summary>
            /// 智能能力类型，VCA_CHAN_ABILITY_TYPE
            /// </summary>
            public byte byVCAType;
            /// <summary>
            /// 码流中是否带智能信息
            /// </summary>
            public byte byStreamWithVCA;
            /// <summary>
            /// 模式，VCA_CHAN_MODE_TYPE ,atm能力的时候需要配置
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 控制类型，按位表示，0-否，1-是
            /// </summary>
            public byte byControlType;
            /// <summary>
            /// byControlType &1 是否启用抓拍功能
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 智能控制信息结构
        /// </summary>
        //智能控制信息结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_CTRLCFG
        {
            public uint dwSize;
            /// <summary>
            /// 控制信息,数组0对应设备的起始通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_VCA_CHAN, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_CTRLINFO[] struCtrlInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 智能设备能力集
        /// </summary>
        //智能设备能力集
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_DEV_ABILITY
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 智能通道个数
            /// </summary>
            public byte byVCAChanNum;
            /// <summary>
            /// 车牌通道个数
            /// </summary>
            public byte byPlateChanNum;
            /// <summary>
            /// 行为基本版个数
            /// </summary>
            public byte byBBaseChanNum;
            /// <summary>
            /// 行为高级版个数
            /// </summary>
            public byte byBAdvanceChanNum;
            /// <summary>
            /// 行为完整版个数
            /// </summary>
            public byte byBFullChanNum;
            /// <summary>
            /// 智能ATM个数
            /// </summary>
            public byte byATMChanNum;
            /// <summary>
            /// 人数统计通道个数
            /// </summary>
            public byte byPDCChanNum;
            /// <summary>
            /// 交通事件通道个数
            /// </summary>
            public byte byITSChanNum;
            /// <summary>
            /// 行为监狱版(监舍)通道个数
            /// </summary>
            public byte byBPrisonChanNum;
            /// <summary>
            /// 人脸抓拍通道个数
            /// </summary>
            public byte byFSnapChanNum;
            /// <summary>
            /// 人脸抓拍和识别通道个数
            /// </summary>
            public byte byFSnapRecogChanNum;
            /// <summary>
            /// 人脸后检索个数
            /// </summary>
            public byte byFRetrievalChanNum;
            /// <summary>
            /// 能力，位与结果为0表示不支持，1表示支持
            /// </summary>
            public byte bySupport;
            /// <summary>
            /// bySupport & 0x1，表示是否支持智能 2012-3-22
            /// bySupport & 0x2，表示是否支持128路取流扩展2012-12-27
            /// </summary>
            public byte byFRecogChanNum;
            /// <summary>
            /// 行为监狱版(周界)通道个数
            /// </summary>
            public byte byBPPerimeterChanNum;
            /// <summary>
            /// 交通诱导通道个数
            /// </summary>
            public byte byTPSChanNum;
            /// <summary>
            /// 道路违章取证通道个数
            /// </summary>
            public byte byTFSChanNum;
            /// <summary>
            /// 人脸抓拍和异常行为识别通道个数
            /// </summary>
            public byte byFSnapBFullChanNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 22, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 异常行为识别能力类型
        /// </summary>
        public enum VCA_ABILITY_TYPE : uint
        {
            /// <summary>
            /// 穿越警戒面
            /// </summary>
            TRAVERSE_PLANE_ABILITY = 0x01,
            /// <summary>
            /// 进入区域
            /// </summary>
            ENTER_AREA_ABILITY = 0x02,
            /// <summary>
            /// 离开区域
            /// </summary>
            EXIT_AREA_ABILITY = 0x04,
            /// <summary>
            /// 入侵
            /// </summary>
            INTRUSION_ABILITY = 0x08,
            /// <summary>
            /// 徘徊
            /// </summary>
            LOITER_ABILITY = 0x10,
            /// <summary>
            /// 物品遗留拿取
            /// </summary>
            LEFT_TAKE_ABILITY = 0x20,
            /// <summary>
            /// 停车
            /// </summary>
            PARKING_ABILITY = 0x40,
            /// <summary>
            /// 快速移动
            /// </summary>
            RUN_ABILITY = 0x80,
            /// <summary>
            /// 人员聚集
            /// </summary>
            HIGH_DENSITY_ABILITY = 0x100,
            /// <summary>
            /// 球机
            /// </summary>
            LF_TRACK_ABILITY = 0x200,
            /// <summary>
            /// 剧烈运动检测
            /// </summary>
            VIOLENT_MOTION_ABILITY = 0x400,
            /// <summary>
            /// 攀高检测
            /// </summary>
            REACH_HIGHT_ABILITY = 0x800,
            /// <summary>
            /// 起身检测
            /// </summary>
            GET_UP_ABILITY = 0x1000,
            /// <summary>
            /// 物品遗留
            /// </summary>
            LEFT_ABILITY = 0x2000,
            /// <summary>
            /// 物品遗留拿取
            /// </summary>
            TAKE_ABILITY = 0x4000,
            /// <summary>
            /// 高危目标岗位检测-离岗
            /// </summary>
            LEAVE_POSITION = 0x8000,
            /// <summary>
            /// 尾随
            /// </summary>
            TRAIL_ABILITY = 0x10000,
            /// <summary>
            /// 重点目标起身检测
            /// </summary>
            KEY_PERSON_GET_UP_ABILITY = 0x20000,
            /// <summary>
            /// 倒地
            /// </summary>
            FALL_DOWN_ABILITY = 0x80000,
            /// <summary>
            /// 声强突变
            /// </summary>
            AUDIO_ABNORMAL_ABILITY = 0x100000,
            /// <summary>
            /// 折线攀高
            /// </summary>
            ADV_REACH_HEIGHT_ABILITY = 0x200000,
            /// <summary>
            /// 目标区域滞留超时
            /// </summary>
            TOILET_TARRY_ABILITY = 0x400000,
            /// <summary>
            /// 放风场滞留
            /// </summary>
            YARD_TARRY_ABILITY = 0x800000,
            /// <summary>
            /// 折线警戒面
            /// </summary>
            ADV_TRAVERSE_PLANE_ABILITY = 0x1000000,
            /// <summary>
            /// 人靠近ATM ,只在ATM_PANEL模式下支持
            /// </summary>
            HUMAN_ENTER_ABILITY = 0x10000000,
            /// <summary>
            /// 操作超时,只在ATM_PANEL模式下支持
            /// </summary>
            OVER_TIME_ABILITY = 0x20000000,
            /// <summary>
            /// 贴纸条
            /// </summary>
            STICK_UP_ABILITY = 0x40000000,
            /// <summary>
            /// 安装读卡器
            /// </summary>
            INSTALL_SCANNER_ABILITY = 0x80000000
        }

        /// <summary>
        /// 智能通道类型
        /// </summary>
        public enum VCA_CHAN_ABILITY_TYPE
        {
            /// <summary>
            /// 异常行为识别基本版
            /// </summary>
            VCA_BEHAVIOR_BASE = 1,
            /// <summary>
            /// 异常行为识别高级版
            /// </summary>
            VCA_BEHAVIOR_ADVANCE = 2,
            /// <summary>
            /// 异常行为识别完整版
            /// </summary>
            VCA_BEHAVIOR_FULL = 3,
            /// <summary>
            /// 车牌能力
            /// </summary>
            VCA_PLATE = 4,
            /// <summary>
            /// ATM能力
            /// </summary>
            VCA_ATM = 5,
            /// <summary>
            /// 人流量统计
            /// </summary>
            VCA_PDC = 6,
            /// <summary>
            /// 智能 交通事件
            /// </summary>
            VCA_ITS = 7,
            /// <summary>
            /// 异常行为识别监狱版(监舍)
            /// </summary>
            VCA_BEHAVIOR_PRISON = 8,
            /// <summary>
            /// 人脸抓拍能力
            /// </summary>
            VCA_FACE_SNAP = 9,
            /// <summary>
            /// 人脸抓拍和识别能力
            /// </summary>
            VCA_FACE_SNAPRECOG = 10,
            /// <summary>
            /// 人脸后检索能力
            /// </summary>
            VCA_FACE_RETRIEVAL = 11,
            /// <summary>
            /// 人脸识别能力
            /// </summary>
            VCA_FACE_RECOG = 12,
            /// <summary>
            /// 异常行为识别监狱版 (周界)
            /// </summary>
            VCA_BEHAVIOR_PRISON_PERIMETER = 13,
            /// <summary>
            /// 交通诱导
            /// </summary>
            VCA_TPS = 14,
            /// <summary>
            /// 道路违章取证
            /// </summary>
            VCA_TFS = 15,
            /// <summary>
            /// 人脸抓拍和异常行为识别能力
            /// </summary>
            VCA_BEHAVIOR_FACESNAP = 16
        }

        /// <summary>
        /// 智能ATM模式类型(ATM能力特有)
        /// </summary>
        public enum VCA_CHAN_MODE_TYPE
        {
            /// <summary>
            /// ATM面板
            /// </summary>
            VCA_ATM_PANEL = 0,
            /// <summary>
            /// ATM环境
            /// </summary>
            VCA_ATM_SURROUND = 1,
            /// <summary>
            /// ATM人脸
            /// </summary>
            VCA_ATM_FACE = 2
        }

        public enum TFS_CHAN_MODE_TYPE
        {
            /// <summary>
            /// TFS 城市道路
            /// </summary>
            TFS_CITYROAD = 0,
            /// <summary>
            /// TFS 高速道路
            /// </summary>
            TFS_FREEWAY = 1
        }

        /// <summary>
        /// 异常行为识别场景模式
        /// </summary>
        public enum BEHAVIOR_SCENE_MODE_TYPE
        {
            /// <summary>
            /// 系统默认
            /// </summary>
            BEHAVIOR_SCENE_DEFAULT = 0,
            /// <summary>
            /// 围墙
            /// </summary>
            BEHAVIOR_SCENE_WALL = 1,
            /// <summary>
            /// 室内
            /// </summary>
            BEHAVIOR_SCENE_INDOOR = 2
        }

        /// <summary>
        /// 通道能力输入参数
        /// </summary>
        //通道能力输入参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_CHAN_IN_PARAM
        {
            /// <summary>
            /// VCA_CHAN_ABILITY_TYPE枚举值
            /// </summary>
            public byte byVCAType;
            /// <summary>
            /// 模式，VCA_CHAN_MODE_TYPE ,atm能力的时候需要配置
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 保留，设置为0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 行为能力集结构
        /// </summary>
        //行为能力集结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_BEHAVIOR_ABILITY
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 支持的能力类型，按位表示，见VCA_ABILITY_TYPE定义
            /// </summary>
            public uint dwAbilityType;
            /// <summary>
            /// 最大规则数
            /// </summary>
            public byte byMaxRuleNum;
            /// <summary>
            /// 最大目标数
            /// </summary>
            public byte byMaxTargetNum;
            /// <summary>
            /// 支持的功能类型   按位表示
            /// </summary>
            public byte bySupport;
            /// <summary>
            /// bySupport & 0x01 支持标定功能
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 9, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 交通能力集结构
        /// </summary>
        // 交通能力集结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ITS_ABILITY
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 支持的能力列表  参照ITS_ABILITY_TYPE
            /// </summary>
            public uint dwAbilityType;
            /// <summary>
            /// 最大规则数
            /// </summary>
            public byte byMaxRuleNum;
            /// <summary>
            /// 最大目标数
            /// </summary>
            public byte byMaxTargetNum;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 10, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// *********************************end******************************************
        /// **********************************智能参数结构********************************
        /// 智能共用结构
        /// 坐标值归一化,浮点数值为当前画面的百分比大小, 精度为小数点后三位
        /// 点坐标结构
        /// </summary>
        /***********************************end*******************************************/

        /************************************智能参数结构*********************************/
        //智能共用结构
        //坐标值归一化,浮点数值为当前画面的百分比大小, 精度为小数点后三位
        //点坐标结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_POINT
        {
            /// <summary>
            /// X轴坐标, 0.001~1
            /// </summary>
            public float fX;
            /// <summary>
            /// Y轴坐标, 0.001~1
            /// </summary>
            public float fY;
        }

        /// <summary>
        /// 区域框结构
        /// </summary>
        //区域框结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_RECT
        {
            /// <summary>
            /// 边界框左上角点的X轴坐标, 0.001~1
            /// </summary>
            public float fX;
            /// <summary>
            /// 边界框左上角点的Y轴坐标, 0.001~1
            /// </summary>
            public float fY;
            /// <summary>
            /// 边界框的宽度, 0.001~1
            /// </summary>
            public float fWidth;
            /// <summary>
            /// 边界框的高度, 0.001~1
            /// </summary>
            public float fHeight;
        }

        /// <summary>
        /// 异常行为识别事件类型
        /// </summary>
        public enum VCA_EVENT_TYPE : uint
        {
            /// <summary>
            /// 穿越警戒面
            /// </summary>
            VCA_TRAVERSE_PLANE = 0x1,
            /// <summary>
            /// 目标进入区域,支持区域规则
            /// </summary>
            VCA_ENTER_AREA = 0x2,
            /// <summary>
            /// 目标离开区域,支持区域规则
            /// </summary>
            VCA_EXIT_AREA = 0x4,
            /// <summary>
            /// 周界入侵,支持区域规则
            /// </summary>
            VCA_INTRUSION = 0x8,
            /// <summary>
            /// 徘徊,支持区域规则
            /// </summary>
            VCA_LOITER = 0x10,
            /// <summary>
            /// 物品遗留拿取,支持区域规则
            /// </summary>
            VCA_LEFT_TAKE = 0x20,
            /// <summary>
            /// 停车,支持区域规则
            /// </summary>
            VCA_PARKING = 0x40,
            /// <summary>
            /// 快速移动,支持区域规则
            /// </summary>
            VCA_RUN = 0x80,
            /// <summary>
            /// 区域内人员聚集,支持区域规则
            /// </summary>
            VCA_HIGH_DENSITY = 0x100,
            /// <summary>
            /// 剧烈运动检测
            /// </summary>
            VCA_VIOLENT_MOTION = 0x200,
            /// <summary>
            /// 攀高检测
            /// </summary>
            VCA_REACH_HIGHT = 0x400,
            /// <summary>
            /// 起身检测
            /// </summary>
            VCA_GET_UP = 0x800,
            /// <summary>
            /// 物品遗留拿取,支持区域规则
            /// </summary>
            VCA_LEFT = 0x1000,
            /// <summary>
            /// 物品拿取
            /// </summary>
            VCA_TAKE = 0x2000,
            /// <summary>
            /// 高危目标岗位检测-离岗
            /// </summary>
            VCA_LEAVE_POSITION = 0x4000,
            /// <summary>
            /// 尾随
            /// </summary>
            VCA_TRAIL = 0x8000,
            /// <summary>
            /// 重点目标起身检测
            /// </summary>
            VCA_KEY_PERSON_GET_UP = 0x10000,
            /// <summary>
            /// 倒地检测
            /// </summary>
            VCA_FALL_DOWN = 0x80000,
            /// <summary>
            /// 声强突变检测
            /// </summary>
            VCA_AUDIO_ABNORMAL = 0x100000,
            /// <summary>
            /// 折线攀高
            /// </summary>
            VCA_ADV_REACH_HEIGHT = 0x200000,
            /// <summary>
            /// 目标区域滞留超时
            /// </summary>
            VCA_TOILET_TARRY = 0x400000,
            /// <summary>
            /// 放风场滞留
            /// </summary>
            VCA_YARD_TARRY = 0x800000,
            /// <summary>
            /// 折线警戒面
            /// </summary>
            VCA_ADV_TRAVERSE_PLANE = 0x1000000,
            /// <summary>
            /// 人靠近ATM           只在ATM_PANEL模式下支持
            /// </summary>
            VCA_HUMAN_ENTER = 0x10000000,
            /// <summary>
            /// 操作超时            只在ATM_PANEL模式下支持
            /// </summary>
            VCA_OVER_TIME = 0x20000000,
            /// <summary>
            /// 贴纸条,支持区域规则
            /// </summary>
            VCA_STICK_UP = 0x40000000,
            /// <summary>
            /// 安装读卡器,支持区域规则
            /// </summary>
            VCA_INSTALL_SCANNER = 0x80000000
        }

        /// <summary>
        /// 异常行为识别事件类型扩展
        /// </summary>
        public enum VCA_RULE_EVENT_TYPE_EX : ushort
        {
            /// <summary>
            /// 穿越警戒面
            /// </summary>
            ENUM_VCA_EVENT_TRAVERSE_PLANE = 1,
            /// <summary>
            /// 目标进入区域,支持区域规则
            /// </summary>
            ENUM_VCA_EVENT_ENTER_AREA = 2,
            /// <summary>
            /// 目标离开区域,支持区域规则
            /// </summary>
            ENUM_VCA_EVENT_EXIT_AREA = 3,
            /// <summary>
            /// 周界入侵,支持区域规则
            /// </summary>
            ENUM_VCA_EVENT_INTRUSION = 4,
            /// <summary>
            /// 徘徊,支持区域规则
            /// </summary>
            ENUM_VCA_EVENT_LOITER = 5,
            /// <summary>
            /// 物品遗留拿取,支持区域规则
            /// </summary>
            ENUM_VCA_EVENT_LEFT_TAKE = 6,
            /// <summary>
            /// 停车,支持区域规则
            /// </summary>
            ENUM_VCA_EVENT_PARKING = 7,
            /// <summary>
            /// 快速移动,支持区域规则
            /// </summary>
            ENUM_VCA_EVENT_RUN = 8,
            /// <summary>
            /// 区域内人员聚集,支持区域规则
            /// </summary>
            ENUM_VCA_EVENT_HIGH_DENSITY = 9,
            /// <summary>
            /// 剧烈运动检测
            /// </summary>
            ENUM_VCA_EVENT_VIOLENT_MOTION = 10,
            /// <summary>
            /// 攀高检测
            /// </summary>
            ENUM_VCA_EVENT_REACH_HIGHT = 11,
            /// <summary>
            /// 起身检测
            /// </summary>
            ENUM_VCA_EVENT_GET_UP = 12,
            /// <summary>
            /// 物品遗留拿取,支持区域规则
            /// </summary>
            ENUM_VCA_EVENT_LEFT = 13,
            /// <summary>
            /// 物品拿取
            /// </summary>
            ENUM_VCA_EVENT_TAKE = 14,
            /// <summary>
            /// 高危目标岗位检测-离岗
            /// </summary>
            ENUM_VCA_EVENT_LEAVE_POSITION = 15,
            /// <summary>
            /// 尾随
            /// </summary>
            ENUM_VCA_EVENT_TRAIL = 16,
            /// <summary>
            /// 重点目标起身检测
            /// </summary>
            ENUM_VCA_EVENT_KEY_PERSON_GET_UP = 17,
            /// <summary>
            /// 倒地检测
            /// </summary>
            ENUM_VCA_EVENT_FALL_DOWN = 20,
            /// <summary>
            /// 声强突变检测
            /// </summary>
            ENUM_VCA_EVENT_AUDIO_ABNORMAL = 21,
            /// <summary>
            /// 折线攀高
            /// </summary>
            ENUM_VCA_EVENT_ADV_REACH_HEIGHT = 22,
            /// <summary>
            /// 目标区域滞留超时
            /// </summary>
            ENUM_VCA_EVENT_TOILET_TARRY = 23,
            /// <summary>
            /// 放风场滞留
            /// </summary>
            ENUM_VCA_EVENT_YARD_TARRY = 24,
            /// <summary>
            /// 折线警戒面
            /// </summary>
            ENUM_VCA_EVENT_ADV_TRAVERSE_PLANE = 25,
            /// <summary>
            /// 人靠近ATM,只在ATM_PANEL模式下支持
            /// </summary>
            ENUM_VCA_EVENT_HUMAN_ENTER = 29,
            /// <summary>
            /// 操作超时,只在ATM_PANEL模式下支持
            /// </summary>
            ENUM_VCA_EVENT_OVER_TIME = 30,
            /// <summary>
            /// 贴纸条,支持区域规则
            /// </summary>
            ENUM_VCA_EVENT_STICK_UP = 31,
            /// <summary>
            /// 安装读卡器,支持区域规则
            /// </summary>
            ENUM_VCA_EVENT_INSTALL_SCANNER = 32
        }

        /// <summary>
        /// 警戒面穿越方向类型
        /// </summary>
        public enum VCA_CROSS_DIRECTION
        {
            /// <summary>
            /// 双向
            /// </summary>
            VCA_BOTH_DIRECTION,
            /// <summary>
            /// 由左至右
            /// </summary>
            VCA_LEFT_GO_RIGHT,
            /// <summary>
            /// 由右至左
            /// </summary>
            VCA_RIGHT_GO_LEFT
        }

        /// <summary>
        /// 线结构
        /// </summary>
        //线结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_LINE
        {
            /// <summary>
            /// 起点
            /// </summary>
            public NET_VCA_POINT struStart;
            /// <summary>
            /// 终点
            /// </summary>
            public NET_VCA_POINT struEnd;
        }

        /// <summary>
        /// 该结构会导致xaml界面出不来！！！！！！！！！？？问题暂时还没有找到
        /// 暂时屏蔽结构先
        /// 多边型结构体
        /// </summary>
        //该结构会导致xaml界面出不来！！！！！！！！！？？问题暂时还没有找到  
        //暂时屏蔽结构先
        //多边型结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_POLYGON
        {
            /// <summary>
            /// DWORD->unsigned int
            /// </summary>
            public uint dwPointNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = VCA_MAX_POLYGON_POINT_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_POINT[] struPos;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_TRAVERSE_PLANE
        {
            /// <summary>
            /// 警戒面底边
            /// </summary>
            public NET_VCA_LINE struPlaneBottom;
            /// <summary>
            /// 穿越方向: 0-双向，1-从左到右，2-从右到左
            /// </summary>
            public uint dwCrossDirection;
            /// <summary>
            /// 灵敏度，取值范围：[1,5] （对于Smart IPC，取值范围为[1,100]）
            /// </summary>
            public byte bySensitivity;
            /// <summary>
            /// 警戒面高度
            /// </summary>
            public byte byPlaneHeight;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 38, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 进入/离开区域参数
        /// </summary>
        //进入/离开区域参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_AREA
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 根据报警延迟时间来标识报警中带图片，报警间隔和IO报警一致，1秒发送一个。
        /// 入侵参数
        /// </summary>
        //根据报警延迟时间来标识报警中带图片，报警间隔和IO报警一致，1秒发送一个。
        //入侵参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_INTRUSION
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 报警延迟时间: 1-120秒，建议5秒，判断是有效报警的时间
            /// </summary>
            public ushort wDuration;
            /// <summary>
            /// 灵敏度参数，范围[1-100]
            /// </summary>
            public byte bySensitivity;
            /// <summary>
            /// 占比：区域内所有未报警目标尺寸目标占区域面积的比重，归一化为－；
            /// </summary>
            public byte byRate;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 徘徊参数
        /// </summary>
        //徘徊参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_LOITER
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 触发徘徊报警的持续时间：1-120秒，建议10秒
            /// </summary>
            public ushort wDuration;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 丢包/捡包参数
        /// </summary>
        //丢包/捡包参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_TAKE_LEFT
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 触发丢包/捡包报警的持续时间：1-120秒，建议10秒
            /// </summary>
            public ushort wDuration;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 停车参数
        /// </summary>
        //停车参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_PARKING
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 触发停车报警持续时间：1-120秒，建议10秒
            /// </summary>
            public ushort wDuration;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 奔跑参数
        /// </summary>
        //奔跑参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_RUN
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 人奔跑最大距离, 范围: [0.1, 1.00]
            /// </summary>
            public float fRunDistance;
            /// <summary>
            /// 保留字节
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// 0 像素模式  1 实际模式
            /// </summary>
            public byte byMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 人员聚集参数
        /// </summary>
        //人员聚集参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_HIGH_DENSITY
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 密度比率, 范围: [0.1, 1.0]
            /// </summary>
            public float fDensity;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 触发人员聚集参数报警阈值 20-360s
            /// </summary>
            public ushort wDuration;
        }

        /// <summary>
        /// 剧烈运动参数
        /// </summary>
        //剧烈运动参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_VIOLENT_MOTION
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 触发剧烈运动报警阈值：1-50秒
            /// </summary>
            public ushort wDuration;
            /// <summary>
            /// 灵敏度参数，范围[1,5]
            /// </summary>
            public byte bySensitivity;
            /// <summary>
            /// 0-纯视频模式，1-音视频联合模式，2-纯音频模式
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 攀高参数
        /// </summary>
        //攀高参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_REACH_HIGHT
        {
            /// <summary>
            /// 攀高警戒面
            /// </summary>
            public NET_VCA_LINE struVcaLine;
            /// <summary>
            /// 触发攀高报警阈值：1-120秒
            /// </summary>
            public ushort wDuration;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 起床参数
        /// </summary>
        //起床参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_GET_UP
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 触发起床报警阈值1-100 秒
            /// </summary>
            public ushort wDuration;
            /// <summary>
            /// 起身检测模式,0-大床通铺模式,1-高低铺模式,2-大床通铺坐立起身模式
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 灵敏度参数，范围[1,10]
            /// </summary>
            public byte bySensitivity;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 物品遗留
        /// </summary>
        //物品遗留
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_LEFT
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 触发物品遗留报警阈值 10-100秒
            /// </summary>
            public ushort wDuration;
            /// <summary>
            /// 灵敏度参数，范围[1,5]
            /// </summary>
            public byte bySensitivity;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 物品拿取
        /// </summary>
        // 物品拿取
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_TAKE
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 触发物品拿取报警阈值10-100秒
            /// </summary>
            public ushort wDuration;
            /// <summary>
            /// 灵敏度参数，范围[1,5]
            /// </summary>
            public byte bySensitivity;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_OVER_TIME
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 操作报警时间阈值 4s-60000s
            /// </summary>
            public ushort wDuration;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_HUMAN_ENTER
        {
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 23, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRes;
        }

        /// <summary>
        /// 贴纸条参数
        /// </summary>
        //贴纸条参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_STICK_UP
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 报警持续时间：10-60秒，建议10秒
            /// </summary>
            public ushort wDuration;
            /// <summary>
            /// 灵敏度参数，范围[1,5]
            /// </summary>
            public byte bySensitivity;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 读卡器参数
        /// </summary>
        //读卡器参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_SCANNER
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 读卡持续时间：10-60秒
            /// </summary>
            public ushort wDuration;
            /// <summary>
            /// 灵敏度参数，范围[1,5]
            /// </summary>
            public byte bySensitivity;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 高危目标岗位检测-离岗事件
        /// </summary>
        //高危目标岗位检测-离岗事件
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_LEAVE_POSITION
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 无人报警时间，单位：s，取值1-1800
            /// </summary>
            public ushort wLeaveDelay;
            /// <summary>
            /// 睡觉报警时间，单位：s，取值1-1800
            /// </summary>
            public ushort wStaticDelay;
            /// <summary>
            /// 模式，0-高危目标岗位检测-离岗事件，1-高危目标岗位检测-睡岗事件，2-高危目标岗位检测-离岗睡岗事件
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 值岗人数类型，0-单人值岗，1-双人值岗
            /// </summary>
            public byte byPersonType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 尾随参数
        /// </summary>
        //尾随参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_TRAIL
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 保留
            /// </summary>
            public ushort wRes;
            /// <summary>
            /// 灵敏度参数，范围[1,5]
            /// </summary>
            public byte bySensitivity;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 倒地参数
        /// </summary>
        //倒地参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FALL_DOWN
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 触发事件阈值 1-60s
            /// </summary>
            public ushort wDuration;
            /// <summary>
            /// 灵敏度参数，范围[1,5]
            /// </summary>
            public byte bySensitivity;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 声强突变参数
        /// </summary>
        //声强突变参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_AUDIO_ABNORMAL
        {
            /// <summary>
            /// 声音强度
            /// </summary>
            public ushort wDecibel;
            /// <summary>
            /// 灵敏度参数，范围[1,5]
            /// </summary>
            public byte bySensitivity;
            /// <summary>
            /// 声音检测模式，0-灵敏度检测，1-分贝阈值检测，2-灵敏度与分贝阈值检测
            /// </summary>
            public byte byAudioMode;
            /// <summary>
            /// 使能，是否开启
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 声音阈值[0,100]
            /// </summary>
            public byte byThreshold;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 54, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AUDIO_EXCEPTION
        {
            public uint dwSize;
            /// <summary>
            /// 使能，是否开启
            /// </summary>
            public byte byEnableAudioInException;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public NET_VCA_AUDIO_ABNORMAL struAudioAbnormal;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmSched;
            /// <summary>
            /// 异常处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V40 struHandleException;
            /// <summary>
            /// 报警触发的录象通道 数（只读）最大支持数量
            /// </summary>
            public uint dwMaxRelRecordChanNum;
            /// <summary>
            /// 报警触发的录象通道 数 实际支持的数量
            /// </summary>
            public uint dwRelRecordChanNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.U4)]
            public uint[] byRelRecordChan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_TOILET_TARRY
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 目标区域滞留超时时间[1,3600]，单位：秒
            /// </summary>
            public ushort wDelay;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_YARD_TARRY
        {
            /// <summary>
            /// 区域范围
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 放风场滞留时间[1,120]，单位：秒
            /// </summary>
            public ushort wDelay;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_ADV_REACH_HEIGHT
        {
            /// <summary>
            /// 攀高折线
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 跨越方向(详见VCA_CROSS_DIRECTION): 0-双向，1-从左到右2-从右到左
            /// </summary>
            public uint dwCrossDirection;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_ADV_TRAVERSE_PLANE
        {
            /// <summary>
            /// 警戒面折线
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 跨越方向(详见VCA_CROSS_DIRECTION): 0-双向，1-从左到右2-从右到左
            /// </summary>
            public uint dwCrossDirection;
            /// <summary>
            /// 灵敏度参数，范围[1,5]
            /// </summary>
            public byte bySensitivity;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 警戒事件参数
        /// </summary>
        //警戒事件参数
        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_VCA_EVENT_UNION
        {
            /// <summary>
            /// 参数
            /// </summary>
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 23, ArraySubType = UnmanagedType.U4)]
            public uint[] uLen;
        }

        /// <summary>
        /// 尺寸过滤器类型
        /// </summary>
        public enum SIZE_FILTER_MODE
        {
            /// <summary>
            /// 根据像素大小设置
            /// </summary>
            IMAGE_PIX_MODE,
            /// <summary>
            /// 根据实际大小设置
            /// </summary>
            REAL_WORLD_MODE,
            /// <summary>
            /// 默认模式
            /// </summary>
            DEFAULT_MODE
        }

        /// <summary>
        /// 尺寸过滤器
        /// </summary>
        //尺寸过滤器
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_SIZE_FILTER
        {
            /// <summary>
            /// 是否激活尺寸过滤器 0-否 非0-是
            /// </summary>
            public byte byActive;
            /// <summary>
            /// 过滤器模式SIZE_FILTER_MODE
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 保留，置0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 最小目标框,全0表示不设置
            /// </summary>
            public NET_VCA_RECT struMiniRect;
            /// <summary>
            /// 最大目标框,全0表示不设置
            /// </summary>
            public NET_VCA_RECT struMaxRect;
        }

        /// <summary>
        /// 警戒规则结构
        /// </summary>
        //警戒规则结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_ONE_RULE
        {
            /// <summary>
            /// 是否激活规则,0-否,非0-是
            /// </summary>
            public byte byActive;
            /// <summary>
            /// 保留，设置为0字段
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 异常行为识别事件类型
            /// </summary>
            public VCA_EVENT_TYPE dwEventType;
            /// <summary>
            /// 异常行为识别事件参数
            /// </summary>
            public NET_VCA_EVENT_UNION uEventParam;
            /// <summary>
            /// 尺寸过滤器
            /// </summary>
            public NET_VCA_SIZE_FILTER struSizeFilter;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_2, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 struHandleType;
            /// <summary>
            /// 报警触发的录象通道,为1表示触发该通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
        }

        /// <summary>
        /// 异常行为识别配置结构体
        /// </summary>
        //异常行为识别配置结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_RULECFG
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 报警时图片处理方式 0-不处理 非0-上传
            /// </summary>
            public byte byPicProType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 图片规格结构
            /// </summary>
            public NET_DVR_JPEGPARA struPictureParam;
            /// <summary>
            /// 规则数组
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RULE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_ONE_RULE[] struRule;
        }

        /// <summary>
        /// 尺寸过滤策略
        /// </summary>
        //尺寸过滤策略
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FILTER_STRATEGY
        {
            /// <summary>
            /// 尺寸过滤策略 0 - 不启用 1-高度和宽度过滤,2-面积过滤
            /// </summary>
            public byte byStrategy;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 规则触发参数
        /// </summary>
        //规则触发参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_RULE_TRIGGER_PARAM
        {
            /// <summary>
            /// 规则的触发方式，0- 不启用，1- 点 2- 目标面积
            /// </summary>
            public byte byTriggerMode;
            /// <summary>
            /// 触发点，触发方式为点时有效 0- 中,1-上,2-下
            /// </summary>
            public byte byTriggerPoint;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 触发目标面积百分比 [0,100]，触发方式为目标面积时有效
            /// </summary>
            public float fTriggerArea;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 警戒规则结构
        /// </summary>
        //警戒规则结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_ONE_RULE_V41
        {
            /// <summary>
            /// 是否激活规则,0-否,非0-是
            /// </summary>
            public byte byActive;
            /// <summary>
            /// 保留，设置为0字段
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 行为事件类型扩展，用于代替字段dwEventType，参考VCA_RULE_EVENT_TYPE_EX
            /// </summary>
            public ushort wEventTypeEx;
            /// <summary>
            /// 规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 行为事件类型，保留是为了兼容，后续建议使用wEventTypeEx获取事件类型
            /// </summary>
            public uint dwEventType;
            /// <summary>
            /// 异常行为识别事件参数
            /// </summary>
            public NET_VCA_EVENT_UNION uEventParam;
            /// <summary>
            /// 尺寸过滤器
            /// </summary>
            public NET_VCA_SIZE_FILTER struSizeFilter;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 struHandleType;
            /// <summary>
            /// 报警触发的录象通道,为1表示触发该通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
            /// <summary>
            /// 智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
            /// </summary>
            public ushort wAlarmDelay;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 尺寸过滤策略
            /// </summary>
            public NET_VCA_FILTER_STRATEGY struFilterStrategy;
            /// <summary>
            /// 规则触发参数
            /// </summary>
            public NET_VCA_RULE_TRIGGER_PARAM struTriggerParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 异常行为识别配置结构体
        /// </summary>
        //异常行为识别配置结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_RULECFG_V41
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 报警时图片处理方式 0-不处理 非0-上传
            /// </summary>
            public byte byPicProType;
            /// <summary>
            /// 2011-04-06 是否先上传最近一次的报警
            /// </summary>
            public byte byUpLastAlarm;
            /// <summary>
            /// 2012-3-1是否启用图片存储, 0-不启用, 1-启用
            /// </summary>
            public byte byPicRecordEnable;
            public byte byRes1;
            /// <summary>
            /// 图片规格结构
            /// </summary>
            public NET_DVR_JPEGPARA struPictureParam;
            /// <summary>
            /// 规则数组
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RULE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_ONE_RULE_V41[] struRule;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 简化目标结构体
        /// </summary>
        //简化目标结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_TARGET_INFO
        {
            /// <summary>
            /// 目标ID ,人员密度过高报警时为0
            /// </summary>
            public uint dwID;
            /// <summary>
            /// 目标边界框
            /// </summary>
            public NET_VCA_RECT struRect;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 简化的规则信息, 包含规则的基本信息
        /// </summary>
        //简化的规则信息, 包含规则的基本信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_RULE_INFO
        {
            /// <summary>
            /// 规则ID,0-7
            /// </summary>
            public byte byRuleID;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byRes;
            /// <summary>
            /// 行为事件类型扩展，用于代替字段dwEventType，参考VCA_RULE_EVENT_TYPE_EX
            /// </summary>
            public ushort wEventTypeEx;
            /// <summary>
            /// 规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 警戒事件类型
            /// </summary>
            public VCA_EVENT_TYPE dwEventType;
            /// <summary>
            /// 事件参数
            /// </summary>
            public NET_VCA_EVENT_UNION uEventParam;
        }

        /// <summary>
        /// 前端设备地址信息，智能分析仪表示的是前端设备的地址信息，其他设备表示本机的地址
        /// </summary>
        //前端设备地址信息，智能分析仪表示的是前端设备的地址信息，其他设备表示本机的地址
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_DEV_INFO
        {
            /// <summary>
            /// 前端设备地址，
            /// </summary>
            public NET_DVR_IPADDR struDevIP;
            /// <summary>
            /// 前端设备端口号，
            /// </summary>
            public ushort wPort;
            /// <summary>
            /// 前端设备通道，
            /// </summary>
            public byte byChannel;
            /// <summary>
            /// 保留字节
            /// </summary>
            public byte byIvmsChannel;
        }

        /// <summary>
        /// 异常行为识别结果上报结构
        /// </summary>
        //异常行为识别结果上报结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_RULE_ALARM
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 事件规则信息
            /// </summary>
            public NET_VCA_RULE_INFO struRuleInfo;
            /// <summary>
            /// 报警目标信息
            /// </summary>
            public NET_VCA_TARGET_INFO struTargetInfo;
            /// <summary>
            /// 前端设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据*/
            /// </summary>
            public uint dwPicDataLen;
            /// <summary>
            /// 0-普通图片 1-对比图片
            /// </summary>
            public byte byPicType;
            /// <summary>
            /// 关联通道报警图片数量
            /// </summary>
            public byte byRelAlarmPicNum;
            /// <summary>
            /// IDS设备返回0(默认值)，Smart Functiom Return 1
            /// </summary>
            public byte bySmart;
            /// <summary>
            /// 图片数据传输方式: 0-二进制；1-url
            /// </summary>
            public byte byPicTransType;
            /// <summary>
            /// 报警ID，用以标识通道间关联产生的组合报警，0表示无效
            /// </summary>
            public uint dwAlarmID;
            /// <summary>
            /// 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
            /// </summary>
            public ushort wDevInfoIvmsChannelEx;
            /// <summary>
            /// dwRelativeTime字段是否有效  0-无效， 1-有效，dwRelativeTime表示UTC时间
            /// </summary>
            public byte byRelativeTimeFlag;
            /// <summary>
            /// 附加信息上传使能 0-不上传 1-上传
            /// </summary>
            public byte byAppendInfoUploadEnabled;
            /// <summary>
            /// 指向附加信息NET_VCA_APPEND_INFO的指针，byAppendInfoUploadEnabled为1时或者byTimeDiffFlag为1时有效
            /// </summary>
            public IntPtr pAppendInfo;
            /// <summary>
            /// 指向图片的指针
            /// </summary>
            public IntPtr pImage;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SYSTEM_TIME
        {
            /// <summary>
            /// 年
            /// </summary>
            public ushort wYear;
            /// <summary>
            /// 月
            /// </summary>
            public ushort wMonth;
            /// <summary>
            /// 日
            /// </summary>
            public ushort wDay;
            /// <summary>
            /// 时
            /// </summary>
            public ushort wHour;
            /// <summary>
            /// 分
            /// </summary>
            public ushort wMinute;
            /// <summary>
            /// 秒
            /// </summary>
            public ushort wSecond;
            /// <summary>
            /// 毫秒
            /// </summary>
            public ushort wMilliSec;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 设备支持AI开放平台接入，上传视频检测数据
        /// </summary>
        //设备支持AI开放平台接入，上传视频检测数据
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_AIOP_VIDEO_HEAD
        {
            /// <summary>
            /// dwSize = sizeof(NET_AIOP_VIDEO_HEAD)
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 设备分析通道的通道号；
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 时间
            /// </summary>
            public NET_DVR_SYSTEM_TIME struTime;
            /// <summary>
            /// 视频任务ID，来自于视频任务派发
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] szTaskID;
            /// <summary>
            /// 对应AIOPDdata数据长度
            /// </summary>
            public uint dwAIOPDataSize;
            /// <summary>
            /// 对应分析图片长度
            /// </summary>
            public uint dwPictureSize;
            /// <summary>
            /// 检测模型包ID，用于匹配AIOP的检测数据解析；可以通过URI(GET /ISAPI/Intelligent/AIOpenPlatform/algorithmModel/management?format=json)获取当前设备加载的模型包的label description信息；
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] szMPID;
            /// <summary>
            /// AIOPDdata数据
            /// </summary>
            public IntPtr pBufferAIOPData;
            /// <summary>
            /// 对应分析图片数据
            /// </summary>
            public IntPtr pBufferPicture;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 184, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 设备支持AI开放平台接入，上传图片检测数据
        /// </summary>
        //设备支持AI开放平台接入，上传图片检测数据
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_AIOP_PICTURE_HEAD
        {
            /// <summary>
            /// dwSize = sizeof(NET_AIOP_PICTURE_HEAD)
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 时间
            /// </summary>
            public NET_DVR_SYSTEM_TIME struTime;
            /// <summary>
            /// 透传下发的图片ID，来自于图片任务派发
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] szPID;
            /// <summary>
            /// 对应AIOPDdata数据长度
            /// </summary>
            public uint dwAIOPDataSize;
            /// <summary>
            /// 状态值：0-成功，1-图片大小错误
            /// </summary>
            public byte byStatus;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 检测模型包ID，用于匹配AIOP的检测数据解析；
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] szMPID;
            /// <summary>
            /// AIOPDdata数据
            /// </summary>
            public IntPtr pBufferAIOPData;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 184, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_AIOP_POLLING_VIDEO_HEAD
        {
            /// <summary>
            /// dwSize = sizeof(NET_AIOP_POLLING_VIDEO_HEAD)
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 设备分析通道的通道号(走SDK协议)；
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 时间
            /// </summary>
            public NET_DVR_SYSTEM_TIME struTime;
            /// <summary>
            /// 轮询抓图任务ID，来自于轮询抓图任务派发
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] szTaskID;
            /// <summary>
            /// 对应AIOPDdata数据长度
            /// </summary>
            public uint dwAIOPDataSize;
            /// <summary>
            /// 对应分析图片长度
            /// </summary>
            public uint dwPictureSize;
            /// <summary>
            /// 检测模型包ID，用于匹配AIOP的检测数据解析；
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] szMPID;
            /// <summary>
            /// AIOPDdata数据
            /// </summary>
            public IntPtr pBufferAIOPData;
            /// <summary>
            /// 对应分析图片数据
            /// </summary>
            public IntPtr pBufferPicture;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 184, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_AIOP_POLLING_SNAP_HEAD
        {
            /// <summary>
            /// dwSize = sizeof(NET_AIOP_POLLING_SNAP_HEAD)
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 设备分析通道的通道号(走SDK协议)；
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 时间
            /// </summary>
            public NET_DVR_SYSTEM_TIME struTime;
            /// <summary>
            /// 轮询抓图任务ID，来自于轮询抓图任务派发
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] szTaskID;
            /// <summary>
            /// 对应AIOPDdata数据长度
            /// </summary>
            public uint dwAIOPDataSize;
            /// <summary>
            /// 对应分析图片长度
            /// </summary>
            public uint dwPictureSize;
            /// <summary>
            /// 检测模型包ID，用于匹配AIOP的检测数据解析；
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] szMPID;
            /// <summary>
            /// AIOPDdata数据
            /// </summary>
            public IntPtr pBufferAIOPData;
            /// <summary>
            /// 分析图片数据
            /// </summary>
            public IntPtr pBufferPicture;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 184, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 异常行为识别规则DSP信息叠加结构
        /// </summary>
        //异常行为识别规则DSP信息叠加结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_DRAW_MODE
        {
            public uint dwSize;
            /// <summary>
            /// 编码是否叠加目标
            /// </summary>
            public byte byDspAddTarget;
            /// <summary>
            /// 编码是否叠加规则
            /// </summary>
            public byte byDspAddRule;
            /// <summary>
            /// 抓图是否叠加目标
            /// </summary>
            public byte byDspPicAddTarget;
            /// <summary>
            /// 抓图是否叠加规则
            /// </summary>
            public byte byDspPicAddRule;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 物体类型
        /// </summary>
        public enum OBJECT_TYPE_ENUM
        {
            /// <summary>
            /// 上衣
            /// </summary>
            ENUM_OBJECT_TYPE_COAT = 1
        }

        /// <summary>
        /// 物体颜色条件结构体
        /// </summary>
        //物体颜色条件结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_OBJECT_COLOR_COND
        {
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 物体类型，参见OBJECT_TYPE_ENUM
            /// </summary>
            public uint dwObjType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 图片参数
        /// </summary>
        //图片参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PIC
        {
            /// <summary>
            /// 图片类型，1-jpg
            /// </summary>
            public byte byPicType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 图片宽度
            /// </summary>
            public uint dwPicWidth;
            /// <summary>
            /// 图片高度
            /// </summary>
            public uint dwPicHeight;
            /// <summary>
            /// 图片数据实际大小
            /// </summary>
            public uint dwPicDataLen;
            /// <summary>
            /// 图片数据缓冲区大小
            /// </summary>
            public uint dwPicDataBuffLen;
            /// <summary>
            /// 图片数据缓冲区
            /// </summary>
            public IntPtr byPicDataBuff;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 颜色联合体
        /// </summary>
        //颜色联合体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_OBJECT_COLOR_UNION
        {
            /// <summary>
            /// 颜色值
            /// </summary>
            public NET_DVR_COLOR struColor;
            /// <summary>
            /// 图片
            /// </summary>
            public NET_DVR_PIC struPicture;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 物体颜色参数结构体
        /// </summary>
        //物体颜色参数结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_OBJECT_COLOR
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 0-不启用，1-启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 取色方式，1-颜色值，2-图片
            /// </summary>
            public byte byColorMode;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 物体颜色联合体，取值依赖于取色方式
            /// </summary>
            public NET_DVR_OBJECT_COLOR_UNION uObjColor;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 区域类型
        /// </summary>
        public enum AREA_TYPE_ENUM
        {
            /// <summary>
            /// 共同区域
            /// </summary>
            ENUM_OVERLAP_REGION = 1,
            /// <summary>
            /// 床铺位置
            /// </summary>
            ENUM_BED_LOCATION = 2
        }

        /// <summary>
        /// 辅助区域
        /// </summary>
        //辅助区域
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AUXAREA
        {
            /// <summary>
            /// 区域类型，参见AREA_TYPE_ENUM
            /// </summary>
            public uint dwAreaType;
            /// <summary>
            /// 0-不启用，1-启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 区域
            /// </summary>
            public NET_VCA_POLYGON struPolygon;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 辅助区域列表
        /// </summary>
        //辅助区域列表
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AUXAREA_LIST
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 辅助区域
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_AUXAREA_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_AUXAREA[] struArea;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 通道工作模式
        /// </summary>
        public enum CHAN_WORKMODE_ENUM
        {
            /// <summary>
            /// 独立模式
            /// </summary>
            ENUM_CHAN_WORKMODE_INDEPENDENT = 1,
            /// <summary>
            /// 主模式
            /// </summary>
            ENUM_CHAN_WORKMODE_MASTER = 2,
            /// <summary>
            /// 从模式
            /// </summary>
            ENUM_CHAN_WORKMODE_SLAVE = 3
        }

        /// <summary>
        /// 通道工作模式参数结构体
        /// </summary>
        //通道工作模式参数结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CHANNEL_WORKMODE
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 工作模式，参见CHAN_WORKMODE_ENUM
            /// </summary>
            public byte byWorkMode;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 63, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 设备通道参数结构体
        /// </summary>
        //设备通道参数结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CHANNEL
        {
            /// <summary>
            /// 设备IP或域名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byAddress;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDVRPort;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 主机用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 主机密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 从通道信息联合体
        /// </summary>
        //从通道信息联合体
        [StructLayout(LayoutKind.Explicit)]
        public struct NET_DVR_SLAVE_CHANNEL_UNION
        {
            /// <summary>
            /// 联合体大小
            /// </summary>
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 152, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 从通道参数结构体
        /// </summary>
        //从通道参数结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SLAVE_CHANNEL_PARAM
        {
            /// <summary>
            /// 从通道类型，1-本机通道，2-远程通道
            /// </summary>
            public byte byChanType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 从通道联合体，取值依赖于byChanType
            /// </summary>
            public NET_DVR_SLAVE_CHANNEL_UNION uSlaveChannel;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 从通道参数配置结构体
        /// </summary>
        //从通道参数配置结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SLAVE_CHANNEL_CFG
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 从通道参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SLAVE_CHANNEL_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SLAVE_CHANNEL_PARAM[] struChanParam;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 视频质量诊断检测事件
        /// </summary>
        public enum VQD_EVENT_ENUM
        {
            /// <summary>
            /// 图像模糊
            /// </summary>
            ENUM_VQD_EVENT_BLUR = 1,
            /// <summary>
            /// 亮度异常
            /// </summary>
            ENUM_VQD_EVENT_LUMA = 2,
            /// <summary>
            /// 图像偏色
            /// </summary>
            ENUM_VQD_EVENT_CHROMA = 3,
            /// <summary>
            /// 雪花干扰
            /// </summary>
            ENUM_VQD_EVENT_SNOW = 4,
            /// <summary>
            /// 条纹干扰
            /// </summary>
            ENUM_VQD_EVENT_STREAK = 5,
            /// <summary>
            /// 画面冻结
            /// </summary>
            ENUM_VQD_EVENT_FREEZE = 6,
            /// <summary>
            /// 信号丢失
            /// </summary>
            ENUM_VQD_EVENT_SIGNAL_LOSS = 7,
            /// <summary>
            /// 云台失控
            /// </summary>
            ENUM_VQD_EVENT_PTZ = 8,
            /// <summary>
            /// 场景突变
            /// </summary>
            ENUM_VQD_EVENT_SCNENE_CHANGE = 9,
            /// <summary>
            /// 视频异常
            /// </summary>
            ENUM_VQD_EVENT_VIDEO_ABNORMAL = 10,
            /// <summary>
            /// 视频遮挡
            /// </summary>
            ENUM_VQD_EVENT_VIDEO_BLOCK = 11
        }

        /// <summary>
        /// 视频质量诊断事件条件结构体
        /// </summary>
        //视频质量诊断事件条件结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VQD_EVENT_COND
        {
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 检测事件类型，参见VQD_EVENT_ENUM
            /// </summary>
            public uint dwEventType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 视频质量诊断事件参数
        /// </summary>
        //视频质量诊断事件参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VQD_EVENT_PARAM
        {
            /// <summary>
            /// 报警阈值，范围[0,100]
            /// </summary>
            public byte byThreshold;
            /// <summary>
            /// 1-持续触发，2-单次触发
            /// </summary>
            public byte byTriggerMode;
            /// <summary>
            /// 0-不上传图片，1-上传图片，无论是否上传图片，事后都可以从设备获取该事件所对应最新的一张报警图片，参见接口NET_DVR_StartDownload
            /// </summary>
            public byte byUploadPic;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// 持续触发报警时间间隔，范围[0,3600] 单位：秒
            /// </summary>
            public uint dwTimeInterval;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 视频质量诊断事件规则
        /// </summary>
        //视频质量诊断事件规则
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VQD_EVENT_RULE
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 0-不启用，1-启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 视频质量诊断事件参数
            /// </summary>
            public NET_DVR_VQD_EVENT_PARAM struEventParam;
            /// <summary>
            /// 检测时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 struHandleType;
            /// <summary>
            /// 报警触发的录象通道：1表示触发该通道；0表示不触发
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IVMS_IP_CHANNEL, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 基准场景参数
        /// </summary>
        //基准场景参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_BASELINE_SCENE
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 0-不启用，1-启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 63, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 基准场景操作参数结构体
        /// </summary>
        //基准场景操作参数结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CONTROL_BASELINE_SCENE_PARAM
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 操作类型，1-此字段保留，暂不使用，2-更新基准场景
            /// </summary>
            public byte byCommand;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 127, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 视频质量诊断报警结构体
        /// </summary>
        //视频质量诊断报警结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VQD_ALARM
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 前端设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 事件类型，参考VQD_EVENT_ENUM
            /// </summary>
            public uint dwEventType;
            /// <summary>
            /// 报警阈值[0.000,1.000]
            /// </summary>
            public float fThreshold;
            /// <summary>
            /// 图片长度，为0表示没有图片
            /// </summary>
            public uint dwPicDataLen;
            /// <summary>
            /// 指向图片的指针
            /// </summary>
            public IntPtr pImage;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 标定点子结构
        /// </summary>
        //标定点子结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CB_POINT
        {
            /// <summary>
            /// 标定点，主摄像机（枪机）
            /// </summary>
            public NET_VCA_POINT struPoint;
            /// <summary>
            /// 球机输入的PTZ坐标
            /// </summary>
            public NET_DVR_PTZPOS struPtzPos;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 标定参数配置结构
        /// </summary>
        //标定参数配置结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TRACK_CALIBRATION_PARAM
        {
            /// <summary>
            /// 有效标定点个数
            /// </summary>
            public byte byPointNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 标定点组
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CALIB_PT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CB_POINT[] struCBPoint;
        }

        /// <summary>
        /// 球机配置结构
        /// </summary>
        //球机配置结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TRACK_CFG
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 标定使能
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 被控制的从通道
            /// </summary>
            public byte byFollowChan;
            /// <summary>
            /// 设置智能球机标定，1设置 0不设置
            /// </summary>
            public byte byDomeCalibrate;
            /// <summary>
            /// 保留字节
            /// </summary>
            public byte byRes;
            /// <summary>
            /// 标定点组
            /// </summary>
            public NET_DVR_TRACK_CALIBRATION_PARAM struCalParam;
        }

        /// <summary>
        /// 模式
        /// </summary>
        public enum TRACK_MODE
        {
            /// <summary>
            /// 手动
            /// </summary>
            MANUAL_CTRL = 0,
            /// <summary>
            /// 报警触发
            /// </summary>
            ALARM_TRACK
        }

        /// <summary>
        /// 手动控制结构
        /// </summary>
        //手动控制结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MANUAL_CTRL_INFO
        {
            public NET_VCA_POINT struCtrlPoint;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 模式结构
        /// </summary>
        //模式结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TRACK_MODE
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 模式
            /// </summary>
            public byte byTrackMode;
            /// <summary>
            /// 规则配置模式0-本地配置，1-远程配置
            /// </summary>
            public byte byRuleConfMode;
            /// <summary>
            /// 保留，置0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARM_JPEG
        {
            /// <summary>
            /// 报警时图片处理方式 0-不处理 1-上传
            /// </summary>
            public byte byPicProType;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 图片规格结构
            /// </summary>
            public NET_DVR_JPEGPARA struPicParam;
        }

        /// <summary>
        /// 分析仪异常行为识别规则结构
        /// 警戒规则结构
        /// </summary>
        //分析仪异常行为识别规则结构
        //警戒规则结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_IVMS_ONE_RULE
        {
            /// <summary>
            /// 是否激活规则,0-否, 非0-是
            /// </summary>
            public byte byActive;
            /// <summary>
            /// 保留，设置为0字段
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 异常行为识别事件类型
            /// </summary>
            public VCA_EVENT_TYPE dwEventType;
            /// <summary>
            /// 异常行为识别事件参数
            /// </summary>
            public NET_VCA_EVENT_UNION uEventParam;
            /// <summary>
            /// 尺寸过滤器
            /// </summary>
            public NET_VCA_SIZE_FILTER struSizeFilter;
            /// <summary>
            /// 保留，设置为0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 68, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 分析仪规则结构
        /// </summary>
        // 分析仪规则结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_IVMS_RULECFG
        {
            /// <summary>
            /// 规则数组
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RULE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_IVMS_ONE_RULE[] struRule;
        }

        /// <summary>
        /// IVMS异常行为识别配置结构
        /// </summary>
        // IVMS异常行为识别配置结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_IVMS_BEHAVIORCFG
        {
            public uint dwSize;
            /// <summary>
            /// 报警时图片处理方式 0-不处理 非0-上传
            /// </summary>
            public byte byPicProType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 图片规格结构
            /// </summary>
            public NET_DVR_JPEGPARA struPicParam;
            /// <summary>
            /// 每个时间段对应规则
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT, ArraySubType = UnmanagedType.Struct)]
            public NET_IVMS_RULECFG[] struRuleCfg;
        }

        /// <summary>
        /// 智能分析仪取流计划子结构
        /// </summary>
        //智能分析仪取流计划子结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_IVMS_DEVSCHED
        {
            /// <summary>
            /// 时间参数
            /// </summary>
            public NET_DVR_SCHEDTIME struTime;
            /// <summary>
            /// 前端取流参数
            /// </summary>
            public NET_DVR_PU_STREAM_CFG struPUStream;
        }

        /// <summary>
        /// 智能分析仪参数配置结构
        /// </summary>
        //智能分析仪参数配置结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_IVMS_STREAMCFG
        {
            public uint dwSize;
            /// <summary>
            /// 按时间段配置前端取流以及规则信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT, ArraySubType = UnmanagedType.Struct)]
            public NET_IVMS_DEVSCHED[] struDevSched;
        }

        /// <summary>
        /// 屏蔽区域
        /// </summary>
        //屏蔽区域
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_MASK_REGION
        {
            /// <summary>
            /// 是否激活, 0-否，非0-是
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留，置0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 屏蔽多边形
            /// </summary>
            public NET_VCA_POLYGON struPolygon;
        }

        /// <summary>
        /// 屏蔽区域链表结构
        /// </summary>
        //屏蔽区域链表结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_MASK_REGION_LIST
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 保留，置0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 屏蔽区域数组
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_MASK_REGION_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_MASK_REGION[] struMask;
        }

        /// <summary>
        /// ATM进入区域参数
        /// </summary>
        //ATM进入区域参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_ENTER_REGION
        {
            public uint dwSize;
            /// <summary>
            /// 是否激活，0-否，非0-是
            /// </summary>
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 进入区域
            /// </summary>
            public NET_VCA_POLYGON struPolygon;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// IVMS屏蔽区域链表
        /// </summary>
        //IVMS屏蔽区域链表
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_IVMS_MASK_REGION_LIST
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_MASK_REGION_LIST[] struList;
        }

        /// <summary>
        /// IVMS的ATM进入区域参数
        /// </summary>
        //IVMS的ATM进入区域参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_IVMS_ENTER_REGION
        {
            public uint dwSize;
            /// <summary>
            /// 进入区域
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_ENTER_REGION[] struEnter;
        }

        /// <summary>
        /// ivms 报警图片上传结构
        /// </summary>
        // ivms 报警图片上传结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_IVMS_ALARM_JPEG
        {
            public byte byPicProType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public NET_DVR_JPEGPARA struPicParam;
        }

        /// <summary>
        /// IVMS 后检索配置
        /// </summary>
        // IVMS 后检索配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_IVMS_SEARCHCFG
        {
            public uint dwSize;
            /// <summary>
            /// 远程回放
            /// </summary>
            public NET_DVR_MATRIX_DEC_REMOTE_PLAY struRemotePlay;
            /// <summary>
            /// 报警上传图片配置
            /// </summary>
            public NET_IVMS_ALARM_JPEG struAlarmJpeg;
            /// <summary>
            /// IVMS 行为规则配置
            /// </summary>
            public NET_IVMS_RULECFG struRuleCfg;
        }

        /// <summary>
        /// **********************************end*****************************************
        /// NAS认证配置
        /// </summary>
        /************************************end******************************************/
        //NAS认证配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IDENTIFICATION_PARAM
        {
            /// <summary>
            /// 用户名 32
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码 16
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_DVR_MOUNT_PARAM_UNION
        {
            /// <summary>
            /// 联合体结构大小
            /// </summary>
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 52, ArraySubType = UnmanagedType.I1)]
            public byte[] uLen;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_NAS_MOUNT_PARAM
        {
            /// <summary>
            /// 0～保留,1~NFS, 2~ SMB/CIFS
            /// </summary>
            public byte byMountType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public NET_DVR_MOUNT_PARAM_UNION uMountParam;
        }

        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_DVR_MOUNTMETHOD_PARAM_UNION
        {
            /// <summary>
            /// 联合体结构大小
            /// </summary>
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 56, ArraySubType = UnmanagedType.I1)]
            public byte[] uLen;
        }

        /// <summary>
        /// 网络硬盘结构配置
        /// </summary>
        //网络硬盘结构配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SINGLE_NET_DISK_INFO
        {
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 网络硬盘地址
            /// </summary>
            public NET_DVR_IPADDR struNetDiskAddr;
            /// <summary>
            /// PATHNAME_LEN = 128
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PATHNAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sDirectory;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 68, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        public const int MAX_NET_DISK = 16;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_NET_DISKCFG
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NET_DISK, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SINGLE_NET_DISK_INFO[] struNetDiskParam;
        }

        /// <summary>
        /// 事件类型
        /// 主类型
        /// </summary>
        public enum MAIN_EVENT_TYPE
        {
            /// <summary>
            /// 移动侦测
            /// </summary>
            EVENT_MOT_DET = 0,
            /// <summary>
            /// 报警输入
            /// </summary>
            EVENT_ALARM_IN = 1,
            /// <summary>
            /// 异常行为识别
            /// </summary>
            EVENT_VCA_BEHAVIOR = 2,
            /// <summary>
            /// 审讯事件
            /// </summary>
            EVENT_INQUEST = 3,
            /// <summary>
            /// 智能侦测
            /// </summary>
            EVENT_VCA_DETECTION = 4,
            /// <summary>
            /// 流ID信息
            /// </summary>
            EVENT_STREAM_INFO = 100
        }
        /// <summary>
        /// 讯问开始信息
        /// </summary>
        public const int INQUEST_START_INFO = 0x1001;
        /// <summary>
        /// 讯问停止信息
        /// </summary>
        public const int INQUEST_STOP_INFO = 0x1002;
        /// <summary>
        /// 重点标记信息
        /// </summary>
        public const int INQUEST_TAG_INFO = 0x1003;
        /// <summary>
        /// 审讯片断状态信息
        /// </summary>
        public const int INQUEST_SEGMENT_INFO = 0x1004;

        public enum VCA_DETECTION_MINOR_TYPE : uint
        {
            /// <summary>
            /// 越警侦测
            /// </summary>
            EVENT_VCA_TRAVERSE_PLANE = 1,
            /// <summary>
            /// 区域入侵侦测
            /// </summary>
            EVENT_FIELD_DETECTION,
            /// <summary>
            /// 音频输入异常
            /// </summary>
            EVENT_AUDIO_INPUT_ALARM,
            /// <summary>
            /// 声强突变侦测
            /// </summary>
            EVENT_SOUND_INTENSITY_ALARM,
            /// <summary>
            /// 人脸侦测
            /// </summary>
            EVENT_FACE_DETECTION,
            /// <summary>
            /// 虚焦侦测
            /// </summary>
            EVENT_VIRTUAL_FOCUS_ALARM,
            /// <summary>
            /// 场景变更侦测
            /// </summary>
            EVENT_SCENE_CHANGE_ALARM,
            /// <summary>
            /// 表示全部
            /// </summary>
            EVENT_ALL = 0xffffffff
        }

        /// <summary>
        /// 异常行为识别主类型对应的此类型， 0xffff表示全部
        /// </summary>
        public enum BEHAVIOR_MINOR_TYPE
        {
            /// <summary>
            /// 穿越警戒面,
            /// </summary>
            EVENT_TRAVERSE_PLANE = 0,
            /// <summary>
            /// 目标进入区域,支持区域规则
            /// </summary>
            EVENT_ENTER_AREA,
            /// <summary>
            /// 目标离开区域,支持区域规则
            /// </summary>
            EVENT_EXIT_AREA,
            /// <summary>
            /// 周界入侵,支持区域规则
            /// </summary>
            EVENT_INTRUSION,
            /// <summary>
            /// 徘徊,支持区域规则
            /// </summary>
            EVENT_LOITER,
            /// <summary>
            /// 丢包捡包,支持区域规则
            /// </summary>
            EVENT_LEFT_TAKE,
            /// <summary>
            /// 停车,支持区域规则
            /// </summary>
            EVENT_PARKING,
            /// <summary>
            /// 奔跑,支持区域规则
            /// </summary>
            EVENT_RUN,
            /// <summary>
            /// 区域内人员密度,支持区域规则
            /// </summary>
            EVENT_HIGH_DENSITY,
            /// <summary>
            /// 贴纸条,支持区域规则
            /// </summary>
            EVENT_STICK_UP,
            /// <summary>
            /// 安装读卡器,支持区域规则
            /// </summary>
            EVENT_INSTALL_SCANNER,
            /// <summary>
            /// 操作超时
            /// </summary>
            EVENT_OPERATE_OVER_TIME,
            /// <summary>
            /// 异常人脸
            /// </summary>
            EVENT_FACE_DETECT,
            /// <summary>
            /// 丢包捡包,支持区域规则
            /// </summary>
            EVENT_LEFT,
            /// <summary>
            /// 物品拿取
            /// </summary>
            EVENT_TAKE,
            /// <summary>
            /// 高危目标岗位检测-离岗事件
            /// </summary>
            EVENT_LEAVE_POSITION,
            /// <summary>
            /// 尾随
            /// </summary>
            EVENT_TRAIL_INFO = 16,
            /// <summary>
            /// 倒地
            /// </summary>
            EVENT_FALL_DOWN_INFO = 19,
            /// <summary>
            /// 异物粘贴区域
            /// </summary>
            EVENT_OBJECT_PASTE = 20,
            /// <summary>
            /// 正常人脸
            /// </summary>
            EVENT_FACE_CAPTURE_INFO = 21,
            /// <summary>
            /// 多张人脸
            /// </summary>
            EVENT_MULTI_FACES_INFO = 22,
            /// <summary>
            /// 声强突变
            /// </summary>
            EVENT_AUDIO_ABNORMAL_INFO = 23,
            /// <summary>
            /// 智能侦测
            /// </summary>
            EVENT_DETECT = 24
        }

        /// <summary>
        /// 主类型100，对应的小类型
        /// </summary>
        public enum STREAM_INFO_MINOR_TYPE
        {
            /// <summary>
            /// 流ID
            /// </summary>
            EVENT_STREAM_ID = 0,
            /// <summary>
            /// 定时录像
            /// </summary>
            EVENT_TIMING = 1,
            /// <summary>
            /// 移动侦测
            /// </summary>
            EVENT_MOTION_DETECT = 2,
            /// <summary>
            /// 报警录像
            /// </summary>
            EVENT_ALARM = 3,
            /// <summary>
            /// 报警或移动侦测
            /// </summary>
            EVENT_ALARM_OR_MOTION_DETECT = 4,
            /// <summary>
            /// 报警和移动侦测
            /// </summary>
            EVENT_ALARM_AND_MOTION_DETECT = 5,
            /// <summary>
            /// 命令触发
            /// </summary>
            EVENT_COMMAND_TRIGGER = 6,
            /// <summary>
            /// 手动录像
            /// </summary>
            EVENT_MANNUAL = 7,
            /// <summary>
            /// 存档卷录像
            /// </summary>
            EVENT_BACKUP_VOLUME = 8
        }
        /// <summary>
        /// 邦诺CVR
        /// </summary>
        public const int MAX_ID_COUNT = 256;
        public const int MAX_STREAM_ID_COUNT = 1024;
        public const int STREAM_ID_LEN = 32;
        public const int PLAN_ID_LEN = 32;

        /// <summary>
        /// 流信息 - 72字节长
        /// </summary>
        // 流信息 - 72字节长
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_STREAM_INFO
        {
            public uint dwSize;
            /// <summary>
            /// ID数据
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = STREAM_ID_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byID;
            /// <summary>
            /// 关联设备通道，等于0xffffffff时，表示不关联
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 事件搜索条件 200-04-07 9000_1.1
        /// </summary>
        public const int SEARCH_EVENT_INFO_LEN = 300;

        /// <summary>
        /// 报警输入
        /// </summary>
        //报警输入
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_ALARM_BYBIT
        {
            /// <summary>
            /// 报警输入号，byAlarmInNo[0]若置1则表示查找由报警输入1触发的事件
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMIN_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmInNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SEARCH_EVENT_INFO_LEN - MAX_ALARMIN_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 报警输入 按值表示
        /// </summary>
        //报警输入 按值表示
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_ALARM_BYVALUE
        {
            /// <summary>
            /// 报警输入号，byAlarmInNo[0]若置1则表示查找由报警输入1触发的事件
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.U2)]
            public ushort[] wAlarmInNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 44, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 移动侦测
        /// </summary>
        //移动侦测
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_MOTION_BYBIT
        {
            /// <summary>
            /// 移动侦测通道，byMotDetChanNo[0]若置1则表示查找由通道1发生移动侦测触发的事件
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byMotDetChanNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SEARCH_EVENT_INFO_LEN - MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 移动侦测--按值
        /// </summary>
        //移动侦测--按值
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_MOTION_BYVALUE
        {
            /// <summary>
            /// 报警输入号，byAlarmInNo[0]若置1则表示查找由报警输入1触发的事件
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.U2)]
            public ushort[] wMotDetChanNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 172, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 异常行为识别
        /// </summary>
        //异常行为识别
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_VCA_BYBIT
        {
            /// <summary>
            /// 触发事件的通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byChanNo;
            /// <summary>
            /// 规则ID，0xff表示全部
            /// </summary>
            public byte byRuleID;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 235, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        /// <summary>
        /// 异常行为识别--按值方式查找
        /// </summary>
        //异常行为识别--按值方式查找 
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_VCA_BYVALUE
        {
            /// <summary>
            /// 触发事件的通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.U2)]
            public ushort[] wChanNo;
            /// <summary>
            /// 异常行为识别类型，规则0xff表示全部，从0开始
            /// </summary>
            public byte byRuleID;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 171, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 审讯事件搜索条件
        /// </summary>
        //审讯事件搜索条件
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_INQUEST_PARAM
        {
            /// <summary>
            /// 审讯室编号,从1开始
            /// </summary>
            public byte byRoomIndex;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 299, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 智能侦测查找条件
        /// </summary>
        //智能侦测查找条件
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_VCADETECT_BYBIT
        {
            /// <summary>
            /// 触发智能侦测的通道号，按数组下标表示，byChan[0]若置1则表示查找由通道1发生移动侦测触发的事件
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byChan;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 44, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 智能侦测查找条件 ，通道号按值表示
        /// </summary>
        //智能侦测查找条件 ，通道号按值表示
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_VCADETECT_BYVALUE
        {
            /// <summary>
            /// 触发通道号,按值表示，0xffffffff无效，且后续数据也表示无效值
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30 - 1, ArraySubType = UnmanagedType.U4)]
            public uint[] dwChanNo;
            /// <summary>
            /// 0-表示不是全部，1-表示全部。
            /// </summary>
            public byte byAll;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 47, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_STREAMID_PARAM
        {
            /// <summary>
            /// 流id信息，72字节长
            /// </summary>
            public NET_DVR_STREAM_INFO struIDInfo;
            /// <summary>
            /// 外部触发类型，NVR接入云存储使用
            /// </summary>
            public uint dwCmdType;
            /// <summary>
            /// 存档卷号，CVR使用
            /// </summary>
            public byte byBackupVolumeNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 223, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayout(LayoutKind.Explicit)]
        public struct SEARCH_EVENT_UNION
        {
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SEARCH_EVENT_INFO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byLen;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SEARCH_EVENT_PARAM
        {
            /// <summary>
            /// 0-移动侦测，1-报警输入, 2-智能事件
            /// </summary>
            public ushort wMajorType;
            /// <summary>
            /// 搜索次类型- 根据主类型变化，0xffff表示全部
            /// </summary>
            public ushort wMinorType;
            /// <summary>
            /// 搜索的开始时间，停止时间: 同时为(0, 0) 表示从最早的时间开始，到最后，最前面的4000个事件
            /// </summary>
            public NET_DVR_TIME struStartTime;
            public NET_DVR_TIME struEndTime;
            /// <summary>
            /// 0xff-全部，0-未锁，1-锁定
            /// </summary>
            public byte byLockType;
            /// <summary>
            /// 0-按位表示，1-按值表示
            /// </summary>
            public byte byValue;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 130, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public SEARCH_EVENT_UNION uSeniorPara;
        }

        /// <summary>
        /// 报警输入结果
        /// </summary>
        //报警输入结果
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_ALARM_RET
        {
            /// <summary>
            /// 报警输入号
            /// </summary>
            public uint dwAlarmInNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SEARCH_EVENT_INFO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 移动侦测结果
        /// </summary>
        //移动侦测结果
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_MOTION_RET
        {
            /// <summary>
            /// 移动侦测通道
            /// </summary>
            public uint dwMotDetNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SEARCH_EVENT_INFO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 异常行为识别结果
        /// </summary>
        //异常行为识别结果 
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_VCA_RET
        {
            /// <summary>
            /// 触发事件的通道号
            /// </summary>
            public uint dwChanNo;
            /// <summary>
            /// 规则ID
            /// </summary>
            public byte byRuleID;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 行为事件参数，wMinorType = VCA_EVENT_TYPE决定事件类型
            /// </summary>
            public NET_VCA_EVENT_UNION uEvent;
        }

        /// <summary>
        /// 审讯事件查询结果
        /// </summary>
        //审讯事件查询结果 
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_INQUEST_RET
        {
            /// <summary>
            /// 审讯室编号,从1开始
            /// </summary>
            public byte byRoomIndex;
            /// <summary>
            /// 刻录机编号,从1开始
            /// </summary>
            public byte byDriveIndex;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 本片断在本次审讯中的序号,从1开始
            /// </summary>
            public uint dwSegmentNo;
            /// <summary>
            /// 本片断的大小, 单位M
            /// </summary>
            public ushort wSegmetSize;
            /// <summary>
            /// 本片断状态 0 刻录正常，1 刻录异常，2 不刻录审讯
            /// </summary>
            public ushort wSegmentState;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 288, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 流id录像查询结果
        /// </summary>
        //流id录像查询结果
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct EVENT_STREAMID_RET
        {
            /// <summary>
            /// 录像类型 0-定时录像 1-移动侦测 2-报警录像 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像 7-震动报警 8-环境触发 9-智能报警 10-回传录像
            /// </summary>
            public uint dwRecordType;
            /// <summary>
            /// 录像大小
            /// </summary>
            public uint dwRecordLength;
            /// <summary>
            /// 锁定标志 0：没锁定 1：锁定
            /// </summary>
            public byte byLockFlag;
            /// <summary>
            /// 0：非抽帧录像 1：抽帧录像
            /// </summary>
            public byte byDrawFrameType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 文件名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byFileName;
            /// <summary>
            /// 存档卷上的文件索引
            /// </summary>
            public uint dwFileIndex;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayout(LayoutKind.Explicit)]
        public struct SEARCH_EVENT_RET
        {
            [FieldOffset(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 304, ArraySubType = UnmanagedType.I1)]
            public byte[] byEventRetUnion;
        }

        /// <summary>
        /// 查找返回结果
        /// </summary>
        //查找返回结果
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SEARCH_EVENT_RET
        {
            /// <summary>
            /// 主类型MA
            /// </summary>
            public ushort wMajorType;
            /// <summary>
            /// 次类型
            /// </summary>
            public ushort wMinorType;
            /// <summary>
            /// 事件开始的时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 事件停止的时间，脉冲事件时和开始时间一样
            /// </summary>
            public NET_DVR_TIME struEndTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byChan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 36, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public SEARCH_EVENT_RET uSeniorRet;
        }

        /// <summary>
        /// SDK_V35  2009-10-26
        /// 标定配置类型
        /// </summary>
        public enum tagCALIBRATE_TYPE
        {
            /// <summary>
            /// PDC 标定
            /// </summary>
            PDC_CALIBRATE = 0x01,
            /// <summary>
            /// 行为室外场景标定
            /// </summary>
            BEHAVIOR_OUT_CALIBRATE = 0x02,
            /// <summary>
            /// 行为室内场景标定
            /// </summary>
            BEHAVIOR_IN_CALIBRATE = 0x03,
            /// <summary>
            /// 交通事件标定
            /// </summary>
            ITS_CALBIRETE = 0x04
        }
        public const int MAX_RECT_NUM = 6;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RECT_LIST
        {
            /// <summary>
            /// 矩形框的个数
            /// </summary>
            public byte byRectNum;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 最大为6个Rect
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RECT_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_RECT[] struVcaRect;
        }

        /// <summary>
        /// PDC 标定参数
        /// </summary>
        // PDC 标定参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PDC_CALIBRATION
        {
            /// <summary>
            /// 标定矩形框列表
            /// </summary>
            public NET_DVR_RECT_LIST struRectList;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 120, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 标定线的属性类别，用来表示当前标定线在实际表示的是高度线还是长度线。
        /// </summary>
        public enum LINE_MODE
        {
            /// <summary>
            /// 高度样本线
            /// </summary>
            HEIGHT_LINE,
            /// <summary>
            /// 长度样本线
            /// </summary>
            LENGTH_LINE
        }

        /// <summary>
        /// 在设置标定信息的时候，如果相应位设置了使能，并设置相关参数，若没有设置使能，则标定后可以获取相关的摄像机参数
        /// </summary>
        /*在设置标定信息的时候，如果相应位设置了使能，并设置相关参数，若没有设置使能，则标定后可以获取相关的摄像机参数*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CAMERA_PARAM
        {
            /// <summary>
            /// 是否使能设置摄像机高度线
            /// </summary>
            public byte byEnableHeight;
            /// <summary>
            /// 是否使能设置摄像机俯仰角度
            /// </summary>
            public byte byEnableAngle;
            /// <summary>
            /// 是否使能设置摄像机地平线
            /// </summary>
            public byte byEnableHorizon;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 摄像机高度
            /// </summary>
            public float fCameraHeight;
            /// <summary>
            /// 摄像机俯仰角度
            /// </summary>
            public float fCameraAngle;
            /// <summary>
            /// 场景中的地平线
            /// </summary>
            public float fHorizon;
        }

        /// <summary>
        /// 当fValue表示目标高度的时候，struStartPoint和struEndPoint分别表示目标头部点和脚部点。
        /// 当fValue表示线段长度的时候，struStartPoint和struEndPoint分别表示线段起始点和终点，
        /// mode表示当前样本线表示高度线还是长度线。
        /// </summary>
        /*当fValue表示目标高度的时候，struStartPoint和struEndPoint分别表示目标头部点和脚部点。
         * 当fValue表示线段长度的时候，struStartPoint和struEndPoint分别表示线段起始点和终点，
         * mode表示当前样本线表示高度线还是长度线。*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LINE_SEGMENT
        {
            /// <summary>
            /// 参照 LINE_MODE
            /// </summary>
            public byte byLineMode;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public NET_VCA_POINT struStartPoint;
            public NET_VCA_POINT struEndPoint;
            public float fValue;
        }
        public const int MAX_LINE_SEG_NUM = 8;

        /// <summary>
        /// 标定样本线目前需要4-8调样本线，以获取摄像机相关参数
        /// </summary>
        /*标定样本线目前需要4-8调样本线，以获取摄像机相关参数*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_BEHAVIOR_OUT_CALIBRATION
        {
            /// <summary>
            /// 样本线个数
            /// </summary>
            public uint dwLineSegNum;
            /// <summary>
            /// 样本线最大个数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LINE_SEG_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_LINE_SEGMENT[] struLineSegment;
            /// <summary>
            /// 摄像机参数
            /// </summary>
            public NET_DVR_CAMERA_PARAM struCameraParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 该结构体表示IAS智能库标定样本，其中包括一个目标框和一条对应的高度标定线；
        /// 目标框为站立的人体外接矩形框；高度线样本标识从人头顶点到脚点的标定线；用归一化坐标表示；
        /// </summary>
        /*该结构体表示IAS智能库标定样本，其中包括一个目标框和一条对应的高度标定线；
         * 目标框为站立的人体外接矩形框；高度线样本标识从人头顶点到脚点的标定线；用归一化坐标表示；*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IN_CAL_SAMPLE
        {
            /// <summary>
            /// 目标框
            /// </summary>
            public NET_VCA_RECT struVcaRect;
            /// <summary>
            /// 高度标定线
            /// </summary>
            public NET_DVR_LINE_SEGMENT struLineSegment;
        }
        public const int MAX_SAMPLE_NUM = 5;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_BEHAVIOR_IN_CALIBRATION
        {
            /// <summary>
            /// 标定样本个数
            /// </summary>
            public uint dwCalSampleNum;
            /// <summary>
            /// 标定样本最大个数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SAMPLE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IN_CAL_SAMPLE[] struCalSample;
            /// <summary>
            /// 摄像机参数
            /// </summary>
            public NET_DVR_CAMERA_PARAM struCameraParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        public const int CALIB_PT_NUM = 4;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ITS_CALIBRATION
        {
            /// <summary>
            /// 标定点数
            /// </summary>
            public uint dwPointNum;
            /// <summary>
            /// 图像坐标
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = CALIB_PT_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_POINT[] struPoint;
            public float fWidth;
            public float fHeight;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 100, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        /// <summary>
        /// 标定参数联合体
        /// 后续的相关标定参数可以放在该结构里面
        /// </summary>
        // 标定参数联合体
        // 后续的相关标定参数可以放在该结构里面
        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_DVR_CALIBRATION_PRARM_UNION
        {
            /// <summary>
            /// 联合体结构大小
            /// </summary>
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 240, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 标定配置结构
        /// </summary>
        // 标定配置结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CALIBRATION_CFG
        {
            /// <summary>
            /// 标定结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 是否启用标定
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 标定类型 根据不同类型在联合体类选择不同的标定 参考CALIBRATE_TYPE
            /// </summary>
            public byte byCalibrationType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 标定参数联合体
            /// </summary>
            public NET_DVR_CALIBRATION_PRARM_UNION uCalibrateParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 流量统计方向结构体
        /// </summary>
        //流量统计方向结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PDC_ENTER_DIRECTION
        {
            /// <summary>
            /// 流量统计方向起始点
            /// </summary>
            public NET_VCA_POINT struStartPoint;
            /// <summary>
            /// 流量统计方向结束点
            /// </summary>
            public NET_VCA_POINT struEndPoint;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PDC_RULE_CFG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 是否激活规则;
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 23, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 多边形
            /// </summary>
            public NET_VCA_POLYGON struPolygon;
            /// <summary>
            /// 流量进入方向
            /// </summary>
            public NET_DVR_PDC_ENTER_DIRECTION struEnterDirection;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PDC_RULE_CFG_V41
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 是否激活规则;
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 23, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 多边形
            /// </summary>
            public NET_VCA_POLYGON struPolygon;
            /// <summary>
            /// 流量进入方向
            /// </summary>
            public NET_DVR_PDC_ENTER_DIRECTION struEnterDirection;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME struAlarmTime;
            /// <summary>
            /// 白天开始时间，时分秒有效
            /// </summary>
            public NET_DVR_TIME_EX struDayStartTime;
            /// <summary>
            /// 夜晚开始时间，时分秒有效
            /// </summary>
            public NET_DVR_TIME_EX struNightStartTime;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 100, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 试用版信息结构体
        /// </summary>
        //试用版信息结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TRIAL_VERSION_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 试用期剩余时间，0xffff表示无效，单位：天
            /// </summary>
            public ushort wReserveTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 62, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SYN_CHANNEL_NAME_PARAM
        {
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TIME_SEGMENT
        {
            /// <summary>
            /// begin time
            /// </summary>
            public NET_DVR_SIMPLE_DAYTIME struBeginTime;
            /// <summary>
            /// end time
            /// </summary>
            public NET_DVR_SIMPLE_DAYTIME struEndTime;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SINGLE_PLAN_SEGMENT
        {
            /// <summary>
            /// whether to enable, 1-enable, 0-disable
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// door status(control ladder status),0-invaild, 1-always open(free), 2-always close(forbidden), 3-ordinary status(used by door plan)
            /// </summary>
            public byte byDoorStatus;
            /// <summary>
            /// verify method, 0-invaild, 1-swipe card, 2-swipe card +password(used by card verify ) 3-swipe card(used by card verify) 4-swipe card or password(used by card verify)
            /// </summary>
            public byte byVerifyMode;
            /// <summary>
            /// 5-fingerprint, 6-fingerprint and passwd, 7-fingerprint or swipe card, 8-fingerprint and swipe card, 9-fingerprint and passwd and swipe card,
            /// 10-face or finger print or swipe card or password,11-face and finger print,12-face and password,13-face and swipe card,14-face,15-employee no and password,
            /// 16-finger print or password,17-employee no and finger print,18-employee no and finger print and password,
            /// 19-face and finger print and swipe card,20-face and password and finger print,21-employee no and face,22-face or face and swipe card
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// time segment parameter
            /// </summary>
            public NET_DVR_TIME_SEGMENT struTimeSegment;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WEEK_PLAN_CFG
        {
            public uint dwSize;
            /// <summary>
            /// whether to enable, 1-enable, 0-disable
            /// </summary>
            public byte byEnable;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// week plan parameter
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SINGLE_PLAN_SEGMENT[] struPlanCfg;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HOLIDAY_PLAN_CFG
        {
            public uint dwSize;
            /// <summary>
            /// whether to enable, 1-enable, 0-disable
            /// </summary>
            public byte byEnable;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// holiday begin date
            /// </summary>
            public NET_DVR_DATE struBeginDate;
            /// <summary>
            /// holiday end date
            /// </summary>
            public NET_DVR_DATE struEndDate;
            /// <summary>
            /// time segment parameter
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SINGLE_PLAN_SEGMENT[] struPlanCfg;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HOLIDAY_GROUP_CFG
        {
            public uint dwSize;
            /// <summary>
            /// whether to enable, 1-enable, 0-disable
            /// </summary>
            public byte byEnable;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// holiday group name
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = HOLIDAY_GROUP_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byGroupName;
            /// <summary>
            /// holiday plan No. fill in from the front side, invalid when meet zero.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_HOLIDAY_PLAN_NUM, ArraySubType = UnmanagedType.U4)]
            public uint[] dwHolidayPlanNo;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLAN_TEMPLATE
        {
            public uint dwSize;
            /// <summary>
            /// whether to enable, 1-enable, 0-disable
            /// </summary>
            public byte byEnable;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// template name
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = TEMPLATE_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byTemplateName;
            /// <summary>
            /// week plan no. 0 invalid
            /// </summary>
            public uint dwWeekPlanNo;
            /// <summary>
            /// holiday group. fill in from the front side, invalid when meet zero.
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_HOLIDAY_GROUP_NUM, ArraySubType = UnmanagedType.U4)]
            public uint[] dwHolidayGroupNo;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HOLIDAY_PLAN_COND
        {
            public uint dwSize;
            /// <summary>
            /// Holiday plan number
            /// </summary>
            public uint dwHolidayPlanNumber;
            /// <summary>
            /// On the controller serial number [1, 64]
            /// </summary>
            public ushort wLocalControllerID;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 106, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WEEK_PLAN_COND
        {
            public uint dwSize;
            /// <summary>
            /// Week plan number
            /// </summary>
            public uint dwWeekPlanNumber;
            /// <summary>
            /// On the controller serial number [1, 64]
            /// </summary>
            public ushort wLocalControllerID;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 106, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HOLIDAY_GROUP_COND
        {
            public uint dwSize;
            /// <summary>
            /// Holiday group number
            /// </summary>
            public uint dwHolidayGroupNumber;
            /// <summary>
            /// On the controller serial number [1, 64]
            /// </summary>
            public ushort wLocalControllerID;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 106, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLAN_TEMPLATE_COND
        {
            public uint dwSize;
            /// <summary>
            /// Plan template number, starting from 1, the maximum value from the entrance guard capability sets
            /// </summary>
            public uint dwPlanTemplateNumber;
            /// <summary>
            /// On the controller serial number[1,64], 0 is invalid
            /// </summary>
            public ushort wLocalControllerID;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 106, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// Maximum number of time segments in 9000 DVR's guard schedule
        /// </summary>
        public const int MAX_TIMESEGMENT_V30 = 8;
        /// <summary>
        /// holiday group name len
        /// </summary>
        public const int HOLIDAY_GROUP_NAME_LEN = 32;
        /// <summary>
        /// holiday max plan number
        /// </summary>
        public const int MAX_HOLIDAY_PLAN_NUM = 16;
        /// <summary>
        /// plan template name len
        /// </summary>
        public const int TEMPLATE_NAME_LEN = 32;
        /// <summary>
        /// plan template max group number
        /// </summary>
        public const int MAX_HOLIDAY_GROUP_NUM = 16;
        /// <summary>
        /// get door status week plan config
        /// </summary>
        public const int NET_DVR_GET_WEEK_PLAN_CFG = 2100;
        /// <summary>
        /// set door status week plan config
        /// </summary>
        public const int NET_DVR_SET_WEEK_PLAN_CFG = 2101;
        /// <summary>
        /// get door status holiday week plan config
        /// </summary>
        public const int NET_DVR_GET_DOOR_STATUS_HOLIDAY_PLAN = 2102;
        /// <summary>
        /// set door status holiday week plan config
        /// </summary>
        public const int NET_DVR_SET_DOOR_STATUS_HOLIDAY_PLAN = 2103;
        /// <summary>
        /// get door holiday group parameter
        /// </summary>
        public const int NET_DVR_GET_DOOR_STATUS_HOLIDAY_GROUP = 2104;
        /// <summary>
        /// set door holiday group parameter
        /// </summary>
        public const int NET_DVR_SET_DOOR_STATUS_HOLIDAY_GROUP = 2105;
        /// <summary>
        /// get door status plan template parameter
        /// </summary>
        public const int NET_DVR_GET_DOOR_STATUS_PLAN_TEMPLATE = 2106;
        /// <summary>
        /// set door status plan template parameter
        /// </summary>
        public const int NET_DVR_SET_DOOR_STATUS_PLAN_TEMPLATE = 2107;
        public const int NET_DVR_SET_DOOR_STATUS_PLAN = 2111;
        /// <summary>
        /// get reader card verfy week plan
        /// </summary>
        public const int NET_DVR_GET_VERIFY_WEEK_PLAN = 2124;
        /// <summary>
        /// set reader card verfy week plan
        /// </summary>
        public const int NET_DVR_SET_VERIFY_WEEK_PLAN = 2125;
        /// <summary>
        /// get card right week plan
        /// </summary>
        public const int NET_DVR_GET_CARD_RIGHT_WEEK_PLAN = 2126;
        /// <summary>
        /// set card right week plan
        /// </summary>
        public const int NET_DVR_SET_CARD_RIGHT_WEEK_PLAN = 2127;
        /// <summary>
        /// get card reader verify holiday plan
        /// </summary>
        public const int NET_DVR_GET_VERIFY_HOLIDAY_PLAN = 2128;
        /// <summary>
        /// set card reader verify holiday plan
        /// </summary>
        public const int NET_DVR_SET_VERIFY_HOLIDAY_PLAN = 2129;
        /// <summary>
        /// get card right holiday plan
        /// </summary>
        public const int NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN = 2130;
        /// <summary>
        /// set card right holiday plan
        /// </summary>
        public const int NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN = 2131;
        /// <summary>
        /// get card reader verify holiday group
        /// </summary>
        public const int NET_DVR_GET_VERIFY_HOLIDAY_GROUP = 2132;
        /// <summary>
        /// set card reader verify holiday group
        /// </summary>
        public const int NET_DVR_SET_VERIFY_HOLIDAY_GROUP = 2133;
        /// <summary>
        /// get card right holiday group
        /// </summary>
        public const int NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP = 2134;
        /// <summary>
        /// set card right holiday group
        /// </summary>
        public const int NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP = 2135;
        /// <summary>
        /// get card reader verify plan template
        /// </summary>
        public const int NET_DVR_GET_VERIFY_PLAN_TEMPLATE = 2136;
        /// <summary>
        /// set card reader verify plan template
        /// </summary>
        public const int NET_DVR_SET_VERIFY_PLAN_TEMPLATE = 2137;
        /// <summary>
        /// get card right plan template
        /// </summary>
        public const int NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE = 2138;
        /// <summary>
        /// set card right plan template
        /// </summary>
        public const int NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE = 2139;
        /// <summary>
        /// V50
        /// </summary>
        public const int NET_DVR_GET_CARD_RIGHT_WEEK_PLAN_V50 = 2304;
        /// <summary>
        /// Set card right V50 weeks plan parameters
        /// </summary>
        public const int NET_DVR_SET_CARD_RIGHT_WEEK_PLAN_V50 = 2305;
        /// <summary>
        /// Access card right parameters V50 holiday plan
        /// </summary>
        public const int NET_DVR_GET_CARD_RIGHT_HOLIDAY_PLAN_V50 = 2310;
        /// <summary>
        /// Set card right parameters V50 holiday plan
        /// </summary>
        public const int NET_DVR_SET_CARD_RIGHT_HOLIDAY_PLAN_V50 = 2311;
        /// <summary>
        /// Access card right parameters V50 holiday group
        /// </summary>
        public const int NET_DVR_GET_CARD_RIGHT_HOLIDAY_GROUP_V50 = 2316;
        /// <summary>
        /// Set card right parameters V50 holiday group
        /// </summary>
        public const int NET_DVR_SET_CARD_RIGHT_HOLIDAY_GROUP_V50 = 2317;
        /// <summary>
        /// Access card right parameters V50 plan template
        /// </summary>
        public const int NET_DVR_GET_CARD_RIGHT_PLAN_TEMPLATE_V50 = 2322;
        /// <summary>
        /// Set card right parameters V50 plan template
        /// </summary>
        public const int NET_DVR_SET_CARD_RIGHT_PLAN_TEMPLATE_V50 = 2323;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RESET_COUNTER_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 是否启用，0-不启用，1-启用
            /// </summary>
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 数据清零时间，时分秒有效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_TIME_EX[] struTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VCA_CTRLINFO_COND
        {
            public uint dwSize;
            public NET_DVR_STREAM_INFO struStreamInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VCA_CTRLINFO_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 是否开启智能
            /// </summary>
            public byte byVCAEnable;
            /// <summary>
            /// 智能能力类型，VCA_CHAN_ABILITY_TYPE
            /// </summary>
            public byte byVCAType;
            /// <summary>
            /// 码流中是否带智能信息
            /// </summary>
            public byte byStreamWithVCA;
            /// <summary>
            /// 模式，ATM 能力时参照VCA_CHAN_MODE_TYPE ,TFS 能力时参照 TFS_CHAN_MODE_TYPE，异常行为识别完整版时参照BEHAVIOR_SCENE_MODE_TYPE
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 控制类型，按位表示，0-否，1-是
            /// </summary>
            public byte byControlType;
            /// <summary>
            /// byControlType &1 是否启用抓拍功能
            /// byControlType &2 是否启用联动前端设备
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 83, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 设置人流量统计参数  复用行为内部关键字参数
        /// HUMAN_GENERATE_RATE
        /// 目标生成速度参数，控制PDC库生成目标的速度。速度越快，目标越容易生成。
        /// 当输入视频光照条件较差，对比度较低时，或者设置的规则区域较小时，应加快目标生成速度， 避免目标的漏检；
        /// 当输入视频中对比度较高时，或者规则区域较大时，应该降低目标生成速度，以减少误检。
        /// 目标生成速度参数共有5级，1级速度最慢，5级最快，默认参数为3。
        /// DETECT_SENSITIVE
        /// 目标检测灵敏度控制参数，控制PDC库中一个矩形区域被检测为目标的灵敏度。
        /// 灵敏度越高，矩形区域越容易被检测为目标，灵敏度越低则越难检测为目标。
        /// 当输入视频光照条件较差，对比度较低时，应提高检测灵敏度， 避免目标的漏检；
        /// 当输入视频中对比度较高时，应该降低检测灵敏度，以减少误检。
        /// 对应参数共有5级，级别1灵敏度最低，5级最高，默认级别为3。
        /// TRAJECTORY_LEN
        /// 生成长度控制参数，表示生成时要求目标的最大位移像素。
        /// 对应参数共有5级，级别1，生成长度最长，生成最慢，5级生成长度最短，生成最快，默认级别为3。
        /// TRAJECT_CNT_LEN
        /// 计数长度控制参数，表示计数时要求目标的最大位移像素。
        /// 对应参数共有5级，级别1，计数要求长度最长，计数最慢，5级计数要求长度最短，计数最快，默认级别为3。
        /// PREPROCESS
        /// 图像预处理控制参数，0 - 不处理；1 - 处理。默认为0；
        /// CAMERA_ANGLE
        /// 摄像机角度输入参数， 0 - 倾斜； 1 - 垂直。默认为0；
        /// </summary>
        public enum PDC_PARAM_KEY
        {
            /// <summary>
            /// 目标生成速度 从50开始
            /// </summary>
            HUMAN_GENERATE_RATE = 50,
            /// <summary>
            /// 检测灵敏度
            /// </summary>
            DETECT_SENSITIVE = 51
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PDC_TARGET_INFO
        {
            /// <summary>
            /// 目标id
            /// </summary>
            public uint dwTargetID;
            /// <summary>
            /// 目标框
            /// </summary>
            public NET_VCA_RECT struTargetRect;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PDC_TARGET_IN_FRAME
        {
            /// <summary>
            /// 目标个数
            /// </summary>
            public byte byTargetNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] yRes1;
            /// <summary>
            /// 目标信息数组
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TARGET_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_PDC_TARGET_INFO[] struTargetInfo;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 单帧统计结果时使用
        /// </summary>
        //单帧统计结果时使用
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct UNION_STATFRAME
        {
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 92, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct UNION_STATTIME
        {
            /// <summary>
            /// 统计起始时间
            /// </summary>
            public NET_DVR_TIME tmStart;
            /// <summary>
            /// 统计结束时间
            /// </summary>
            public NET_DVR_TIME tmEnd;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 92, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct UNION_PDCPARAM
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 140, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PDC_ALRAM_INFO
        {
            /// <summary>
            /// PDC人流量报警上传结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 0 单帧统计结果 1最小时间段统计结果
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 报警上传通道号
            /// </summary>
            public byte byChannel;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 前端设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            public UNION_PDCPARAM uStatModeParam;
            /// <summary>
            /// 离开人数
            /// </summary>
            public uint dwLeaveNum;
            /// <summary>
            /// 进入人数
            /// </summary>
            public uint dwEnterNum;
            /// <summary>
            /// 断网续传标志位，0-不是重传数据，1-重传数据
            /// </summary>
            public byte byBrokenNetHttp;
            public byte byRes3;
            /// <summary>
            /// 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx
            /// </summary>
            public ushort wDevInfoIvmsChannelEx;
            /// <summary>
            /// 经过人数（进入区域后徘徊没有触发进入、离开的人数）
            /// </summary>
            public uint dwPassingNum;
            /// <summary>
            /// 小孩离开人数
            /// </summary>
            public uint dwChildLeaveNum;
            /// <summary>
            /// 小孩进入人数
            /// </summary>
            public uint dwChildEnterNum;
            /// <summary>
            /// 重复人数
            /// </summary>
            public uint dwDuplicatePeople;
            /// <summary>
            /// XML透传数据长度, 即EventNotificationAlert XML Block的数据长度
            /// </summary>
            public uint dwXmlLen;
            /// <summary>
            /// XML报警信息指针,其XML对应到EventNotificationAlert XML Block
            /// </summary>
            public IntPtr pXmlBuf;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 人流量信息查询
        /// </summary>
        //人流量信息查询
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PDC_QUERY
        {
            public NET_DVR_TIME tmStart;
            public NET_DVR_TIME tmEnd;
            public uint dwLeaveNum;
            public uint dwEnterNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PTZ_POSITION
        {
            /// <summary>
            /// 是否启用场景，在设置场景行为规则的时候该字段无效，在设置球机本地配置场景位置信息时作为使能位
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 场景位置名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPtzPositionName;
            /// <summary>
            /// ptz 坐标
            /// </summary>
            public NET_DVR_PTZPOS struPtzPos;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_POSITION_RULE_CFG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 场景位置信息
            /// </summary>
            public NET_DVR_PTZ_POSITION struPtzPosition;
            /// <summary>
            /// 行为规则配置
            /// </summary>
            public NET_VCA_RULECFG struVcaRuleCfg;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 80, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_POSITION_RULE_CFG_V41
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 场景位置信息
            /// </summary>
            public NET_DVR_PTZ_POSITION struPtzPosition;
            /// <summary>
            /// 行为规则配置
            /// </summary>
            public NET_VCA_RULECFG_V41 struVcaRuleCfg;
            /// <summary>
            /// 是否启用
            /// </summary>
            public byte byTrackEnable;
            public byte byRes1;
            /// <summary>
            /// 持续时间，单位s
            /// </summary>
            public ushort wTrackDuration;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 76, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LIMIT_ANGLE
        {
            /// <summary>
            /// 是否启用场景限位功能
            /// </summary>
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 上限位
            /// </summary>
            public NET_DVR_PTZPOS struUp;
            /// <summary>
            /// 下限位
            /// </summary>
            public NET_DVR_PTZPOS struDown;
            /// <summary>
            /// 左限位
            /// </summary>
            public NET_DVR_PTZPOS struLeft;
            /// <summary>
            /// 右限位
            /// </summary>
            public NET_DVR_PTZPOS struRight;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_POSITION_INDEX
        {
            /// <summary>
            /// 场景索引
            /// </summary>
            public byte byIndex;
            public byte byRes1;
            /// <summary>
            /// 停留时间
            /// </summary>
            public ushort wDwell;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        public const int MAX_POSITION_NUM = 10;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_POSITION_TRACK_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 场景个数
            /// </summary>
            public byte byNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_POSITION_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_POSITION_INDEX[] struPositionIndex;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 巡航路径场景信息
        /// </summary>
        //巡航路径场景信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PATROL_SCENE_INFO
        {
            /// <summary>
            /// 停留时间 30-300
            /// </summary>
            public ushort wDwell;
            /// <summary>
            /// 场景号1-10，默认0表示该巡航点不添加场景
            /// </summary>
            public byte byPositionID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 场景巡航配置信息
        /// </summary>
        //场景巡航配置信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PATROL_TRACKCFG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 巡航路径
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 10, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_PATROL_SCENE_INFO[] struPatrolSceneInfo;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 球机本地规则菜单配置结构体
        /// </summary>
        //球机本地规则菜单配置结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TRACK_PARAMCFG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 报警延时时间，目前球机只支持全局入侵 范围1-120秒
            /// </summary>
            public ushort wAlarmDelayTime;
            /// <summary>
            /// 报警持续时间  范围0-300秒
            /// </summary>
            public ushort wTrackHoldTime;
            /// <summary>
            /// 参照 IPDOME_TRACK_MODE
            /// </summary>
            public byte byTrackMode;
            /// <summary>
            /// 方向预判 0-不启用 1-启用
            /// </summary>
            public byte byPreDirection;
            /// <summary>
            /// 连续  0-不启用 1-启用
            /// </summary>
            public byte byTrackSmooth;
            /// <summary>
            /// 倍率系数调整 参见下表
            /// </summary>
            public byte byZoomAdjust;
            /// <summary>
            /// 最大倍率系数,0-表示默认倍率系数,等级6-标定值*1.0(默认),1-5为缩小标定值，值越小，缩小的比例越大,7-15为放大，值越大，放大的比例越大
            /// </summary>
            public byte byMaxTrackZoom;
            /// <summary>
            /// 人脸检测到后是否停止 0-否 1-是
            /// </summary>
            public byte byStopTrackWhenFindFace;
            /// <summary>
            /// 终止评分阈值
            /// </summary>
            public byte byStopTrackThreshold;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 9, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 球机机芯参数
        /// </summary>
        //球机机芯参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DOME_MOVEMENT_PARAM
        {
            /// <summary>
            /// 球机最大倍率系数
            /// </summary>
            public ushort wMaxZoom;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 42, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// ******************************智能交通事件 begin***************************************
        /// </summary>
        public const int MAX_REGION_NUM = 8;
        /// <summary>
        /// 最大参数规则数目
        /// </summary>
        public const int MAX_TPS_RULE = 8;
        /// <summary>
        /// 最大事件规则数目
        /// </summary>
        public const int MAX_AID_RULE = 8;
        /// <summary>
        /// 最大车道数目
        /// </summary>
        public const int MAX_LANE_NUM = 8;

        /// <summary>
        /// 交通事件类型
        /// </summary>
        public enum TRAFFIC_AID_TYPE
        {
            /// <summary>
            /// 拥堵
            /// </summary>
            CONGESTION = 0x01,
            /// <summary>
            /// 停车
            /// </summary>
            PARKING = 0x02,
            /// <summary>
            /// 逆行
            /// </summary>
            INVERSE = 0x04,
            /// <summary>
            /// 行人
            /// </summary>
            PEDESTRIAN = 0x08,
            /// <summary>
            /// 遗留物 抛洒物碎片
            /// </summary>
            DEBRIS = 0x10,
            /// <summary>
            /// 烟雾
            /// </summary>
            SMOKE = 0x20,
            /// <summary>
            /// 压线
            /// </summary>
            OVERLINE = 0x40,
            /// <summary>
            /// 禁止名单数据
            /// </summary>
            VEHICLE_CONTROL_LIST = 0x80,
            /// <summary>
            /// 超速
            /// </summary>
            SPEED = 0x100
        }

        public enum TRAFFIC_SCENE_MODE
        {
            /// <summary>
            /// 高速户外场景
            /// </summary>
            FREEWAY = 0,
            /// <summary>
            /// 高速隧道场景
            /// </summary>
            TUNNEL,
            /// <summary>
            /// 高速桥梁场景
            /// </summary>
            BRIDGE
        }

        public enum ITS_ABILITY_TYPE
        {
            /// <summary>
            /// 拥堵
            /// </summary>
            ITS_CONGESTION_ABILITY = 0x01,
            /// <summary>
            /// 停车
            /// </summary>
            ITS_PARKING_ABILITY = 0x02,
            /// <summary>
            /// 逆行
            /// </summary>
            ITS_INVERSE_ABILITY = 0x04,
            /// <summary>
            /// 行人
            /// </summary>
            ITS_PEDESTRIAN_ABILITY = 0x08,
            /// <summary>
            /// 遗留物 抛洒物碎片
            /// </summary>
            ITS_DEBRIS_ABILITY = 0x10,
            /// <summary>
            /// 烟雾-隧道
            /// </summary>
            ITS_SMOKE_ABILITY = 0x20,
            /// <summary>
            /// 压线
            /// </summary>
            ITS_OVERLINE_ABILITY = 0x40,
            /// <summary>
            /// 禁止名单数据
            /// </summary>
            ITS_VEHICLE_CONTROL_LIST_ABILITY = 0x80,
            /// <summary>
            /// 超速
            /// </summary>
            ITS_SPEED_ABILITY = 0x100,
            /// <summary>
            /// 车道流量
            /// </summary>
            ITS_LANE_VOLUME_ABILITY = 0x010000,
            /// <summary>
            /// 车道平均速度
            /// </summary>
            ITS_LANE_VELOCITY_ABILITY = 0x020000,
            /// <summary>
            /// 车头时距
            /// </summary>
            ITS_TIME_HEADWAY_ABILITY = 0x040000,
            /// <summary>
            /// 车头间距
            /// </summary>
            ITS_SPACE_HEADWAY_ABILITY = 0x080000,
            /// <summary>
            /// 车道占有率，（时间上)
            /// </summary>
            ITS_TIME_OCCUPANCY_RATIO_ABILITY = 0x100000,
            /// <summary>
            /// 车道占有率，百分比计算（空间上)
            /// </summary>
            ITS_SPACE_OCCUPANCY_RATIO_ABILITY = 0x200000,
            /// <summary>
            /// 排队长度
            /// </summary>
            ITS_LANE_QUEUE_ABILITY = 0x400000,
            /// <summary>
            /// 车辆类型
            /// </summary>
            ITS_VEHICLE_TYPE_ABILITY = 0x800000,
            /// <summary>
            /// 交通状态
            /// </summary>
            ITS_TRAFFIC_STATE_ABILITY = 0x1000000
        }

        /// <summary>
        /// 交通统计参数
        /// </summary>
        public enum ITS_TPS_TYPE
        {
            /// <summary>
            /// 车道流量
            /// </summary>
            LANE_VOLUME = 0x01,
            /// <summary>
            /// 车道速度
            /// </summary>
            LANE_VELOCITY = 0x02,
            /// <summary>
            /// 车头时距
            /// </summary>
            TIME_HEADWAY = 0x04,
            /// <summary>
            /// 车头间距
            /// </summary>
            SPACE_HEADWAY = 0x08,
            /// <summary>
            /// 车道占有率 (时间上)
            /// </summary>
            TIME_OCCUPANCY_RATIO = 0x10,
            /// <summary>
            /// 车道占有率，百分比计算(空间上)
            /// </summary>
            SPACE_OCCUPANCY_RATIO = 0x20,
            /// <summary>
            /// 排队长度
            /// </summary>
            QUEUE = 0x40,
            /// <summary>
            /// 车辆类型
            /// </summary>
            VEHICLE_TYPE = 0x80,
            /// <summary>
            /// 交通状态
            /// </summary>
            TRAFFIC_STATE = 0x100
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_REGION_LIST
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 区域个数
            /// </summary>
            public byte byNum;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 区域
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_REGION_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_POLYGON[] struPolygon;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 方向结构体
        /// </summary>
        //方向结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DIRECTION
        {
            /// <summary>
            /// 方向起始点
            /// </summary>
            public NET_VCA_POINT struStartPoint;
            /// <summary>
            /// 方向结束点
            /// </summary>
            public NET_VCA_POINT struEndPoint;
        }

        /// <summary>
        /// 单个车道
        /// </summary>
        //单个车道
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ONE_LANE
        {
            /// <summary>
            /// 车道是否启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 车道规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byLaneName;
            /// <summary>
            /// 车道内车流方向
            /// </summary>
            public NET_DVR_DIRECTION struFlowDirection;
            /// <summary>
            /// 车道区域
            /// </summary>
            public NET_VCA_POLYGON struPolygon;
        }

        /// <summary>
        /// 车道配置
        /// </summary>
        //车道配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LANE_CFG
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 车道参数 数组下标作为车道ID
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LANE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ONE_LANE[] struLane;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        /// <summary>
        /// 交通事件参数
        /// </summary>
        //交通事件参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AID_PARAM
        {
            /// <summary>
            /// 违停检测灵敏度  10-120s
            /// </summary>
            public ushort wParkingDuration;
            /// <summary>
            /// 行人持续时间    1-120s
            /// </summary>
            public ushort wPedestrianDuration;
            /// <summary>
            /// 抛洒物持续时间  10-120s
            /// </summary>
            public ushort wDebrisDuration;
            /// <summary>
            /// 拥堵长度阈值    5-200（米）
            /// </summary>
            public ushort wCongestionLength;
            /// <summary>
            /// 拥堵持续参数    10-120s
            /// </summary>
            public ushort wCongestionDuration;
            /// <summary>
            /// 逆行持续时间    1-10s
            /// </summary>
            public ushort wInverseDuration;
            /// <summary>
            /// 逆行距离阈值 单位m 范围[2-100] 默认 10米
            /// </summary>
            public ushort wInverseDistance;
            /// <summary>
            /// 允许角度偏差 90-180度,车流与逆行允许的夹角
            /// </summary>
            public ushort wInverseAngleTolerance;
            /// <summary>
            /// 违停时间[4,60]，单位：分钟 ,TFS(交通违章取证) 城市模式下
            /// </summary>
            public ushort wIllegalParkingTime;
            /// <summary>
            /// 违停图片数量[1,6], TFS(交通违章取证) 城市模式下
            /// </summary>
            public ushort wIllegalParkingPicNum;
            /// <summary>
            /// 图片拼接,TFS 城市模式下 0- 不拼接 1- 拼接
            /// </summary>
            public byte byMergePic;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 23, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        /// <summary>
        /// 单条交通事件规则结构体
        /// </summary>
        //单条交通事件规则结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ONE_AID_RULE
        {
            /// <summary>
            /// 是否启用事件规则
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 交通事件检测类型 TRAFFIC_AID_TYPE
            /// </summary>
            public uint dwEventType;
            /// <summary>
            /// 尺寸过滤器
            /// </summary>
            public NET_VCA_SIZE_FILTER struSizeFilter;
            /// <summary>
            /// 规则区域
            /// </summary>
            public NET_VCA_POLYGON struPolygon;
            /// <summary>
            /// 事件参数
            /// </summary>
            public NET_DVR_AID_PARAM struAIDParam;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_2, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 struHandleType;
            /// <summary>
            /// 报警触发的录象通道,为1表示触发该通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 交通事件规则
        /// </summary>
        //交通事件规则
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AID_RULECFG
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 报警时图片处理方式 0-不处理 非0-上传
            /// </summary>
            public byte byPicProType;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 图片规格结构
            /// </summary>
            public NET_DVR_JPEGPARA struPictureParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_AID_RULE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ONE_AID_RULE[] struOneAIDRule;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 单条交通事件规则结构体(扩展)
        /// </summary>
        //单条交通事件规则结构体(扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ONE_AID_RULE_V41
        {
            /// <summary>
            /// 是否启用事件规则
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 交通事件检测类型 TRAFFIC_AID_TYPE
            /// </summary>
            public uint dwEventType;
            /// <summary>
            /// 尺寸过滤器
            /// </summary>
            public NET_VCA_SIZE_FILTER struSizeFilter;
            /// <summary>
            /// 规则区域
            /// </summary>
            public NET_VCA_POLYGON struPolygon;
            /// <summary>
            /// 事件参数
            /// </summary>
            public NET_DVR_AID_PARAM struAIDParam;
            /// <summary>
            /// 布防时间段
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 struHandleType;
            /// <summary>
            /// 报警触发的录象通道：1表示触发该通道；0表示不触发
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IVMS_IP_CHANNEL, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 60, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 交通事件规则(扩展)
        /// </summary>
        //交通事件规则(扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AID_RULECFG_V41
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 报警时图片处理方式 0-不处理 非0-上传
            /// </summary>
            public byte byPicProType;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 图片规格结构
            /// </summary>
            public NET_DVR_JPEGPARA struPictureParam;
            /// <summary>
            /// 规则数组
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_AID_RULE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ONE_AID_RULE_V41[] struAIDRule;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 交通统计参数结构体
        /// </summary>
        //交通统计参数结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ONE_TPS_RULE
        {
            /// <summary>
            /// 是否使能车道交通规则参数
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 车道ID
            /// </summary>
            public byte byLaneID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 统计参数类型ITS_TPS_TYPE
            /// </summary>
            public uint dwCalcType;
            /// <summary>
            /// 尺寸过滤器
            /// </summary>
            public NET_VCA_SIZE_FILTER struSizeFilter;
            /// <summary>
            /// 虚拟线圈
            /// </summary>
            public NET_VCA_POLYGON struVitrualLoop;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_2, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 处理方式,一般为处理是否上传中心，其他功能不需要
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 struHandleType;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 交通参数统计规则配置结构体
        /// </summary>
        //交通参数统计规则配置结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TPS_RULECFG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 下标对应交通参数ID
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TPS_RULE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ONE_TPS_RULE[] struOneTpsRule;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 交通统计参数结构体(扩展)
        /// </summary>
        //交通统计参数结构体(扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ONE_TPS_RULE_V41
        {
            /// <summary>
            /// 是否使能车道交通规则参数
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 车道ID
            /// </summary>
            public byte byLaneID;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 统计参数类型ITS_TPS_TYPE
            /// </summary>
            public uint dwCalcType;
            /// <summary>
            /// 尺寸过滤器
            /// </summary>
            public NET_VCA_SIZE_FILTER struSizeFilter;
            /// <summary>
            /// 虚拟线圈
            /// </summary>
            public NET_VCA_POLYGON struVitrualLoop;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 struHandleType;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 60, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 交通参数统计规则配置结构体(扩展)
        /// </summary>
        //交通参数统计规则配置结构体(扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TPS_RULECFG_V41
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 下标对应交通参数ID
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TPS_RULE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ONE_TPS_RULE_V41[] struOneTpsRule;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 实时信息
        /// </summary>
        //实时信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TPS_PARAM
        {
            /// <summary>
            /// 开始码
            /// </summary>
            public byte byStart;
            /// <summary>
            /// 命令号，01-进入指令，02-离开指令，03-拥堵状态指令(为03时，只有byLaneState和byQueueLen有效)，04-多线圈状态（为04时，wLoopState和wStateMask有效，表示byLane车道上多个线圈的过车状态）
            /// </summary>
            public byte byCMD;
            /// <summary>
            /// 车头间距，以米来计算
            /// </summary>
            public ushort wSpaceHeadway;
            /// <summary>
            /// 设备ID
            /// </summary>
            public ushort wDeviceID;
            /// <summary>
            /// 数据长度
            /// </summary>
            public ushort wDataLen;
            /// <summary>
            /// 对应车道号
            /// </summary>
            public byte byLane;
            /// <summary>
            /// 对应车速（KM/H）
            /// </summary>
            public byte bySpeed;
            /// <summary>
            /// 车道状态；0-无状态，1-畅通，2-拥挤，3-堵塞
            /// </summary>
            public byte byLaneState;
            /// <summary>
            /// 堵塞状态下排队长度（比如50米）
            /// </summary>
            public byte byQueueLen;
            /// <summary>
            /// 线圈状态，第几位表示几号线圈状态，线圈编号从镜头由近到远依次增大。状态1-到达，0-离开
            /// </summary>
            public ushort wLoopState;
            /// <summary>
            /// 线圈状态掩码，掩码位为1对应wLoopState状态位有效，为0表示无效
            /// </summary>
            public ushort wStateMask;
            /// <summary>
            /// 当前车道 从上到下车流量
            /// </summary>
            public uint dwDownwardFlow;
            /// <summary>
            /// 当前车道 从下到上车流量
            /// </summary>
            public uint dwUpwardFlow;
            /// <summary>
            /// 拥堵等级，当byLaneState为3时有效，1-轻度，2-中度，3-重度
            /// </summary>
            public byte byJamLevel;
            /// <summary>
            /// 0-未知，1-由上而下，2-由下而上
            /// </summary>
            public byte byVehicleDirection;
            /// <summary>
            /// 拥堵新增流量，每新增一辆车就上报一次累计车辆的信息
            /// </summary>
            public byte byJamFlow;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 车头时距，以秒计算
            /// </summary>
            public ushort wTimeHeadway;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LLI_PARAM
        {
            /// <summary>
            /// 秒[0.000000,60.000000]
            /// </summary>
            public float fSec;
            /// <summary>
            /// 度:纬度[0,90] 经度[0,180]
            /// </summary>
            public byte byDegree;
            /// <summary>
            /// 分[0,59]
            /// </summary>
            public byte byMinute;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LLPOS_PARAM
        {
            /// <summary>
            /// 纬度类型，0-北纬，1-南纬
            /// </summary>
            public byte byLatitudeType;
            /// <summary>
            /// 经度类型，0-东经，1-西经
            /// </summary>
            public byte byLongitudeType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 纬度
            /// </summary>
            public NET_DVR_LLI_PARAM struLatitude;
            /// <summary>
            /// 经度
            /// </summary>
            public NET_DVR_LLI_PARAM struLongitude;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// TPS附加信息
        /// </summary>
        //TPS附加信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TPS_ADDINFO
        {
            /// <summary>
            /// 车流量最后一辆车的经纬度位置信息(byLaneState=3且byQueueLen>0时才返回)
            /// </summary>
            public NET_DVR_LLPOS_PARAM struLLPos;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 1024, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// TPS实时过车数据上传
        /// </summary>
        //TPS实时过车数据上传
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TPS_REAL_TIME_INFO
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChan;
            /// <summary>
            /// 检测时间
            /// </summary>
            public NET_DVR_TIME_V30 struTime;
            /// <summary>
            /// 交通参数统计信息
            /// </summary>
            public NET_DVR_TPS_PARAM struTPSRealTimeInfo;
            public IntPtr pAddInfoBuffer;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 附加信息标识（即是否有NET_DVR_TPS_ADDINFO结构体）,0-无附加信息, 1-有附加信息。
            /// </summary>
            public byte byAddInfoFlag;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 15, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 统计信息
        /// </summary>
        //统计信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TPS_LANE_PARAM
        {
            /// <summary>
            /// 对应车道号
            /// </summary>
            public byte byLane;
            /// <summary>
            /// 车道过车平均速度
            /// </summary>
            public byte bySpeed;
            /// <summary>
            /// 到达流量
            /// </summary>
            public ushort wArrivalFlow;
            /// <summary>
            /// 小型车数量
            /// </summary>
            public uint dwLightVehicle;
            /// <summary>
            /// 中型车数量
            /// </summary>
            public uint dwMidVehicle;
            /// <summary>
            /// 重型车数量
            /// </summary>
            public uint dwHeavyVehicle;
            /// <summary>
            /// 车头时距，以秒计算
            /// </summary>
            public uint dwTimeHeadway;
            /// <summary>
            /// 车头间距，以米来计算
            /// </summary>
            public uint dwSpaceHeadway;
            /// <summary>
            /// 空间占有率，百分比计算,浮点数*1000
            /// </summary>
            public float fSpaceOccupyRation;
            /// <summary>
            /// 时间占有率，百分比计算,浮点数*1000
            /// </summary>
            public float fTimeOccupyRation;
            /// <summary>
            /// 平均停车次数
            /// </summary>
            public byte byStoppingTimes;
            /// <summary>
            /// 堵塞状态下排队长度（比如50米）
            /// </summary>
            public byte byQueueLen;
            /// <summary>
            /// 上传标识，0-表示T1时间的统计结果,1-表示T2时间的统计
            /// </summary>
            public byte byFlag;
            /// <summary>
            /// 区域车辆数
            /// </summary>
            public byte byVehicelNum;
            /// <summary>
            /// 平均延误
            /// </summary>
            public ushort wDelay;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 非机动车数量
            /// </summary>
            public uint dwNonMotor;
        }

        /// <summary>
        /// 交通参数统计信息
        /// </summary>
        // 交通参数统计信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TPS_STATISTICS_PARAM
        {
            /// <summary>
            /// 开始码
            /// </summary>
            public byte byStart;
            /// <summary>
            /// 命令号， 08-定时成组数据指令
            /// </summary>
            public byte byCMD;
            /// <summary>
            /// 预留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 设备ID
            /// </summary>
            public ushort wDeviceID;
            /// <summary>
            /// 数据长度
            /// </summary>
            public ushort wDataLen;
            /// <summary>
            /// 有效车道总数
            /// </summary>
            public byte byTotalLaneNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 15, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 统计开始时间
            /// </summary>
            public NET_DVR_TIME_V30 struStartTime;
            /// <summary>
            /// 统计时间,单位秒
            /// </summary>
            public uint dwSamplePeriod;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TPS_RULE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_TPS_LANE_PARAM[] struLaneParam;
        }

        /// <summary>
        /// TPS统计过车数据上传
        /// </summary>
        //TPS统计过车数据上传
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TPS_STATISTICS_INFO
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChan;
            /// <summary>
            /// 交通参数统计信息
            /// </summary>
            public NET_DVR_TPS_STATISTICS_PARAM struTPSStatisticsInfo;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 交通事件信息
        /// </summary>
        //交通事件信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AID_INFO
        {
            /// <summary>
            /// 规则序号，为规则配置结构下标，0-16
            /// </summary>
            public byte byRuleID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 报警事件类型
            /// </summary>
            public uint dwAIDType;
            /// <summary>
            /// 报警指向区域
            /// </summary>
            public NET_DVR_DIRECTION struDirect;
            /// <summary>
            /// 限速值，单位km/h[0,255]
            /// </summary>
            public byte bySpeedLimit;
            /// <summary>
            /// 当前速度值，单位km/h[0,255]
            /// </summary>
            public byte byCurrentSpeed;
            /// <summary>
            /// 车辆出入状态 0-无效 1-驶入 2-驶出
            /// </summary>
            public byte byVehicleEnterState;
            /// <summary>
            /// 0-变化上传，1-轮巡上传
            /// </summary>
            public byte byState;
            /// <summary>
            /// 停车位编号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byParkingID;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 交通事件报警
        /// </summary>
        //交通事件报警 
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AID_ALARM
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 前端设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 交通事件信息
            /// </summary>
            public NET_DVR_AID_INFO struAIDInfo;
            /// <summary>
            /// 返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据
            /// </summary>
            public uint dwPicDataLen;
            /// <summary>
            /// 指向图片的指针
            /// </summary>
            public IntPtr pImage;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 交通取证报警
        /// </summary>
        //交通取证报警
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TFS_ALARM
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 违章类型，采用国标定义，当dwIllegalType值为0xffffffff时使用byIllegalCode
            /// </summary>
            public uint dwIllegalType;
            /// <summary>
            /// 违法持续时间（单位：秒） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
            /// </summary>
            public uint dwIllegalDuration;
            /// <summary>
            /// 显示点编号（路口编号、内部编号）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MONITORSITE_ID_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMonitoringSiteID;
            /// <summary>
            /// 设备编号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = DEVICE_ID_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDeviceID;
            /// <summary>
            /// 前端设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 场景信息
            /// </summary>
            public NET_DVR_SCENE_INFO struSceneInfo;
            /// <summary>
            /// 录像开始时间
            /// </summary>
            public NET_DVR_TIME_EX struBeginRecTime;
            /// <summary>
            /// 录像结束时间
            /// </summary>
            public NET_DVR_TIME_EX struEndRecTime;
            /// <summary>
            /// 交通事件信息
            /// </summary>
            public NET_DVR_AID_INFO struAIDInfo;
            /// <summary>
            /// 车牌信息
            /// </summary>
            public NET_DVR_PLATE_INFO struPlateInfo;
            /// <summary>
            /// 车辆信息
            /// </summary>
            public NET_DVR_VEHICLE_INFO struVehicleInfo;
            /// <summary>
            /// 图片数量
            /// </summary>
            public uint dwPicNum;
            /// <summary>
            /// 图片信息，最多8张
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.Struct)]
            public NET_ITS_PICTURE_INFO[] struPicInfo;
            /// <summary>
            /// 具体车辆种类  参考识别结果类型VTR_RESULT
            /// </summary>
            public byte bySpecificVehicleType;
            /// <summary>
            /// 关联车道号
            /// </summary>
            public byte byLaneNo;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 手动定位，当前时间。
            /// </summary>
            public NET_DVR_TIME_V30 struTime;
            /// <summary>
            /// 序号；
            /// </summary>
            public uint dwSerialNo;
            /// <summary>
            /// 车辆属性，按位表示，0- 无附加属性(普通车)，bit1- 黄标车(类似年检的标志)，bit2- 危险品车辆，值：0- 否，1- 是
            /// </summary>
            public byte byVehicleAttribute;
            /// <summary>
            /// 0-表示未知,1-系安全带,2-不系安全带
            /// </summary>
            public byte byPilotSafebelt;
            /// <summary>
            /// 0-表示未知,1-系安全带,2-不系安全带
            /// </summary>
            public byte byCopilotSafebelt;
            /// <summary>
            /// 0-表示未知,1-不打开遮阳板,2-打开遮阳板
            /// </summary>
            public byte byPilotSunVisor;
            /// <summary>
            /// 0-表示未知, 1-不打开遮阳板,2-打开遮阳板
            /// </summary>
            public byte byCopilotSunVisor;
            /// <summary>
            /// 0-表示未知, 1-不打电话,2-打电话
            /// </summary>
            public byte byPilotCall;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 违法代码扩展，当dwIllegalType值为0xffffffff；使用这个值
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ILLEGAL_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byIllegalCode;
            /// <summary>
            /// 国家索引值,参照枚举COUNTRY_INDEX
            /// </summary>
            public ushort wCountry;
            /// <summary>
            /// 区域索引值,0-保留，1-欧洲(Europe Region)，2-俄语区域(Russian Region)，3-欧洲&俄罗斯(EU&CIS) , 4-中东（Middle East），0xff-所有
            /// </summary>
            public byte byRegion;
            /// <summary>
            /// 是否压线停车（侧方停车），0-表示未知，1-不压线，2-压线
            /// </summary>
            public byte byCrossLine;
            /// <summary>
            /// 泊车位编号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SERIAL_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byParkingSerialNO;
            /// <summary>
            /// 是否跨泊车位停车（侧方停车），0-表示未知，1-未跨泊车位停车，2-跨泊车位停车
            /// </summary>
            public byte byCrossSpaces;
            /// <summary>
            /// 是否倾斜停车（侧方停车）, 0-表示未知，1-未倾斜停车，2-倾斜停车
            /// </summary>
            public byte byAngledParking;
            /// <summary>
            /// 报警置信度，可以输出驶入驶出的置信度，范围0-100；置信度越高，事件真实性越高
            /// </summary>
            public byte byAlarmValidity;
            /// <summary>
            /// 车门状态 0-车门关闭 1-车门开启
            /// </summary>
            public byte byDoorsStatus;
            /// <summary>
            /// XML报警信息长度
            /// </summary>
            public uint dwXmlLen;
            /// <summary>
            /// XML报警信息指针,其XML对应到EventNotificationAlert XML Block
            /// </summary>
            public IntPtr pXmlBuf;
            /// <summary>
            /// [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            /// public byte[] byRes3; //32位SDK需要保留字节对齐
            /// </summary>
            public byte byVehicleHeadTailStatus;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 31, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 车道队列结构体
        /// </summary>
        //车道队列结构体 
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LANE_QUEUE
        {
            /// <summary>
            /// 队列头
            /// </summary>
            public NET_VCA_POINT struHead;
            /// <summary>
            /// 队列尾
            /// </summary>
            public NET_VCA_POINT struTail;
            /// <summary>
            /// 实际队列长度 单位为米 [0-500]
            /// </summary>
            public uint dwLength;
        }

        public enum TRAFFIC_DATA_VARY_TYPE
        {
            /// <summary>
            /// 无变化
            /// </summary>
            NO_VARY,
            /// <summary>
            /// 车辆进入虚拟线圈
            /// </summary>
            VEHICLE_ENTER,
            /// <summary>
            /// 车辆离开虚拟线圈
            /// </summary>
            VEHICLE_LEAVE,
            /// <summary>
            /// 队列变化
            /// </summary>
            UEUE_VARY
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LANE_PARAM
        {
            /// <summary>
            /// 车道规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 规则序号，为规则配置结构下标，0-7
            /// </summary>
            public byte byRuleID;
            /// <summary>
            /// 车道交通参数变化类型 参照 TRAFFIC_DATA_VARY_TYPE
            /// </summary>
            public byte byVaryType;
            /// <summary>
            /// 车道上行或下行
            /// </summary>
            public byte byLaneType;
            public byte byRes1;
            /// <summary>
            /// 车道流量 ，统计有多少车子通过
            /// </summary>
            public uint dwLaneVolume;
            /// <summary>
            /// 车道速度，公里计算
            /// </summary>
            public uint dwLaneVelocity;
            /// <summary>
            /// 车头时距，以秒计算
            /// </summary>
            public uint dwTimeHeadway;
            /// <summary>
            /// 车头间距，以米来计算
            /// </summary>
            public uint dwSpaceHeadway;
            /// <summary>
            /// 车道占有率，百分比计算（空间上)
            /// </summary>
            public float fSpaceOccupyRation;
            /// <summary>
            /// 车道队列长度
            /// </summary>
            public NET_DVR_LANE_QUEUE struLaneQueue;
            /// <summary>
            /// 线圈规则的中心点位置
            /// </summary>
            public NET_VCA_POINT struRuleLocation;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TPS_INFO
        {
            /// <summary>
            /// 交通参数的车道数目
            /// </summary>
            public uint dwLanNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TPS_RULE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_LANE_PARAM[] struLaneParam;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TPS_ALARM
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 前端设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 交通事件信息
            /// </summary>
            public NET_DVR_TPS_INFO struTPSInfo;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        public enum TRAFFIC_DATA_VARY_TYPE_EX_ENUM
        {
            /// <summary>
            /// 无变化
            /// </summary>
            ENUM_TRAFFIC_VARY_NO = 0x00,
            /// <summary>
            /// 车辆进入虚拟线圈
            /// </summary>
            ENUM_TRAFFIC_VARY_VEHICLE_ENTER = 0x01,
            /// <summary>
            /// 车辆离开虚拟线圈
            /// </summary>
            ENUM_TRAFFIC_VARY_VEHICLE_LEAVE = 0x02,
            /// <summary>
            /// 队列变化
            /// </summary>
            ENUM_TRAFFIC_VARY_QUEUE = 0x04,
            /// <summary>
            /// 统计数据变化（每分钟变化一次包括平均速度，车道空间/时间占有率，交通状态）
            /// </summary>
            ENUM_TRAFFIC_VARY_STATISTIC = 0x08
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LANE_PARAM_V41
        {
            /// <summary>
            /// 车道规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 规则序号，为规则配置结构下标，0-7
            /// </summary>
            public byte byRuleID;
            /// <summary>
            /// 车道上行或下行
            /// </summary>
            public byte byLaneType;
            /// <summary>
            /// 车道的交通状态，0-无效，1-畅通，2-拥挤，3-堵塞
            /// </summary>
            public byte byTrafficState;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// 车道交通参数变化类型参照  TRAFFIC_DATA_VARY_TYPE_EX_ENUM，按位区分
            /// </summary>
            public uint dwVaryType;
            /// <summary>
            /// 数据变化类型标志，表示当前上传的统计参数中，哪些数据有效，参照ITS_TPS_TYPE,按位区分
            /// </summary>
            public uint dwTpsType;
            /// <summary>
            /// 车道流量，统计有多少车子通过
            /// </summary>
            public uint dwLaneVolume;
            /// <summary>
            /// 车道速度，公里计算
            /// </summary>
            public uint dwLaneVelocity;
            /// <summary>
            /// 车头时距，以秒计算
            /// </summary>
            public uint dwTimeHeadway;
            /// <summary>
            /// 车头间距，以米来计算
            /// </summary>
            public uint dwSpaceHeadway;
            /// <summary>
            /// 车道占有率，百分比计算（空间上)
            /// </summary>
            public float fSpaceOccupyRation;
            /// <summary>
            /// 时间占有率，百分比计算
            /// </summary>
            public float fTimeOccupyRation;
            /// <summary>
            /// 小型车数量
            /// </summary>
            public uint dwLightVehicle;
            /// <summary>
            /// 中型车数量
            /// </summary>
            public uint dwMidVehicle;
            /// <summary>
            /// 重型车数量
            /// </summary>
            public uint dwHeavyVehicle;
            /// <summary>
            /// 车道队列长度
            /// </summary>
            public NET_DVR_LANE_QUEUE struLaneQueue;
            /// <summary>
            /// 规则位置虚拟线圈的中心
            /// </summary>
            public NET_VCA_POINT struRuleLocation;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TPS_INFO_V41
        {
            /// <summary>
            /// 交通参数的车道数目
            /// </summary>
            public uint dwLanNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TPS_RULE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_LANE_PARAM_V41[] struLaneParam;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 人脸规则配置
        /// </summary>
        //人脸规则配置 
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FACEDETECT_RULECFG
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 是否启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 警戒事件类型， 0-异常人脸; 1-正常人脸;2-异常人脸&正常人脸;
            /// </summary>
            public byte byEventType;
            /// <summary>
            /// 2011-04-06 是否先上传最近一次的报警
            /// </summary>
            public byte byUpLastAlarm;
            /// <summary>
            /// 是否上传人脸子图，0-否，1-是
            /// </summary>
            public byte byUpFacePic;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 人脸检测规则区域
            /// </summary>
            public NET_VCA_POLYGON struVcaPolygon;
            /// <summary>
            /// 报警时图片处理方式 0-不处理 非0-上传
            /// </summary>
            public byte byPicProType;
            /// <summary>
            /// 规则灵敏度
            /// </summary>
            public byte bySensitivity;
            /// <summary>
            /// 触发人脸报警时间阈值
            /// </summary>
            public ushort wDuration;
            /// <summary>
            /// 图片规格结构
            /// </summary>
            public NET_DVR_JPEGPARA struPictureParam;
            /// <summary>
            /// 尺寸过滤器
            /// </summary>
            public NET_VCA_SIZE_FILTER struSizeFilter;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_2, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 struHandleType;
            /// <summary>
            /// 报警触发的录象通道,为1表示触发该通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
            /// <summary>
            /// 2012-3-1是否启用图片存储, 0-不启用, 1-启用
            /// </summary>
            public byte byPicRecordEnable;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 39, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FACE_PIPCFG
        {
            /// <summary>
            /// 是否开启画中画
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 背景通道号（面板通道）
            /// </summary>
            public byte byBackChannel;
            /// <summary>
            /// 叠加位置，0-左上,1-左下,2-右上,3-右下
            /// </summary>
            public byte byPosition;
            /// <summary>
            /// 分屏系数(人脸画面:面板画面)，0-1:4,1-1:9,2-1:16
            /// </summary>
            public byte byPIPDiv;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FACEDETECT_RULECFG_V41
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 是否启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 警戒事件类型， 0-异常人脸; 1-正常人脸;2-异常人脸&正常人脸;
            /// </summary>
            public byte byEventType;
            /// <summary>
            /// 2011-04-06 是否先上传最近一次的报警
            /// </summary>
            public byte byUpLastAlarm;
            /// <summary>
            /// 是否上传人脸子图，0-否，1-是
            /// </summary>
            public byte byUpFacePic;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 人脸检测规则区域
            /// </summary>
            public NET_VCA_POLYGON struVcaPolygon;
            /// <summary>
            /// 报警时图片处理方式 0-不处理 非0-上传
            /// </summary>
            public byte byPicProType;
            /// <summary>
            /// 规则灵敏度
            /// </summary>
            public byte bySensitivity;
            /// <summary>
            /// 触发人脸报警时间阈值
            /// </summary>
            public ushort wDuration;
            /// <summary>
            /// 图片规格结构
            /// </summary>
            public NET_DVR_JPEGPARA struPictureParam;
            /// <summary>
            /// 尺寸过滤器
            /// </summary>
            public NET_VCA_SIZE_FILTER struSizeFilter;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 struHandleType;
            /// <summary>
            /// 报警触发的录象通道,为1表示触发该通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
            /// <summary>
            /// 2012-10-22是否启用图片存储, 0-不启用, 1-启用
            /// </summary>
            public byte byPicRecordEnable;
            public byte byRes1;
            /// <summary>
            /// 2012-10-22智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
            /// </summary>
            public ushort wAlarmDelay;
            /// <summary>
            /// 2012-11-7画中画参数
            /// </summary>
            public NET_DVR_FACE_PIPCFG struFacePIP;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 28, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FACEDETECT_ALARM
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 报警目标信息
            /// </summary>
            public NET_VCA_TARGET_INFO struTargetInfo;
            /// <summary>
            /// 前端设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据*/
            /// </summary>
            public uint dwPicDataLen;
            /// <summary>
            /// 0-异常人脸报警图片 1- 人脸图片,2-多张人脸
            /// </summary>
            public byte byAlarmPicType;
            /// <summary>
            /// 2012-3-1人脸通道关联的面板通道
            /// </summary>
            public byte byPanelChan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 人脸图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据*/
            /// </summary>
            public uint dwFacePicDataLen;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 48, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 指向人脸图指针
            /// </summary>
            public IntPtr pFaceImage;
            /// <summary>
            /// 指向图片的指针
            /// </summary>
            public IntPtr pImage;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_EVENT_PARAM_UNION
        {
            /// <summary>
            /// 联合体大小为12字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.U4)]
            public uint[] uLen;
            /// <summary>
            /// 有无人接近 0 - 无人 1- 有人
            /// </summary>
            public uint dwHumanIn;
            /// <summary>
            /// 人员聚集值
            /// </summary>
            public float fCrowdDensity;
        }

        /// <summary>
        /// 目前只有有人无人事件和人员聚集事件实时报警上传
        /// </summary>
        //目前只有有人无人事件和人员聚集事件实时报警上传
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_EVENT_INFO
        {
            /// <summary>
            /// Rule ID
            /// </summary>
            public byte byRuleID;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRuleName;
            /// <summary>
            /// 参照VCA_EVENT_TYPE
            /// </summary>
            public uint dwEventType;
            public NET_DVR_EVENT_PARAM_UNION uEventParam;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_EVENT_INFO_LIST
        {
            /// <summary>
            /// 事件实时信息个数
            /// </summary>
            public byte byNum;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 事际实时信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RULE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_EVENT_INFO[] struEventInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RULE_INFO_ALARM
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 前端设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 事件信息列表
            /// </summary>
            public NET_DVR_EVENT_INFO_LIST struEventInfoList;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 单条场景时间段
        /// </summary>
        //单条场景时间段
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ONE_SCENE_TIME
        {
            /// <summary>
            /// 0 -无效,1–有效
            /// </summary>
            public byte byActive;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 场景ID
            /// </summary>
            public uint dwSceneID;
            /// <summary>
            /// 场景起效时间
            /// </summary>
            public NET_DVR_SCHEDTIME struEffectiveTime;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 场景起效时间段配置
        /// </summary>
        //场景起效时间段配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCENE_TIME_CFG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 场景时间段数组
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SCENE_TIMESEG_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ONE_SCENE_TIME[] struSceneTime;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 单条场景配置信息
        /// </summary>
        //单条场景配置信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ONE_SCENE_CFG
        {
            /// <summary>
            /// 是否启用该场景,0-不启用 1- 启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 显示方向 1-上行，2-下行，3-双向，4-由东向西，5-由南向北，6-由西向东，7-由北向南，8-其它
            /// </summary>
            public byte byDirection;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 场景ID(只读), 0 - 表示该场景无效
            /// </summary>
            public uint dwSceneID;
            /// <summary>
            /// 场景名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] bySceneName;
            /// <summary>
            /// ptz 坐标
            /// </summary>
            public NET_DVR_PTZPOS struPtzPos;
            /// <summary>
            /// 球机时间[5,300] 秒，TFS(交通取证)模式下有效
            /// </summary>
            public uint dwTrackTime;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 场景配置结构体
        /// </summary>
        //场景配置结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCENE_CFG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 场景配置信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ITS_SCENE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ONE_SCENE_CFG[] struSceneCfg;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 多场景操作条件
        /// </summary>
        //多场景操作条件
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCENE_COND
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public Int32 lChannel;
            /// <summary>
            /// 场景ID, 0-表示该场景无效
            /// </summary>
            public uint dwSceneID;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 48, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 取证方式
        /// </summary>
        //取证方式
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FORENSICS_MODE
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 0-手动取证 ,1-自动取证
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 23, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 报警场景信息
        /// </summary>
        //报警场景信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCENE_INFO
        {
            /// <summary>
            /// 场景ID, 0 - 表示该场景无效
            /// </summary>
            public uint dwSceneID;
            /// <summary>
            /// 场景名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] bySceneName;
            /// <summary>
            /// 显示方向 1-上行，2-下行，3-双向，4-由东向西，5-由南向北，6-由西向东，7-由北向南，8-其它
            /// </summary>
            public byte byDirection;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// Ptz 坐标
            /// </summary>
            public NET_DVR_PTZPOS struPtzPos;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 交通事件报警(扩展)
        /// </summary>
        //交通事件报警(扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AID_ALARM_V41
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 前端设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 交通事件信息
            /// </summary>
            public NET_DVR_AID_INFO struAIDInfo;
            /// <summary>
            /// 场景信息
            /// </summary>
            public NET_DVR_SCENE_INFO struSceneInfo;
            /// <summary>
            /// 图片长度
            /// </summary>
            public uint dwPicDataLen;
            /// <summary>
            /// 指向图片的指针
            /// </summary>
            public IntPtr pImage;
            /// <summary>
            /// 0-数据直接上传; 1-云存储服务器URL(3.7Ver)原先的图片数据变成URL数据，图片长度变成URL长度
            /// </summary>
            public byte byDataType;
            /// <summary>
            /// 关联车道号
            /// </summary>
            public byte byLaneNo;
            /// <summary>
            /// 时标毫秒
            /// </summary>
            public ushort wMilliSecond;
            /// <summary>
            /// 显示点编号（路口编号、内部编号）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MONITORSITE_ID_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMonitoringSiteID;
            /// <summary>
            /// 设备编号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = DEVICE_ID_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDeviceID;
            /// <summary>
            /// XML报警信息长度
            /// </summary>
            public uint dwXmlLen;
            /// <summary>
            /// XML报警信息指针,其XML对应到EventNotificationAlert XML Block
            /// </summary>
            public IntPtr pXmlBuf;
            /// <summary>
            /// 检测的目标类型，0~未知，1~行人、2~二轮车、3~三轮车(行人检测中返回)
            /// </summary>
            public byte byTargetType;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 19, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 交通统计信息报警(扩展)
        /// </summary>
        //交通统计信息报警(扩展)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TPS_ALARM_V41
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 前端设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 交通参数统计信息
            /// </summary>
            public NET_DVR_TPS_INFO_V41 struTPSInfo;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VCA_VERSION
        {
            /// <summary>
            /// 主版本号
            /// </summary>
            public ushort wMajorVersion;
            /// <summary>
            /// 次版本号
            /// </summary>
            public ushort wMinorVersion;
            /// <summary>
            /// 修正号
            /// </summary>
            public ushort wRevisionNumber;
            /// <summary>
            /// 编译号
            /// </summary>
            public ushort wBuildNumber;
            /// <summary>
            /// 版本日期-年
            /// </summary>
            public ushort wVersionYear;
            /// <summary>
            /// 版本日期-月
            /// </summary>
            public byte byVersionMonth;
            /// <summary>
            /// 版本日期-日
            /// </summary>
            public byte byVersionDay;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// *****************************智能交通事件 end****************************************
        /// ****************************车牌识别 begin*****************************************
        /// </summary>
        /*******************************智能交通事件 end*****************************************/

        /******************************车牌识别 begin******************************************/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLATE_PARAM
        {
            /// <summary>
            /// 车牌识别的模式,默认为1(视频触发模式)
            /// </summary>
            public byte byPlateRecoMode;
            /// <summary>
            /// 整牌置信度阈值, 只用于视频识别方式, 根据背景复杂程度设置, 误触发率高就设高, 漏车率高就设低,
            /// * 建议在80-90范围内
            /// </summary>
            public byte byBelive;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 22, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLATECFG
        {
            public uint dwSize;
            /// <summary>
            /// 是否启用视频车牌识别 0－否 1－是
            /// </summary>
            public uint dwEnable;
            /// <summary>
            /// 报警时图片处理方式 0-不处理 非0-上传
            /// </summary>
            public byte byPicProType;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 图片规格结构
            /// </summary>
            public NET_DVR_JPEGPARA struPictureParam;
            /// <summary>
            /// 车牌识别参数配置
            /// </summary>
            public NET_DVR_PLATE_PARAM struPlateParam;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION struHandleType;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 报警触发的录象通道,为1表示触发该通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 车牌识别结果子结构
        /// </summary>
        //车牌识别结果子结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLATE_INFO
        {
            /// <summary>
            /// 车牌类型
            /// </summary>
            public byte byPlateType;
            /// <summary>
            /// 车牌颜色
            /// </summary>
            public byte byColor;
            /// <summary>
            /// 车牌亮度
            /// </summary>
            public byte byBright;
            /// <summary>
            /// 车牌字符个数
            /// </summary>
            public byte byLicenseLen;
            /// <summary>
            /// 整个车牌的置信度，0-100
            /// </summary>
            public byte byEntireBelieve;
            /// <summary>
            /// 区域索引值 0-保留，1-欧洲(EU)，2-俄语区域(ER)，3-欧洲&俄罗斯(EU&CIS) ,4-中东(ME),0xff-所有
            /// </summary>
            public byte byRegion;
            /// <summary>
            /// 国家索引值，参照枚举COUNTRY_INDEX（不支持"COUNTRY_ALL = 0xff, //ALL  全部"）
            /// </summary>
            public byte byCountry;
            /// <summary>
            /// 区域（省份），各国家内部区域枚举，阿联酋参照 EMI_AREA
            /// </summary>
            public byte byArea;
            /// <summary>
            /// 车牌尺寸，0~未知，1~long, 2~short(中东车牌使用)
            /// </summary>
            public byte byPlateSize;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 15, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 车牌附加信息, 即中东车牌中车牌号码旁边的小字信息，(目前只有中东地区支持)
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CATEGORY_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPlateCategory;
            /// <summary>
            /// XML报警信息长度
            /// </summary>
            public uint dwXmlLen;
            /// <summary>
            /// XML报警信息指针,报警类型为 COMM_ITS_PLATE_RESUL时有效，其XML对应到EventNotificationAlert XML Block
            /// </summary>
            public IntPtr pXmlBuf;
            /// <summary>
            /// 车牌位置
            /// </summary>
            public NET_VCA_RECT struPlateRect;
            /// <summary>
            /// 车牌号码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LICENSE_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sLicense;
            /// <summary>
            /// 各个识别字符的置信度，如检测到车牌"浙A12345", 置信度为,20,30,40,50,60,70，则表示"浙"字正确的可能性只有%，"A"字的正确的可能性是%
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LICENSE_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byBelieve;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLATERECO_RESULE
        {
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 前段设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            public NET_DVR_PLATE_INFO struPlateInfo;
            /// <summary>
            /// 返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据
            /// </summary>
            public uint dwPicDataLen;
            /// <summary>
            /// 保留，设置为0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRes;
            /// <summary>
            /// 指向图片的指针
            /// </summary>
            public IntPtr pImage;
        }

        /// <summary>
        /// ****************************车牌识别 end*****************************************
        /// ****************************抓拍机******************************************
        /// IO输入配置
        /// </summary>
        /******************************车牌识别 end******************************************/

        /******************************抓拍机*******************************************/
        //IO输入配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IO_INCFG
        {
            public uint dwSize;
            /// <summary>
            /// 输入的IO口状态，0-下降沿，1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
            /// </summary>
            public byte byIoInStatus;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// IO输出配置
        /// </summary>
        //IO输出配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IO_OUTCFG
        {
            public uint dwSize;
            /// <summary>
            /// IO默认状态：0-低电平，1-高电平
            /// </summary>
            public byte byDefaultStatus;
            /// <summary>
            /// IO起效时状态：0-低电平，1-高电平，2-脉冲
            /// </summary>
            public byte byIoOutStatus;
            /// <summary>
            /// 输出IO提前时间，单位us
            /// </summary>
            public ushort wAheadTime;
            /// <summary>
            /// 脉冲间隔时间，单位us
            /// </summary>
            public uint dwTimePluse;
            /// <summary>
            /// IO有效持续时间，单位us
            /// </summary>
            public uint dwTimeDelay;
            /// <summary>
            /// 倍频，数值范围[1,15]
            /// </summary>
            public byte byFreqMulti;
            /// <summary>
            /// 占空比，[0,40%]
            /// </summary>
            public byte byDutyRate;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 闪光灯配置
        /// </summary>
        //闪光灯配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FLASH_OUTCFG
        {
            public uint dwSize;
            /// <summary>
            /// 闪光灯闪烁模式，0-不闪，1-闪，2-关联闪，3-轮闪
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 闪光灯关联的输入IO号（关联闪时此参数有效）
            /// </summary>
            public byte byRelatedIoIn;
            /// <summary>
            /// 关联的IO号，按位表示，bit0表示IO1是否关联，0-不关联，1-关联
            /// </summary>
            public byte byRecognizedLane;
            /// <summary>
            /// 自动检测亮度使能闪光灯0-不检测；1-检测
            /// </summary>
            public byte byDetectBrightness;
            /// <summary>
            /// 使能闪光灯亮度阈值，范围[0,100],高于阈值闪
            /// </summary>
            public byte byBrightnessThreld;
            /// <summary>
            /// 开始时间-小时,取值范围0-23
            /// </summary>
            public byte byStartHour;
            /// <summary>
            /// 开始时间-分,取值范围0-59
            /// </summary>
            public byte byStartMinute;
            /// <summary>
            /// 结束时间-小时,取值范围0-23
            /// </summary>
            public byte byEndHour;
            /// <summary>
            /// 结束时间-分,取值范围0-59
            /// </summary>
            public byte byEndMinute;
            /// <summary>
            /// 设置闪光灯时间使能:0-关;1-开
            /// </summary>
            public byte byFlashLightEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 红绿灯功能（2个IO输入一组）
        /// </summary>
        //红绿灯功能（2个IO输入一组）
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LIGHTSNAPCFG
        {
            public uint dwSize;
            /// <summary>
            /// 红绿灯的IO 号
            /// </summary>
            public byte byLightIoIn;
            /// <summary>
            /// 触发的IO号
            /// </summary>
            public byte byTrigIoIn;
            /// <summary>
            /// 触发IO关联的车道号
            /// </summary>
            public byte byRelatedDriveWay;
            /// <summary>
            /// 0-高电平红灯，低电平绿灯；1-高电平绿灯，低电平红灯
            /// </summary>
            public byte byTrafficLight;
            /// <summary>
            /// 红灯抓拍次数1，0-不抓拍，非0-连拍次数，最大5次
            /// </summary>
            public byte bySnapTimes1;
            /// <summary>
            /// 绿灯抓拍次数2，0-不抓拍，非0-连拍次数，最大5次
            /// </summary>
            public byte bySnapTimes2;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 红灯连拍间隔时间，ms
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_INTERVAL_NUM, ArraySubType = UnmanagedType.U2)]
            public ushort[] wIntervalTime1;
            /// <summary>
            /// 绿灯连拍间隔时间，ms
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_INTERVAL_NUM, ArraySubType = UnmanagedType.U2)]
            public ushort[] wIntervalTime2;
            /// <summary>
            /// 闯红灯周期录像标志，0-不录像，1-录像
            /// </summary>
            public byte byRecord;
            /// <summary>
            /// 闯红灯周期录像超时时间（秒）
            /// </summary>
            public byte bySessionTimeout;
            /// <summary>
            /// 闯红灯录像片段预录时间(秒)
            /// </summary>
            public byte byPreRecordTime;
            /// <summary>
            /// 闯红灯录像片段延时时间（秒）
            /// </summary>
            public byte byVideoDelay;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 测速功能(2个IO输入一组）
        /// </summary>
        //测速功能(2个IO输入一组）
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MEASURESPEEDCFG
        {
            public uint dwSize;
            /// <summary>
            /// 测速第1线圈
            /// </summary>
            public byte byTrigIo1;
            /// <summary>
            /// 测速第2线圈
            /// </summary>
            public byte byTrigIo2;
            /// <summary>
            /// 触发IO关联的车道号
            /// </summary>
            public byte byRelatedDriveWay;
            /// <summary>
            /// 测速模式超时时间，单位s
            /// </summary>
            public byte byTestSpeedTimeOut;
            /// <summary>
            /// 线圈距离,cm
            /// </summary>
            public uint dwDistance;
            /// <summary>
            /// 测速模式起拍速度，单位km/h
            /// </summary>
            public byte byCapSpeed;
            /// <summary>
            /// 限速值，单位km/h
            /// </summary>
            public byte bySpeedLimit;
            /// <summary>
            /// 线圈1抓拍次数，0-不抓拍，非0-连拍次数，最大5次
            /// </summary>
            public byte bySnapTimes1;
            /// <summary>
            /// 线圈2抓拍次数，0-不抓拍，非0-连拍次数，最大5次
            /// </summary>
            public byte bySnapTimes2;
            /// <summary>
            /// 线圈1连拍间隔时间，ms
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_INTERVAL_NUM, ArraySubType = UnmanagedType.U2)]
            public ushort[] wIntervalTime1;
            /// <summary>
            /// 线圈2连拍间隔时间，ms
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_INTERVAL_NUM, ArraySubType = UnmanagedType.U2)]
            public ushort[] wIntervalTime2;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 视频参数配置
        /// </summary>
        //视频参数配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VIDEOEFFECT
        {
            /// <summary>
            /// 0-100
            /// </summary>
            public byte byBrightnessLevel;
            /// <summary>
            /// 0-100
            /// </summary>
            public byte byContrastLevel;
            /// <summary>
            /// 0-100
            /// </summary>
            public byte bySharpnessLevel;
            /// <summary>
            /// 0-100
            /// </summary>
            public byte bySaturationLevel;
            /// <summary>
            /// 0-100,（保留）
            /// </summary>
            public byte byHueLevel;
            /// <summary>
            /// 使能，按位表示，bit0-SMART IR(防过曝)，bit1-低照度,bit2-强光抑制使能，0-否，1-是
            /// </summary>
            public byte byEnableFunc;
            /// <summary>
            /// 强光抑制等级，[1-3]表示等级
            /// </summary>
            public byte byLightInhibitLevel;
            /// <summary>
            /// 灰度值域，0-[0-255]，1-[16-235]
            /// </summary>
            public byte byGrayLevel;
        }

        /// <summary>
        /// 增益配置
        /// </summary>
        //增益配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_GAIN
        {
            /// <summary>
            /// 增益：0-100
            /// </summary>
            public byte byGainLevel;
            /// <summary>
            /// 用户自定义增益；0-100，对于抓拍机，是CCD模式下的抓拍增益
            /// </summary>
            public byte byGainUserSet;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 最大增益值，单位dB
            /// </summary>
            public uint dwMaxGainValue;
        }

        /// <summary>
        /// 白平衡配置
        /// </summary>
        //白平衡配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WHITEBALANCE
        {
            /// <summary>
            /// 0-手动白平衡（MWB）,1-自动白平衡1（AWB1）,2-自动白平衡2 (AWB2),3-自动控制改名为锁定白平衡(Locked WB)，
            /// 4-室外(Indoor)，5-室内(Outdoor)6-日光灯(Fluorescent Lamp)，7-钠灯(Sodium Lamp)，
            /// 8-自动(Auto-Track)9-一次白平衡(One Push)，10-室外自动(Auto-Outdoor)，
            /// 11-钠灯自动 (Auto-Sodiumlight)，12-水银灯(Mercury Lamp)，13-自动白平衡(Auto)，
            /// 14-白炽灯 (IncandescentLamp)，15-暖光灯(Warm Light Lamp)，16-自然光(Natural Light)
            /// </summary>
            public byte byWhiteBalanceMode;
            /// <summary>
            /// 手动白平衡时有效，手动白平衡 R增益
            /// </summary>
            public byte byWhiteBalanceModeRGain;
            /// <summary>
            /// 手动白平衡时有效，手动白平衡 B增益
            /// </summary>
            public byte byWhiteBalanceModeBGain;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 曝光控制
        /// </summary>
        //曝光控制
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_EXPOSURE
        {
            /// <summary>
            /// 0 手动曝光 1自动曝光
            /// </summary>
            public byte byExposureMode;
            /// <summary>
            /// 自动光圈灵敏度, 0-10
            /// </summary>
            public byte byAutoApertureLevel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 自定义视频曝光时间（单位us）
            /// 注:自动曝光时该值为曝光最慢值 新增20-1s(1000000us)
            /// </summary>
            public uint dwVideoExposureSet;
            /// <summary>
            /// 自定义曝光时间,在抓拍机上应用时，CCD模式时是抓拍快门速度
            /// </summary>
            public uint dwExposureUserSet;
            public uint dwRes;
        }

        /// <summary>
        /// 宽动态配置
        /// </summary>
        //宽动态配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WDR
        {
            /// <summary>
            /// 宽动态：0 dsibale  1 enable 2 auto
            /// </summary>
            public byte byWDREnabled;
            /// <summary>
            /// 0-F
            /// </summary>
            public byte byWDRLevel1;
            /// <summary>
            /// 0-F
            /// </summary>
            public byte byWDRLevel2;
            /// <summary>
            /// 0-100
            /// </summary>
            public byte byWDRContrastLevel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 日夜转换功能配置
        /// </summary>
        //日夜转换功能配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DAYNIGHT
        {
            /// <summary>
            /// 日夜切换：0-白天，1-夜晚，2-自动，3-定时，4-报警输入触发
            /// </summary>
            public byte byDayNightFilterType;
            /// <summary>
            /// 0 dsibale  1 enable,(保留)
            /// </summary>
            public byte bySwitchScheduleEnabled;
            /// <summary>
            /// 定时模式参数
            /// </summary>
            public byte byBeginTime;
            /// <summary>
            /// 结束时间（小时），0-23
            /// </summary>
            public byte byEndTime;
            /// <summary>
            /// 模式2
            /// </summary>
            public byte byDayToNightFilterLevel;
            /// <summary>
            /// 0-7
            /// </summary>
            public byte byNightToDayFilterLevel;
            /// <summary>
            /// (60秒)
            /// </summary>
            public byte byDayNightFilterTime;
            /// <summary>
            /// 定时模式参数
            /// </summary>
            public byte byBeginTimeMin;
            /// <summary>
            /// 开始时间（秒），0-59
            /// </summary>
            public byte byBeginTimeSec;
            /// <summary>
            /// 结束时间（分），0-59
            /// </summary>
            public byte byEndTimeMin;
            /// <summary>
            /// 结束时间（秒），0-59
            /// </summary>
            public byte byEndTimeSec;
            /// <summary>
            /// 报警输入触发模式参数
            /// </summary>
            public byte byAlarmTrigState;
        }

        /// <summary>
        /// Gamma校正
        /// </summary>
        //Gamma校正
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_GAMMACORRECT
        {
            /// <summary>
            /// 0 dsibale  1 enable
            /// </summary>
            public byte byGammaCorrectionEnabled;
            /// <summary>
            /// 0-100
            /// </summary>
            public byte byGammaCorrectionLevel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 背光补偿配置
        /// </summary>
        //背光补偿配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_BACKLIGHT
        {
            /// <summary>
            /// 背光补偿:0 off 1 UP、2 DOWN、3 LEFT、4 RIGHT、5MIDDLE、6自定义
            /// </summary>
            public byte byBacklightMode;
            /// <summary>
            /// 0x0-0xF
            /// </summary>
            public byte byBacklightLevel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// （X坐标1）
            /// </summary>
            public uint dwPositionX1;
            /// <summary>
            /// （Y坐标1）
            /// </summary>
            public uint dwPositionY1;
            /// <summary>
            /// （X坐标2）
            /// </summary>
            public uint dwPositionX2;
            /// <summary>
            /// （Y坐标2）
            /// </summary>
            public uint dwPositionY2;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 数字降噪功能
        /// </summary>
        //数字降噪功能
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_NOISEREMOVE
        {
            /// <summary>
            /// 0-不启用，1-普通模式数字降噪，2-专家模式数字降噪
            /// </summary>
            public byte byDigitalNoiseRemoveEnable;
            /// <summary>
            /// 普通模式数字降噪级别：0x0-0xF
            /// </summary>
            public byte byDigitalNoiseRemoveLevel;
            /// <summary>
            /// 专家模式下空域强度：0-100
            /// </summary>
            public byte bySpectralLevel;
            /// <summary>
            /// 专家模式下时域强度：0-100
            /// </summary>
            public byte byTemporalLevel;
            /// <summary>
            /// 抓拍帧2D降噪，0-不启用，1-启用
            /// </summary>
            public byte byDigitalNoiseRemove2DEnable;
            /// <summary>
            /// 抓拍帧2D降噪级别，0-100
            /// </summary>
            public byte byDigitalNoiseRemove2DLevel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// CMOS模式下前端镜头配置
        /// </summary>
        //CMOS模式下前端镜头配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CMOSMODECFG
        {
            /// <summary>
            /// 抓拍模式：0-抓拍模式1；1-抓拍模式2
            /// </summary>
            public byte byCaptureMod;
            /// <summary>
            /// 亮度阈值
            /// </summary>
            public byte byBrightnessGate;
            /// <summary>
            /// 抓拍增益1,0-100
            /// </summary>
            public byte byCaptureGain1;
            /// <summary>
            /// 抓拍增益2,0-100
            /// </summary>
            public byte byCaptureGain2;
            /// <summary>
            /// 抓拍快门速度1
            /// </summary>
            public uint dwCaptureShutterSpeed1;
            /// <summary>
            /// 抓拍快门速度2
            /// </summary>
            public uint dwCaptureShutterSpeed2;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 前端参数配置
        /// </summary>
        //前端参数配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CAMERAPARAMCFG
        {
            public uint dwSize;
            /// <summary>
            /// 亮度、对比度、饱和度、锐度、色调配置
            /// </summary>
            public NET_DVR_VIDEOEFFECT struVideoEffect;
            /// <summary>
            /// 自动增益
            /// </summary>
            public NET_DVR_GAIN struGain;
            /// <summary>
            /// 白平衡
            /// </summary>
            public NET_DVR_WHITEBALANCE struWhiteBalance;
            /// <summary>
            /// 曝光控制
            /// </summary>
            public NET_DVR_EXPOSURE struExposure;
            /// <summary>
            /// Gamma校正
            /// </summary>
            public NET_DVR_GAMMACORRECT struGammaCorrect;
            /// <summary>
            /// 宽动态
            /// </summary>
            public NET_DVR_WDR struWdr;
            /// <summary>
            /// 日夜转换
            /// </summary>
            public NET_DVR_DAYNIGHT struDayNight;
            /// <summary>
            /// 背光补偿
            /// </summary>
            public NET_DVR_BACKLIGHT struBackLight;
            /// <summary>
            /// 数字降噪
            /// </summary>
            public NET_DVR_NOISEREMOVE struNoiseRemove;
            /// <summary>
            /// 0-50HZ; 1-60HZ
            /// </summary>
            public byte byPowerLineFrequencyMode;
            /// <summary>
            /// 0 自动光圈 1手动光圈
            /// </summary>
            public byte byIrisMode;
            /// <summary>
            /// 镜像：0 off，1- leftright，2- updown，3-center
            /// </summary>
            public byte byMirror;
            /// <summary>
            /// 数字缩放:0 dsibale  1 enable
            /// </summary>
            public byte byDigitalZoom;
            /// <summary>
            /// 坏点检测,0 dsibale  1 enable
            /// </summary>
            public byte byDeadPixelDetect;
            /// <summary>
            /// 黑电平补偿 ,  0-255
            /// </summary>
            public byte byBlackPwl;
            /// <summary>
            /// EPTZ开关变量:0-不启用电子云台，1-启用电子云台
            /// </summary>
            public byte byEptzGate;
            /// <summary>
            /// 本地输出开关变量0-本地输出关闭1-本地BNC输出打开 2-HDMI输出关闭
            /// </summary>
            public byte byLocalOutputGate;
            /// <summary>
            /// 20-HDMI_720P50输出开
            /// 21-HDMI_720P60输出开
            /// 22-HDMI_1080I60输出开
            /// 23-HDMI_1080I50输出开
            /// 24-HDMI_1080P24输出开
            /// 25-HDMI_1080P25输出开
            /// 26-HDMI_1080P30输出开
            /// 27-HDMI_1080P50输出开
            /// 28-HDMI_1080P60输出开
            /// 40-SDI_720P50,
            /// 41-SDI_720P60,
            /// 42-SDI_1080I50,
            /// 43-SDI_1080I60,
            /// 44-SDI_1080P24,
            /// 45-SDI_1080P25,
            /// 46-SDI_1080P30,
            /// 47-SDI_1080P50,
            /// 48-SDI_1080P60
            /// </summary>
            public byte byCoderOutputMode;
            /// <summary>
            /// 是否开启行编码：0-否，1-是
            /// </summary>
            public byte byLineCoding;
            /// <summary>
            /// 调光模式：0-半自动，1-自动
            /// </summary>
            public byte byDimmerMode;
            /// <summary>
            /// 调色板：0-白热，1-黑热，2-调色板2，…，8-调色板8
            /// </summary>
            public byte byPaletteMode;
            /// <summary>
            /// 增强方式（探测物体周边）：0-不增强，1-1，2-2，3-3，4-4
            /// </summary>
            public byte byEnhancedMode;
            /// <summary>
            /// 动态对比度增强 0-1
            /// </summary>
            public byte byDynamicContrastEN;
            /// <summary>
            /// 动态对比度 0-100
            /// </summary>
            public byte byDynamicContrast;
            /// <summary>
            /// JPEG图像质量 0-100
            /// </summary>
            public byte byJPEGQuality;
            /// <summary>
            /// CMOS模式下前端参数配置，镜头模式从能力集获取
            /// </summary>
            public NET_DVR_CMOSMODECFG struCmosModeCfg;
            /// <summary>
            /// 滤波开关：0-不启用，1-启用
            /// </summary>
            public byte byFilterSwitch;
            /// <summary>
            /// 镜头调焦速度：0-10
            /// </summary>
            public byte byFocusSpeed;
            /// <summary>
            /// 定时自动快门补偿：1-120，单位：分钟
            /// </summary>
            public byte byAutoCompensationInterval;
            /// <summary>
            /// 场景模式：0-室外，1-室内，2-默认，3-弱光
            /// </summary>
            public byte bySceneMode;
        }

        /// <summary>
        /// 透雾
        /// </summary>
        //透雾
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEFOGCFG
        {
            /// <summary>
            /// 模式，0-不启用，1-自动模式，2-常开模式
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 等级，0-100
            /// </summary>
            public byte byLevel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 电子防抖
        /// </summary>
        //电子防抖
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ELECTRONICSTABILIZATION
        {
            /// <summary>
            /// 使能 0- 不启用，1- 启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 等级，0-100
            /// </summary>
            public byte byLevel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 走廊模式
        /// </summary>
        //走廊模式
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CORRIDOR_MODE_CCD
        {
            /// <summary>
            /// 是否启用走廊模式 0～不启用， 1～启用
            /// </summary>
            public byte byEnableCorridorMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// SMART IR(防过曝)配置参数
        /// </summary>
        //SMART IR(防过曝)配置参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SMARTIR_PARAM
        {
            /// <summary>
            /// 0～手动，1～自动
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 红外距离等级(等级，距离正比例)level:1~100 默认:50（手动模式下增加）
            /// </summary>
            public byte byIRDistance;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 在byIrisMode 为P-Iris1时生效，配置红外光圈大小等级，配置模式
        /// </summary>
        //在byIrisMode 为P-Iris1时生效，配置红外光圈大小等级，配置模式
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PIRIS_PARAM
        {
            /// <summary>
            /// 0-自动，1-手动
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 红外光圈大小等级(等级,光圈大小正比例)level:1~100 默认:50（手动模式下增加）
            /// </summary>
            public byte byPIrisAperture;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 前端参数配置
        /// </summary>
        //前端参数配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CAMERAPARAMCFG_EX
        {
            public uint dwSize;
            /// <summary>
            /// 亮度、对比度、饱和度、锐度、色调配置
            /// </summary>
            public NET_DVR_VIDEOEFFECT struVideoEffect;
            /// <summary>
            /// 自动增益
            /// </summary>
            public NET_DVR_GAIN struGain;
            /// <summary>
            /// 白平衡
            /// </summary>
            public NET_DVR_WHITEBALANCE struWhiteBalance;
            /// <summary>
            /// 曝光控制
            /// </summary>
            public NET_DVR_EXPOSURE struExposure;
            /// <summary>
            /// Gamma校正
            /// </summary>
            public NET_DVR_GAMMACORRECT struGammaCorrect;
            /// <summary>
            /// 宽动态
            /// </summary>
            public NET_DVR_WDR struWdr;
            /// <summary>
            /// 日夜转换
            /// </summary>
            public NET_DVR_DAYNIGHT struDayNight;
            /// <summary>
            /// 背光补偿
            /// </summary>
            public NET_DVR_BACKLIGHT struBackLight;
            /// <summary>
            /// 数字降噪
            /// </summary>
            public NET_DVR_NOISEREMOVE struNoiseRemove;
            /// <summary>
            /// 0-50HZ; 1-60HZ
            /// </summary>
            public byte byPowerLineFrequencyMode;
            /// <summary>
            /// 0-自动光圈 1-手动光圈, 2-P-Iris1
            /// </summary>
            public byte byIrisMode;
            /// <summary>
            /// 镜像：0 off，1- leftright，2- updown，3-center
            /// </summary>
            public byte byMirror;
            /// <summary>
            /// 数字缩放:0 dsibale  1 enable
            /// </summary>
            public byte byDigitalZoom;
            /// <summary>
            /// 坏点检测,0 dsibale  1 enable
            /// </summary>
            public byte byDeadPixelDetect;
            /// <summary>
            /// 黑电平补偿 ,  0-255
            /// </summary>
            public byte byBlackPwl;
            /// <summary>
            /// EPTZ开关变量:0-不启用电子云台，1-启用电子云台
            /// </summary>
            public byte byEptzGate;
            /// <summary>
            /// 本地输出开关变量0-本地输出关闭1-本地BNC输出打开 2-HDMI输出关闭
            /// </summary>
            public byte byLocalOutputGate;
            /// <summary>
            /// 20-HDMI_720P50输出开
            /// 21-HDMI_720P60输出开
            /// 22-HDMI_1080I60输出开
            /// 23-HDMI_1080I50输出开
            /// 24-HDMI_1080P24输出开
            /// 25-HDMI_1080P25输出开
            /// 26-HDMI_1080P30输出开
            /// 27-HDMI_1080P50输出开
            /// 28-HDMI_1080P60输出开
            /// </summary>
            public byte byCoderOutputMode;
            /// <summary>
            /// 是否开启行编码：0-否，1-是
            /// </summary>
            public byte byLineCoding;
            /// <summary>
            /// 调光模式：0-半自动，1-自动
            /// </summary>
            public byte byDimmerMode;
            /// <summary>
            /// 调色板：0-白热，1-黑热，2-调色板2，…，8-调色板8
            /// </summary>
            public byte byPaletteMode;
            /// <summary>
            /// 增强方式（探测物体周边）：0-不增强，1-1，2-2，3-3，4-4
            /// </summary>
            public byte byEnhancedMode;
            /// <summary>
            /// 动态对比度增强 0-1
            /// </summary>
            public byte byDynamicContrastEN;
            /// <summary>
            /// 动态对比度 0-100
            /// </summary>
            public byte byDynamicContrast;
            /// <summary>
            /// JPEG图像质量 0-100
            /// </summary>
            public byte byJPEGQuality;
            /// <summary>
            /// CMOS模式下前端参数配置，镜头模式从能力集获取
            /// </summary>
            public NET_DVR_CMOSMODECFG struCmosModeCfg;
            /// <summary>
            /// 滤波开关：0-不启用，1-启用
            /// </summary>
            public byte byFilterSwitch;
            /// <summary>
            /// 镜头调焦速度：0-10
            /// </summary>
            public byte byFocusSpeed;
            /// <summary>
            /// 定时自动快门补偿：1-120，单位：分钟
            /// </summary>
            public byte byAutoCompensationInterval;
            /// <summary>
            /// 场景模式：0-室外，1-室内，2-默认，3-弱光
            /// </summary>
            public byte bySceneMode;
            /// <summary>
            /// 透雾参数
            /// </summary>
            public NET_DVR_DEFOGCFG struDefogCfg;
            /// <summary>
            /// 电子防抖
            /// </summary>
            public NET_DVR_ELECTRONICSTABILIZATION struElectronicStabilization;
            /// <summary>
            /// 走廊模式
            /// </summary>
            public NET_DVR_CORRIDOR_MODE_CCD struCorridorMode;
            /// <summary>
            /// 0~不启用,1~启用  曝光时间和增益呈阶梯状调整，比如曝光往上调整时，先提高曝光时间到中间值，然后提高增益到中间值，再提高曝光到最大值，最后提高增益到最大值
            /// </summary>
            public byte byExposureSegmentEnable;
            /// <summary>
            /// 亮度增强 [0~100]
            /// </summary>
            public byte byBrightCompensate;
            /// <summary>
            /// 0-关闭、1-640*480@25fps、2-640*480@30ps、3-704*576@25fps、4-704*480@30fps、5-1280*720@25fps、6-1280*720@30fps、
            /// 7-1280*720@50fps、8-1280*720@60fps、9-1280*960@15fps、10-1280*960@25fps、11-1280*960@30fps、
            /// 12-1280*1024@25fps、13--1280*1024@30fps、14-1600*900@15fps、15-1600*1200@15fps、16-1920*1080@15fps、
            /// 17-1920*1080@25fps、18-1920*1080@30fps、19-1920*1080@50fps、20-1920*1080@60fps、21-2048*1536@15fps、22-2048*1536@20fps、
            /// 23-2048*1536@24fps、24-2048*1536@25fps、25-2048*1536@30fps、26-2560*2048@25fps、27-2560*2048@30fps、
            /// 28-2560*1920@7.5fps、29-3072*2048@25fps、30-3072*2048@30fps、31-2048*1536@12.5、32-2560*1920@6.25、
            /// 33-1600*1200@25、34-1600*1200@30、35-1600*1200@12.5、36-1600*900@12.5、37-1600@900@15、38-800*600@25、39-800*600@30
            /// </summary>
            public byte byCaptureModeN;
            /// <summary>
            /// 视频输入模式（P制）
            /// </summary>
            public byte byCaptureModeP;
            /// <summary>
            /// 红外放过爆配置信息
            /// </summary>
            public NET_DVR_SMARTIR_PARAM struSmartIRParam;
            /// <summary>
            /// PIris配置信息对应byIrisMode字段从2-PIris1开始生效
            /// </summary>
            public NET_DVR_PIRIS_PARAM struPIrisParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 296, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        /// <summary>
        /// 车牌类型
        /// </summary>
        public enum VCA_PLATE_TYPE
        {
            /// <summary>
            /// 标准民用车与特种车
            /// </summary>
            VCA_STANDARD92_PLATE = 0,
            /// <summary>
            /// 02式民用车牌
            /// </summary>
            VCA_STANDARD02_PLATE,
            /// <summary>
            /// 武警车
            /// </summary>
            VCA_WJPOLICE_PLATE,
            /// <summary>
            /// 警车
            /// </summary>
            VCA_JINGCHE_PLATE,
            /// <summary>
            /// 民用车双行尾牌
            /// </summary>
            STANDARD92_BACK_PLATE,
            /// <summary>
            /// 使馆车牌
            /// </summary>
            VCA_SHIGUAN_PLATE,
            /// <summary>
            /// 农用车
            /// </summary>
            VCA_NONGYONG_PLATE,
            /// <summary>
            /// 摩托车
            /// </summary>
            VCA_MOTO_PLATE,
            /// <summary>
            /// 新能源车牌
            /// </summary>
            NEW_ENERGY_PLATE,
            /// <summary>
            /// 领事馆车牌
            /// </summary>
            VCA_CONSULATE_PLATE = 9,
            /// <summary>
            /// 应急车牌
            /// </summary>
            VCA_EMERGENCY_PLATE = 10,
            /// <summary>
            /// 2017-05-18 增加 中东地区车牌类型
            /// </summary>
            TRANSPORT_PLATE = 0x20,
            /// <summary>
            /// 商用车
            /// </summary>
            COMMERCIAL_PLATE,
            /// <summary>
            /// 私家车
            /// </summary>
            PRIVATE_PLATE,
            /// <summary>
            /// 教练车
            /// </summary>
            LEARNING_PLATE,
            /// <summary>
            /// 使馆车
            /// </summary>
            CD_PLATE,
            /// <summary>
            /// 使馆车
            /// </summary>
            CC_PLATE,
            /// <summary>
            /// 特种车
            /// </summary>
            SPECIAL_PLATE,
            /// <summary>
            /// PROTOCOL
            /// </summary>
            PROTOCOL_PLATE,
            /// <summary>
            /// 政府车
            /// </summary>
            GOVERNMENT_PLATE,
            /// <summary>
            /// EXPORT
            /// </summary>
            EXPORT_PLATE,
            /// <summary>
            /// 出租车
            /// </summary>
            TAXI_PLATE,
            /// <summary>
            /// TESTING
            /// </summary>
            TESTING_PLATE,
            /// <summary>
            /// TRANSFER
            /// </summary>
            TRANSFER_PLATE,
            /// <summary>
            /// 货车
            /// </summary>
            TRUCK_PLATE,
            /// <summary>
            /// 公交车
            /// </summary>
            BUS_PLATE,
            /// <summary>
            /// PUBLIC
            /// </summary>
            PUBLIC_PLATE,
            /// <summary>
            /// PUBLIC TRANSFER
            /// </summary>
            PUB_TRANS_PLATE,
            /// <summary>
            /// PRIVATE TRANSPORT
            /// </summary>
            PRI_TRANS_PLATE,
            /// <summary>
            /// 二轮车
            /// </summary>
            TUMBREL_PLATE,
            /// <summary>
            /// 港澳入出车
            /// </summary>
            HONG_KONG_MACAO_PLATE,
            /// <summary>
            /// 未知（未识别）
            /// </summary>
            UNKNOWN_PLATE = 0xff
        }

        public enum VLR_VEHICLE_CLASS
        {
            /// <summary>
            /// 其它
            /// </summary>
            VLR_OTHER = 0,
            /// <summary>
            /// 大众
            /// </summary>
            VLR_VOLKSWAGEN = 1,
            /// <summary>
            /// 别克
            /// </summary>
            VLR_BUICK = 2,
            /// <summary>
            /// 宝马
            /// </summary>
            VLR_BMW = 3,
            /// <summary>
            /// 本田
            /// </summary>
            VLR_HONDA = 4,
            /// <summary>
            /// 标致
            /// </summary>
            VLR_PEUGEOT = 5,
            /// <summary>
            /// 丰田
            /// </summary>
            VLR_TOYOTA = 6,
            /// <summary>
            /// 福特
            /// </summary>
            VLR_FORD = 7,
            /// <summary>
            /// 日产
            /// </summary>
            VLR_NISSAN = 8,
            /// <summary>
            /// 奥迪
            /// </summary>
            VLR_AUDI = 9,
            /// <summary>
            /// 马自达
            /// </summary>
            VLR_MAZDA = 10,
            /// <summary>
            /// 雪佛兰
            /// </summary>
            VLR_CHEVROLET = 11,
            /// <summary>
            /// 雪铁龙
            /// </summary>
            VLR_CITROEN = 12,
            /// <summary>
            /// 现代
            /// </summary>
            VLR_HYUNDAI = 13,
            /// <summary>
            /// 奇瑞
            /// </summary>
            VLR_CHERY = 14
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VEHICLE_INFO
        {
            public uint dwIndex;
            public byte byVehicleType;
            public byte byColorDepth;
            public byte byColor;
            public byte byRadarState;
            public ushort wSpeed;
            public ushort wLength;
            public byte byIllegalType;
            /// <summary>
            /// 参考枚举类型 VLR_VEHICLE_CLASS
            /// </summary>
            public byte byVehicleLogoRecog;
            /// <summary>
            /// 车辆品牌子类型识别；参考VSB_VOLKSWAGEN_CLASS等子类型枚举。
            /// </summary>
            public byte byVehicleSubLogoRecog;
            /// <summary>
            /// 车辆子品牌年款，0-未知，参考"车辆子品牌年款.xlsx"
            /// </summary>
            public byte byVehicleModel;
            /// <summary>
            /// 自定义信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byCustomInfo;
            /// <summary>
            /// 车辆主品牌，参考"车辆主品牌.xlsx" (该字段兼容byVehicleLogoRecog);
            /// </summary>
            public ushort wVehicleLogoRecog;
            /// <summary>
            /// 是否停车 0-无效，1-停车，2-未停车
            /// </summary>
            public byte byIsParking;
            /// <summary>
            /// 保留字节
            /// </summary>
            public byte byRes;
            /// <summary>
            /// 停车时间，单位：s
            /// </summary>
            public uint dwParkingTime;
            /// <summary>
            /// byIllegalType置信度，1-100
            /// </summary>
            public byte byBelieve;
            /// <summary>
            /// 当前作业人数
            /// </summary>
            public byte byCurrentWorkerNumber;
            /// <summary>
            /// 当前货物装载率 0-空 1-少 2-中 3-多 4-满
            /// </summary>
            public byte byCurrentGoodsLoadingRate;
            /// <summary>
            /// 车门状态 0-车门关闭 1-车门开启
            /// </summary>
            public byte byDoorsStatus;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLATE_RESULT
        {
            public uint dwSize;
            public byte byResultType;
            public byte byChanIndex;
            /// <summary>
            /// 报警录像ID(用于查询录像，仅当byResultType为2时有效)
            /// </summary>
            public ushort wAlarmRecordID;
            public uint dwRelativeTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byAbsTime;
            public uint dwPicLen;
            public uint dwPicPlateLen;
            public uint dwVideoLen;
            public byte byTrafficLight;
            public byte byPicNum;
            public byte byDriveChan;
            /// <summary>
            /// 0- 未知，1- 客车，2- 货车，3- 轿车，4- 面包车，5- 小货车
            /// </summary>
            public byte byVehicleType;
            public uint dwBinPicLen;
            public uint dwCarPicLen;
            public uint dwFarCarPicLen;
            public IntPtr pBuffer3;
            public IntPtr pBuffer4;
            public IntPtr pBuffer5;
            public byte byRelaLaneDirectionType;
            public byte byCarDirectionType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
            public NET_DVR_PLATE_INFO struPlateInfo;
            public NET_DVR_VEHICLE_INFO struVehicleInfo;
            public IntPtr pBuffer1;
            public IntPtr pBuffer2;
        }

        /// <summary>
        /// 图像叠加信息配置
        /// </summary>
        //图像叠加信息配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IMAGEOVERLAYCFG
        {
            public uint dwSize;
            /// <summary>
            /// 叠加使能开关，0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayInfo;
            /// <summary>
            /// 是否叠加显示点信息，0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayMonitorInfo;
            /// <summary>
            /// 是否叠加时间，0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayTime;
            /// <summary>
            /// 是否叠加速度，0-不叠加，1-叠加
            /// </summary>
            public byte byOverlaySpeed;
            /// <summary>
            /// 是否叠加超速比例，0-不叠加，1-叠加
            /// </summary>
            public byte byOverlaySpeeding;
            /// <summary>
            /// 是否叠加限速标志，0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayLimitFlag;
            /// <summary>
            /// 是否叠加车牌号，0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayPlate;
            /// <summary>
            /// 是否叠加车身颜色，0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayColor;
            /// <summary>
            /// 是否叠加车长，0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayLength;
            /// <summary>
            /// 是否叠加车型，0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayType;
            /// <summary>
            /// 是否叠加车身颜色深浅，0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayColorDepth;
            /// <summary>
            /// 是否叠加车道，0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayDriveChan;
            /// <summary>
            /// 叠加毫秒信息 0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayMilliSec;
            /// <summary>
            /// 叠加违章信息 0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayIllegalInfo;
            /// <summary>
            /// 叠加红灯已亮时间 0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayRedOnTime;
            /// <summary>
            /// 远景图是否叠加车牌截图,0-不叠加,1-叠加
            /// </summary>
            public byte byFarAddPlateJpeg;
            /// <summary>
            /// 近景图是否叠加车牌截图,0-不叠加,1-叠加
            /// </summary>
            public byte byNearAddPlateJpeg;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 显示点信息1
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byMonitorInfo1;
            /// <summary>
            /// 检测点信息2
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 44, ArraySubType = UnmanagedType.I1)]
            public byte[] byMonitorInfo2;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 52, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        public struct NET_DVR_FACELIB_GUARD_COND
        {
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 人脸库的ID
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 68, ArraySubType = UnmanagedType.I1)]
            public byte[] szFDID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        public struct NET_DVR_EVENT_SCHEDULE
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 假日布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struHolidayAlarmTime;
            /// <summary>
            /// 场景号,目前支持1~4场景，0为无效。该场景号与布防时间中每个时间段一一对应。
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] bySceneID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 72, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SNAPCFG
        {
            public uint dwSize;
            public byte byRelatedDriveWay;
            public byte bySnapTimes;
            public ushort wSnapWaitTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_INTERVAL_NUM, ArraySubType = UnmanagedType.U2)]
            public ushort[] wIntervalTime;
            /// <summary>
            /// 抓拍车辆序号。
            /// </summary>
            public uint dwSnapVehicleNum;
            /// <summary>
            /// 抓拍图片参数
            /// </summary>
            public NET_DVR_JPEGPARA struJpegPara;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        public enum ITC_MAINMODE_ABILITY
        {
            /// <summary>
            /// 无
            /// </summary>
            ITC_MODE_UNKNOW = 0x0,
            /// <summary>
            /// 卡口模式
            /// </summary>
            ITC_POST_MODE = 0x1,
            /// <summary>
            /// 电警模式
            /// </summary>
            ITC_EPOLICE_MODE = 0x2,
            /// <summary>
            /// 卡式电警模式
            /// </summary>
            ITC_POSTEPOLICE_MODE = 0x4
        }

        public enum ITC_RECOG_REGION_TYPE
        {
            /// <summary>
            /// 矩形
            /// </summary>
            ITC_REGION_RECT = 0x0,
            /// <summary>
            /// 多边形
            /// </summary>
            ITC_REGION_POLYGON = 0x1
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SNAP_ABILITY
        {
            public uint dwSize;
            /// <summary>
            /// IO输入口数
            /// </summary>
            public byte byIoInNum;
            /// <summary>
            /// IO输出口数
            /// </summary>
            public byte byIoOutNum;
            /// <summary>
            /// 单IO触发组数
            /// </summary>
            public byte bySingleSnapNum;
            /// <summary>
            /// 红绿灯模式组数
            /// </summary>
            public byte byLightModeArrayNum;
            /// <summary>
            /// 测速模式组数
            /// </summary>
            public byte byMeasureModeArrayNum;
            /// <summary>
            /// 车牌识别能力
            /// </summary>
            public byte byPlateEnable;
            /// <summary>
            /// 镜头模式0-CCD,1-CMOS
            /// </summary>
            public byte byLensMode;
            /// <summary>
            /// 是否支持原触发模式，0-支持，1-不支持
            /// </summary>
            public byte byPreTriggerSupport;
            /// <summary>
            /// 支持的触发模式能力，按位表示，定义见ITC_MAINMODE_ABILITY
            /// </summary>
            public uint dwAbilityType;
            /// <summary>
            /// 支持的IO测速组数
            /// </summary>
            public byte byIoSpeedGroup;
            /// <summary>
            /// 支持的IO红绿灯组数
            /// </summary>
            public byte byIoLightGroup;
            /// <summary>
            /// 牌识区域支持的类型，详见定义ITC_RECOG_REGION_TYPE
            /// </summary>
            public byte byRecogRegionType;
            /// <summary>
            /// 设备能力，按位表示，0-不支持，1-支持
            /// </summary>
            public byte bySupport;
            /// <summary>
            /// bySupport&0x1，表示是否支持扩展的字符叠加配置
            /// bySupport&0x2，表示是否支持扩展的校时配置结构
            /// bySupport&0x4, 表示是否支持多网卡(多网隔离)
            /// bySupport&0x8, 表示是否支持网卡的bonding功能(网络容错)
            /// bySupport&0x10, 表示是否支持语音对讲
            /// 2013-07-09 能力集返回
            /// </summary>
            public ushort wSupportMultiRadar;
            /// <summary>
            /// wSupportMultiRadar&0x1，表示 卡口RS485雷达 支持车道关联雷达处理
            /// wSupportMultiRadar&0x2，表示 卡口虚拟线圈 支持车道关联雷达处理
            /// wSupportMultiRadar&0x4，表示 混行卡口 支持车道关联雷达处理
            /// wSupportMultiRadar&0x8，表示 视频检测 支持车道关联雷达处理
            /// </summary>
            public byte byICRPresetNum;
            /// <summary>
            /// 表示支持的ICR预置点（滤光片偏移点）数
            /// </summary>
            public byte byICRTimeSlot;
            /// <summary>
            /// 表示支持的RS485口的数量
            /// </summary>
            public byte bySupportRS485Num;
            /// <summary>
            /// 设备能力，按位表示，0-不支持，1-支持
            /// </summary>
            public byte byExpandRs485SupportSensor;
            /// <summary>
            /// byExpandRs485SupportSensor &0x1，表示电警车检器支持车检器
            /// byExpandRs485SupportSensor &0x2，表示卡式电警车检器支持车检器
            /// </summary>
            public byte byExpandRs485SupportSignalLampDet;
            /// <summary>
            /// byExpandRs485SupportSignalLampDet &0x1，表示电警车检器支持外接信号灯检测器
            /// byExpandRs485SupportSignalLampDet &0x2，表示卡式电警车检器支持外接信号灯检测器
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 13, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITC_ICRTIMECFG
        {
            public NET_DVR_SCHEDTIME struTime;
            /// <summary>
            /// 预置点号1～8 , 0代表无
            /// </summary>
            public byte byAssociateRresetNo;
            /// <summary>
            /// 1~白天，2~晚上 (当预置点等于0 的时候生效)
            /// </summary>
            public byte bySubSwitchMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 10, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITC_ICR_TIMESWITCH_PARAM
        {
            /// <summary>
            /// 自动切换时间段 (自动切换下 时空下生效 现在支持4组，预留4组)
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_ITC_ICRTIMECFG[] struAutoCtrlTime;
            /// <summary>
            /// 实际生效根据能力集动态显示 [0~100] 数组下标表示预置点号1～8 （0～7 相对应）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ICR_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byICRPreset;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITC_ICR_MANUALSWITCH_PARAM
        {
            /// <summary>
            /// 实际生效根据能力集动态显示 [0~100]
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ICR_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byICRPreset;
            /// <summary>
            /// 1~白天，2~晚上
            /// </summary>
            public byte bySubSwitchMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 147, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITC_ICR_AOTOSWITCH_PARAM
        {
            /// <summary>
            /// 实际生效根据能力集动态显示 [0~100] 数组下标表示预置点号1～8 （0～7 相对应）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ICR_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byICRPreset;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 148, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITC_ICR_PARAM_UNION
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 156, ArraySubType = UnmanagedType.I1)]
            public byte[] uLen;
            public NET_ITC_ICR_AOTOSWITCH_PARAM struICRAutoSwitch;
            public NET_ITC_ICR_MANUALSWITCH_PARAM struICRManualSwitch;
            public NET_ITC_ICR_TIMESWITCH_PARAM struICRTimeSwitch;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITC_ICRCFG
        {
            public uint dwSize;
            /// <summary>
            /// 1~自动切换，2~手动切换 ,3~定时切换
            /// </summary>
            public byte bySwitchType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public NET_ITC_ICR_PARAM_UNION uICRParam;
        }

        /// <summary>
        /// 2013-07-09 异常处理
        /// </summary>
        //2013-07-09 异常处理
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITC_HANDLEEXCEPTION
        {
            /// <summary>
            /// 异常处理,异常处理方式的"或"结果
            /// </summary>
            public uint dwHandleType;
            /// <summary>
            /// 0x00: 无响应
            /// 0x01: 显示器上警告
            /// 0x02: 声音警告
            /// 0x04: 上传中心
            /// 0x08: 触发报警输出（继电器输出）
            /// 0x10: 触发JPRG抓图并上传Email
            /// 0x20: 无线声光报警器联动
            /// 0x40: 联动电子地图(目前只有PCNVR支持)
            /// 0x200: 抓图并上传FTP
            /// </summary>
            public byte byEnable;
            public byte byRes;
            /// <summary>
            /// 持续时间(单位/s)
            /// </summary>
            public ushort wDuration;
            /// <summary>
            /// 触发输出通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ITC_EXCEPTIONOUT, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmOutTriggered;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITC_EXCEPTION
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_EXCEPTIONNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_ITC_HANDLEEXCEPTION[] struSnapExceptionType;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TRIGCOORDINATE
        {
            /// <summary>
            /// 线圈左上角横坐标（2个字节）
            /// </summary>
            public ushort wTopLeftX;
            /// <summary>
            /// 线圈左上角纵坐标（2个字节）
            /// </summary>
            public ushort wTopLeftY;
            /// <summary>
            /// 线圈宽度（2个字节）
            /// </summary>
            public ushort wWdith;
            /// <summary>
            /// 线圈高度（2个字节）
            /// </summary>
            public ushort wHeight;
        }

        public enum PROVINCE_CITY_IDX
        {
            /// <summary>
            /// 安徽
            /// </summary>
            ANHUI_PROVINCE = 0,
            /// <summary>
            /// 澳门（中国）
            /// </summary>
            AOMEN_CHINA_PROVINCE = 1,
            /// <summary>
            /// 北京
            /// </summary>
            BEIJING_PROVINCE = 2,
            /// <summary>
            /// 重庆
            /// </summary>
            CHONGQING_PROVINCE = 3,
            /// <summary>
            /// 福建
            /// </summary>
            FUJIAN_PROVINCE = 4,
            /// <summary>
            /// 甘肃
            /// </summary>
            GANSU_PROVINCE = 5,
            /// <summary>
            /// 广东
            /// </summary>
            GUANGDONG_PROVINCE = 6,
            /// <summary>
            /// 广西
            /// </summary>
            GUANGXI_PROVINCE = 7,
            /// <summary>
            /// 贵州
            /// </summary>
            GUIZHOU_PROVINCE = 8,
            /// <summary>
            /// 海南
            /// </summary>
            HAINAN_PROVINCE = 9,
            /// <summary>
            /// 河北
            /// </summary>
            HEBEI_PROVINCE = 10,
            /// <summary>
            /// 河南
            /// </summary>
            HENAN_PROVINCE = 11,
            /// <summary>
            /// 黑龙江
            /// </summary>
            HEILONGJIANG_PROVINCE = 12,
            /// <summary>
            /// 湖北
            /// </summary>
            HUBEI_PROVINCE = 13,
            /// <summary>
            /// 湖南
            /// </summary>
            HUNAN_PROVINCE = 14,
            /// <summary>
            /// 吉林
            /// </summary>
            JILIN_PROVINCE = 15,
            /// <summary>
            /// 江苏
            /// </summary>
            JIANGSU_PROVINCE = 16,
            /// <summary>
            /// 江西
            /// </summary>
            JIANGXI_PROVINCE = 17,
            /// <summary>
            /// 辽宁
            /// </summary>
            LIAONING_PROVINCE = 18,
            /// <summary>
            /// 内蒙古
            /// </summary>
            NEIMENGGU_PROVINCE = 19,
            /// <summary>
            /// 宁夏
            /// </summary>
            NINGXIA_PROVINCE = 20,
            /// <summary>
            /// 青海
            /// </summary>
            QINGHAI_PROVINCE = 21,
            /// <summary>
            /// 山东
            /// </summary>
            SHANDONG_PROVINCE = 22,
            /// <summary>
            /// 山西
            /// </summary>
            SHANXI_JIN_PROVINCE = 23,
            /// <summary>
            /// 陕西
            /// </summary>
            SHANXI_SHAN_PROVINCE = 24,
            /// <summary>
            /// 上海
            /// </summary>
            SHANGHAI_PROVINCE = 25,
            /// <summary>
            /// 四川
            /// </summary>
            SICHUAN_PROVINCE = 26,
            /// <summary>
            /// 台湾（中国）
            /// </summary>
            TAIWAN_CHINA_PROVINCE = 27,
            /// <summary>
            /// 天津
            /// </summary>
            TIANJIN_PROVINCE = 28,
            /// <summary>
            /// 西藏
            /// </summary>
            XIZANG_PROVINCE = 29,
            /// <summary>
            /// 香港（中国）
            /// </summary>
            XIANGGANG_CHINA_PROVINCE = 30,
            /// <summary>
            /// 新疆
            /// </summary>
            XINJIANG_PROVINCE = 31,
            /// <summary>
            /// 云南
            /// </summary>
            YUNNAN_PROVINCE = 32,
            /// <summary>
            /// 浙江
            /// </summary>
            ZHEJIANG_PROVINCE = 33
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_GEOGLOCATION
        {
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.U4)]
            public int[] iRes;
            /// <summary>
            /// 城市，详见PROVINCE_CITY_IDX
            /// </summary>
            public uint dwCity;
        }

        /// <summary>
        /// 场景模式
        /// </summary>
        public enum SCENE_MODE
        {
            /// <summary>
            /// 未知场景模式
            /// </summary>
            UNKOWN_SCENE_MODE = 0,
            /// <summary>
            /// 高速场景模式
            /// </summary>
            HIGHWAY_SCENE_MODE = 1,
            /// <summary>
            /// 郊区场景模式(保留)
            /// </summary>
            SUBURBAN_SCENE_MODE = 2,
            /// <summary>
            /// 郊区场景模式(保留)
            /// </summary>
            URBAN_SCENE_MODE = 3,
            /// <summary>
            /// 隧道场景模式(保留)
            /// </summary>
            TUNNEL_SCENE_MODE = 4
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VTPARAM
        {
            public uint dwSize;
            /// <summary>
            /// 是否使能虚拟线圈，0-不使用，1-使用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 是否显示虚拟线圈，0-不显示，1-显示
            /// </summary>
            public byte byIsDisplay;
            /// <summary>
            /// 晚间触发线圈的偏向：0-向上，1-向下
            /// </summary>
            public byte byLoopPos;
            /// <summary>
            /// 抓拍增益
            /// </summary>
            public byte bySnapGain;
            /// <summary>
            /// 抓拍快门速度
            /// </summary>
            public uint dwSnapShutter;
            /// <summary>
            /// 保留
            /// </summary>
            public NET_DVR_TRIGCOORDINATE struTrigCoordinate;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_VL_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_TRIGCOORDINATE[] struRes;
            /// <summary>
            /// 视频触发的车道数1
            /// </summary>
            public byte byTotalLaneNum;
            /// <summary>
            /// 偏振镜类型，0：不加偏振镜；1：加施耐德偏振镜。
            /// </summary>
            public byte byPolarLenType;
            /// <summary>
            /// 白天辅助照明模式，0：无辅助照明；1：LED灯照明；2：闪光灯照明
            /// </summary>
            public byte byDayAuxLightMode;
            /// <summary>
            /// 用以计算路面亮度的车道(虚拟线圈)
            /// </summary>
            public byte byLoopToCalRoadBright;
            /// <summary>
            /// 路面亮度低阈值初始化值1
            /// </summary>
            public byte byRoadGrayLowTh;
            /// <summary>
            /// 路面亮度高阈值初始化值140
            /// </summary>
            public byte byRoadGrayHighTh;
            /// <summary>
            /// 晚间触发线圈位移30
            /// </summary>
            public ushort wLoopPosBias;
            /// <summary>
            /// 连续图像曝光时间的初始值2000
            /// </summary>
            public uint dwHfrShtterInitValue;
            /// <summary>
            /// 抓拍图像曝光时间的初始值500
            /// </summary>
            public uint dwSnapShtterInitValue;
            /// <summary>
            /// 连续图像曝光时间的最大值20000
            /// </summary>
            public uint dwHfrShtterMaxValue;
            /// <summary>
            /// 抓拍图像曝光时间的最大值1500
            /// </summary>
            public uint dwSnapShtterMaxValue;
            /// <summary>
            /// 晚间连续图像曝光时间的设置值3000
            /// </summary>
            public uint dwHfrShtterNightValue;
            /// <summary>
            /// 晚间抓拍图像曝光时间的最小值3000
            /// </summary>
            public uint dwSnapShtterNightMinValue;
            /// <summary>
            /// 晚间抓拍图像曝光时间的最大值5000
            /// </summary>
            public uint dwSnapShtterNightMaxValue;
            /// <summary>
            /// 增益的初始值200
            /// </summary>
            public uint dwInitAfe;
            /// <summary>
            /// 增益的最大值400
            /// </summary>
            public uint dwMaxAfe;
            /// <summary>
            /// 设备当前分辨率宽
            /// </summary>
            public ushort wResolutionX;
            /// <summary>
            /// 设备当前分辨率高
            /// </summary>
            public ushort wResolutionY;
            /// <summary>
            /// 晚间增益，默认值70
            /// </summary>
            public uint dwGainNightValue;
            /// <summary>
            /// 场景模式， 详见SCENE_MODE
            /// </summary>
            public uint dwSceneMode;
            /// <summary>
            /// 录像标志：0-不录像，1-录像
            /// </summary>
            public uint dwRecordMode;
            /// <summary>
            /// 地址位置
            /// </summary>
            public NET_DVR_GEOGLOCATION struGeogLocation;
            /// <summary>
            /// 触发标志，0-车头触发；1-车尾触发；2-车头/车尾都触发
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_VL_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byTrigFlag;
            /// <summary>
            /// 触发灵敏度，1-100
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_VL_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byTrigSensitive;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 62, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SNAPENABLECFG
        {
            public uint dwSize;
            /// <summary>
            /// 是否支持车牌识别，0-不支持，1-支持
            /// </summary>
            public byte byPlateEnable;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 图像是否翻转 0-不翻转，1-翻转
            /// </summary>
            public byte byFrameFlip;
            /// <summary>
            /// 图像翻转角度 0,90,180,270
            /// </summary>
            public ushort wFlipAngle;
            /// <summary>
            /// 相位，取值范围[0, 360]
            /// </summary>
            public ushort wLightPhase;
            /// <summary>
            /// 是否信号灯电源同步，0-不同步；1-同步
            /// </summary>
            public byte byLightSyncPower;
            /// <summary>
            /// 信号频率
            /// </summary>
            public byte byFrequency;
            /// <summary>
            /// 是否自动上传SD图片，0-否；1-是
            /// </summary>
            public byte byUploadSDEnable;
            /// <summary>
            /// 识别模式参数:0-视频触发,1-外部触发
            /// </summary>
            public byte byPlateMode;
            /// <summary>
            /// 是否上传抓拍附加信息到FTP，0-否，1-是
            /// </summary>
            public byte byUploadInfoFTP;
            /// <summary>
            /// 是否自动格式化SD卡，0-否，1-是
            /// </summary>
            public byte byAutoFormatSD;
            /// <summary>
            /// Jpeg图片大小[64-8196]
            /// </summary>
            public ushort wJpegPicSize;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 56, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// ftp上传参数
        /// </summary>
        /*ftp上传参数*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FTPCFG
        {
            public uint dwSize;
            /// <summary>
            /// 是否启动ftp上传功能
            /// </summary>
            public uint dwEnableFTP;
            /// <summary>
            /// ftp 服务器
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string sFTPIP;
            /// <summary>
            /// ftp端口
            /// </summary>
            public uint dwFTPPort;
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 0 = 不使用目录结构，直接保存在根目录,1 = 使用1级目录,2=使用2级目录
            /// </summary>
            public uint dwDirLevel;
            /// <summary>
            /// 一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址，0x4=使用显示点,0x5=使用时间(年月),0x=6自定义,0x7=违规类型,0x8=方向,0x9=地点
            /// </summary>
            public ushort wTopDirMode;
            /// <summary>
            /// 二级目录，0x1 = 使用通道名,0x2 = 使用通道号，,0x3=使用时间(年月日),0x4=使用车道号,0x=5自定义,0x6=违规类型,0x7=方向,0x8=地点
            /// </summary>
            public ushort wSubDirMode;
            /// <summary>
            /// 启用匿名，0-否，1-是
            /// </summary>
            public byte byEnableAnony;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 23, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 可用来命名图片的相关元素
        /// </summary>
        public const int PICNAME_ITEM_DEV_NAME = 1;
        /// <summary>
        /// 设备号
        /// </summary>
        public const int PICNAME_ITEM_DEV_NO = 2;
        /// <summary>
        /// 设备IP
        /// </summary>
        public const int PICNAME_ITEM_DEV_IP = 3;
        /// <summary>
        /// 通道名
        /// </summary>
        public const int PICNAME_ITEM_CHAN_NAME = 4;
        /// <summary>
        /// 通道号
        /// </summary>
        public const int PICNAME_ITEM_CHAN_NO = 5;
        /// <summary>
        /// 时间
        /// </summary>
        public const int PICNAME_ITEM_TIME = 6;
        /// <summary>
        /// 卡号
        /// </summary>
        public const int PICNAME_ITEM_CARDNO = 7;
        /// <summary>
        /// 车牌号码
        /// </summary>
        public const int PICNAME_ITEM_PLATE_NO = 8;
        /// <summary>
        /// 车牌颜色
        /// </summary>
        public const int PICNAME_ITEM_PLATE_COLOR = 9;
        /// <summary>
        /// 车道号
        /// </summary>
        public const int PICNAME_ITEM_CAR_CHAN = 10;
        /// <summary>
        /// 车辆速度
        /// </summary>
        public const int PICNAME_ITEM_CAR_SPEED = 11;
        /// <summary>
        /// 显示点
        /// </summary>
        public const int PICNAME_ITEM_CARCHAN = 12;
        /// <summary>
        /// 图片序号
        /// </summary>
        public const int PICNAME_ITEM_PIC_NUMBER = 13;
        /// <summary>
        /// 车辆序号
        /// </summary>
        public const int PICNAME_ITEM_CAR_NUMBER = 14;
        /// <summary>
        /// 限速值
        /// </summary>
        public const int PICNAME_ITEM_SPEED_LIMIT_VALUES = 15;
        /// <summary>
        /// 国标违法代码
        /// </summary>
        public const int PICNAME_ITEM_ILLEGAL_CODE = 16;
        /// <summary>
        /// 路口编号
        /// </summary>
        public const int PICNAME_ITEM_CROSS_NUMBER = 17;
        /// <summary>
        /// 方向编号
        /// </summary>
        public const int PICNAME_ITEM_DIRECTION_NUMBER = 18;
        public const int PICNAME_MAXITEM = 15;

        /// <summary>
        /// 图片命名
        /// </summary>
        //图片命名
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PICTURE_NAME
        {
            /// <summary>
            /// 桉数组定义文件命名的规则
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PICNAME_MAXITEM, ArraySubType = UnmanagedType.I1)]
            public byte[] byItemOrder;
            /// <summary>
            /// 分隔符，一般为'_'
            /// </summary>
            public byte byDelimiter;
        }
        /// <summary>
        /// 命名规则：2013-09-27
        /// </summary>
        public const int PICNAME_ITEM_PARK_DEV_IP = 1;
        /// <summary>
        /// 车牌号码
        /// </summary>
        public const int PICNAME_ITEM_PARK_PLATE_NO = 2;
        /// <summary>
        /// 时间
        /// </summary>
        public const int PICNAME_ITEM_PARK_TIME = 3;
        /// <summary>
        /// 车位编号
        /// </summary>
        public const int PICNAME_ITEM_PARK_INDEX = 4;
        /// <summary>
        /// 车位状态
        /// </summary>
        public const int PICNAME_ITEM_PARK_STATUS = 5;

        /// <summary>
        /// 图片命名扩展 2013-09-27
        /// </summary>
        //图片命名扩展 2013-09-27
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PICTURE_NAME_EX
        {
            /// <summary>
            /// 桉数组定义文件命名的规则
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PICNAME_MAXITEM, ArraySubType = UnmanagedType.I1)]
            public byte[] byItemOrder;
            /// <summary>
            /// 分隔符，一般为'_'
            /// </summary>
            public byte byDelimiter;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 串口抓图设置
        /// </summary>
        /* 串口抓图设置*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SERIAL_CATCHPIC_PARA
        {
            /// <summary>
            /// 串口数据开始符
            /// </summary>
            public byte byStrFlag;
            /// <summary>
            /// 结束符
            /// </summary>
            public byte byEndFlag;
            /// <summary>
            /// 卡号相对起始位
            /// </summary>
            public ushort wCardIdx;
            /// <summary>
            /// 卡号长度
            /// </summary>
            public uint dwCardLen;
            /// <summary>
            /// 所触发的通道号，按位，从第1位开始计，即0x2表示第一通道
            /// </summary>
            public uint dwTriggerPicChans;
        }

        /// <summary>
        /// DVR抓图参数配置（基线）
        /// </summary>
        //DVR抓图参数配置（基线）
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_JPEGCFG_V30
        {
            public uint dwSize;
            /// <summary>
            /// 每个通道的图像参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_JPEGPARA[] struJpegPara;
            /// <summary>
            /// 抓图方式,按位设置.0x1=报警输入触发，0x2=移动侦测触发 0x4=232触发，0x8=485触发，0x10=网络触发
            /// </summary>
            public ushort wBurstMode;
            /// <summary>
            /// 图片上传间隔(秒)[0,65535]
            /// </summary>
            public ushort wUploadInterval;
            /// <summary>
            /// 图片命名规则
            /// </summary>
            public NET_DVR_PICTURE_NAME struPicNameRule;
            /// <summary>
            /// 是否保存到硬盘
            /// </summary>
            public byte bySaveToHD;
            public byte byRes1;
            /// <summary>
            /// 抓图间隔(毫秒)[0,65535]
            /// </summary>
            public ushort wCatchInterval;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            public NET_DVR_SERIAL_CATCHPIC_PARA struRs232Cfg;
            public NET_DVR_SERIAL_CATCHPIC_PARA struRs485Cfg;
            /// <summary>
            /// 每个通道一次触发拍照次数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.U4)]
            public uint[] dwTriggerPicTimes;
            /// <summary>
            /// 报警触发抓拍通道,按位设置，从第1位开始
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMIN_V30, ArraySubType = UnmanagedType.U4)]
            public uint[] dwAlarmInPicChanTriggered;
        }

        /// <summary>
        /// 手动触发参数
        /// </summary>
        //手动触发参数
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_MANUALSNAP
        {
            public byte byOSDEnable;
            public byte byLaneNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 22, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 获取触发参数
        /// </summary>
        public const int NET_ITC_GET_TRIGGERCFG = 3003;
        /// <summary>
        /// 设置触发参数
        /// </summary>
        public const int NET_ITC_SET_TRIGGERCFG = 3004;
        /// <summary>
        /// 获取设备当前触发模式
        /// </summary>
        public const int NET_DVR_GET_CURTRIGGERMODE = 3130;
        /// <summary>
        /// 获取视频电警触发参数
        /// </summary>
        public const int NET_ITC_GET_VIDEO_TRIGGERCFG = 3017;
        /// <summary>
        /// 设置视频电警触发参数
        /// </summary>
        public const int NET_ITC_SET_VIDEO_TRIGGERCFG = 3018;
        public const int MAX_ITC_LANE_NUM = 6;
        public const int MAX_IOOUT_NUM = 4;
        public const int MAX_LANEAREA_NUM = 2;
        public const int MAX_IOIN_NUMEX = 10;

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_SERIAL_INFO
        {
            public byte bySerialProtocol;
            public byte byIntervalType;
            public ushort wInterval;
            public byte byNormalPassProtocol;
            public byte byInverseProtocol;
            public byte bySpeedProtocol;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 9, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_EPOLICE_LANE_PARAM
        {
            public byte byEnable;
            public byte byRelatedDriveWay;
            public ushort wDistance;
            public byte byRecordEnable;
            public byte byRecordType;
            public byte byPreRecordTime;
            public byte byRecordDelayTime;
            public byte byRecordTimeOut;
            public byte bySignSpeed;
            public byte bySpeedLimit;
            public byte byOverlayDriveWay;
            public NET_ITC_SERIAL_INFO struSerialInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IOOUT_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelatedIOOut;
            public byte byFlashMode;
            public byte bySerialType;
            public byte byRelatedIOOutEx;
            public byte bySnapPicPreRecord;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LANEAREA_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_ITC_PLATE_RECOG_REGION_PARAM[] struPlateRecog;
            public byte byBigCarSignSpeed;
            public byte byBigCarSpeedLimit;
            public byte byRedTrafficLightChan;
            public byte byYellowTrafficLightChan;
            public byte byRelaLaneDirectionType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_EPOLICE_RS485_PARAM
        {
            public byte byRelatedLaneNum;
            public byte byTrafficLightSignalSrc;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public NET_ITC_PLATE_RECOG_PARAM struPlateRecog;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ITC_LANE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_ITC_EPOLICE_LANE_PARAM[] struLane;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_SINGLEIO_PARAM
        {
            public byte byDefaultStatus;
            public byte byRelatedDriveWay;
            public byte bySnapTimes;
            public byte byRelatedIOOutEx;
            public NET_ITC_INTERVAL_PARAM struInterval;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IOOUT_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelatedIOOut;
            public byte byFlashMode;
            public byte byEnable;
            public byte byUseageType;
            public byte byRes2;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LANEAREA_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_ITC_PLATE_RECOG_REGION_PARAM[] struPlateRecog;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_POST_SINGLEIO_PARAM
        {
            public NET_ITC_PLATE_RECOG_PARAM struPlateRecog;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IOIN_NUMEX, ArraySubType = UnmanagedType.Struct)]
            public NET_ITC_SINGLEIO_PARAM[] struSingleIO;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_CURTRIGGERMODE
        {
            public uint dwSize;
            public uint dwTriggerType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_PLATE_RECOG_PARAM
        {
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 3)]
            public string byDefaultCHN;
            public byte byEnable;
            public uint dwRecogMode;
            public byte byVehicleLogoRecog;
            public byte byProvince;
            public byte byRegion;
            public byte byRes1;
            public ushort wPlatePixelWidthMin;
            public ushort wPlatePixelWidthMax;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_INTERVAL_PARAM
        {
            public byte byIntervalType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_INTERVAL_NUM, ArraySubType = UnmanagedType.U2)]
            public ushort[] wInterval;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct UNION_REGION
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 164, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_PLATE_RECOG_REGION_PARAM
        {
            public byte byMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public UNION_REGION uRegion;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_LANE_PARAM
        {
            public byte byEnable;
            public byte byRelatedDriveWay;
            public ushort wDistance;
            public ushort wTrigDelayTime;
            public byte byTrigDelayDistance;
            public byte bySpeedCapEn;
            public byte bySignSpeed;
            public byte bySpeedLimit;
            public byte bySnapTimes;
            public byte byOverlayDriveWay;
            public NET_ITC_INTERVAL_PARAM struInterval;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IOOUT_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelatedIOOut;
            public byte byFlashMode;
            public byte byCartSignSpeed;
            public byte byCartSpeedLimit;
            public byte byRelatedIOOutEx;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LANEAREA_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_ITC_PLATE_RECOG_REGION_PARAM[] struPlateRecog;
            public byte byLaneType;
            public byte byUseageType;
            public byte byRelaLaneDirectionType;
            public byte byLowSpeedLimit;
            public byte byBigCarLowSpeedLimit;
            public byte byLowSpeedCapEn;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 10, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_RADAR_PARAM
        {
            public byte byRadarType;
            public byte byLevelAngle;
            public ushort wRadarSensitivity;
            public ushort wRadarSpeedValidTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public float fLineCorrectParam;
            public int iConstCorrectParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_POST_RS485_RADAR_PARAM
        {
            public byte byRelatedLaneNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public NET_ITC_PLATE_RECOG_PARAM struPlateRecog;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ITC_LANE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_ITC_LANE_PARAM[] struLane;
            public NET_ITC_RADAR_PARAM struRadar;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_TRIGGER_PARAM_UNION
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4280, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_SINGLE_TRIGGERCFG
        {
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public uint dwTriggerType;
            public NET_ITC_TRIGGER_PARAM_UNION uTriggerParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_TRIGGERCFG
        {
            public uint dwSize;
            public NET_ITC_SINGLE_TRIGGERCFG struTriggerParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_VIDEO_TRIGGER_COND
        {
            public uint dwSize;
            public uint dwChannel;
            public uint dwTriggerMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_VIDEO_TRIGGER_PARAM_UNION
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 1150, ArraySubType = UnmanagedType.U4)]
            public uint[] uLen;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_LIGHT_ACCESSPARAM_UNION
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 122, ArraySubType = UnmanagedType.U4)]
            public uint[] uLen;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_TRAFFIC_LIGHT_PARAM
        {
            /// <summary>
            /// 交通信号灯接入源，0-IO接入，1-RS485接入
            /// </summary>
            public byte bySource;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 信号灯接入参数
            /// </summary>
            public NET_ITC_LIGHT_ACCESSPARAM_UNION struLightAccess;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 车道属性参数结构
        /// </summary>
        //车道属性参数结构
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_LANE_LOGIC_PARAM
        {
            /// <summary>
            /// 车道用途类型，详见ITC_LANE_USEAGE_TYPE
            /// </summary>
            public byte byUseageType;
            /// <summary>
            /// 车道方向类型，详见ITC_LANE_DIRECTION_TYPE
            /// </summary>
            public byte byDirectionType;
            /// <summary>
            /// 车辆行驶方向，详见ITC_LANE_CAR_DRIVE_DIRECT
            /// </summary>
            public byte byCarDriveDirect;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 33, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 违规检测参数结构
        /// </summary>
        //违规检测参数结构
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_VIOLATION_DETECT_PARAM
        {
            /// <summary>
            /// 违规检测类型, 按位表示, 详见ITC_VIOLATION_DETECT_TYPE ,0-不启用,1-启用
            /// </summary>
            public uint dwVioDetectType;
            /// <summary>
            /// 压车道线抓拍张数,2-3
            /// </summary>
            public byte byDriveLineSnapTimes;
            /// <summary>
            /// 逆行抓拍,2-3
            /// </summary>
            public byte byReverseSnapTimes;
            /// <summary>
            /// 机占非停留时间（该时间后抓拍），单位s
            /// </summary>
            public ushort wStayTime;
            /// <summary>
            /// 机占非抓拍张数2-3
            /// </summary>
            public byte byNonDriveSnapTimes;
            /// <summary>
            /// 违法变道抓拍张数 2-3
            /// </summary>
            public byte byChangeLaneTimes;
            /// <summary>
            /// 违法禁令抓拍张数2-3
            /// </summary>
            public byte bybanTimes;
            /// <summary>
            /// 压线灵敏度(0~100)(3.7Ver)
            /// </summary>
            public byte byDriveLineSnapSen;
            /// <summary>
            /// 第2,3张抓拍位置最小偏移(违反信号灯时起效)（单位：像素） 命名需改进
            /// </summary>
            public ushort wSnapPosFixPixel;
            /// <summary>
            /// 违法超速抓拍张数2-3(3.8Ver)
            /// </summary>
            public byte bySpeedTimes;
            /// <summary>
            /// 违章掉头使能 0~关闭 1~开启
            /// </summary>
            public byte byTurnAroundEnable;
            /// <summary>
            /// 第三张牌识时间 0~180s
            /// </summary>
            public byte byThirdPlateRecogTime;
            /// <summary>
            /// 卡口抓拍张数,1-2张
            /// </summary>
            public byte byPostSnapTimes;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 18, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 电警第2张违规图片与停止线的最短距离，[0,300]单位(像素)
            /// </summary>
            public ushort wStopLineDis;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 14, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_VIDEO_TRIGGER_PARAM
        {
            public uint dwSize;
            public uint dwMode;
            public NET_ITC_VIDEO_TRIGGER_PARAM_UNION uVideoTrigger;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_LAMP_EXTERNAL_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 外控使能 0～不启用 1～启用
            /// </summary>
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 指示灯外控
            /// </summary>
            public NET_DVR_LAMP_STATE struLampStateCtrl;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 指示灯外控
        /// </summary>
        //指示灯外控
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_LAMP_STATE
        {
            /// <summary>
            /// 0~不闪烁 1 ～闪烁
            /// </summary>
            public byte byFlicker;
            /// <summary>
            /// 车位号1～3
            /// </summary>
            public byte byParkingIndex;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 1~IO1;2~IO2;4~IO3;
            /// </summary>
            public uint dwIONo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        public const int MAX_LED_INFO_LEN = 512;
        public const int MAX_VOICE_INFO_LEN = 128;
        public const int NET_DVR_GET_LEDDISPLAY_CFG = 3673;
        public const int NET_DVR_SET_LEDDISPLAY_CFG = 3672;
        public const int NET_DVR_SET_VOICEBROADCAST_CFG = 3675;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LEDDISPLAY_CFG
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LED_INFO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sDisplayInfo;
            public byte byDisplayMode;
            public byte bySpeedType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public uint dwShowTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VOICEBROADCAST_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 语音播报内容
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_VOICE_INFO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sInfo;
            /// <summary>
            /// 语音播报次数， 1~10次
            /// </summary>
            public byte byBroadcastNum;
            /// <summary>
            /// 语音播报间隔时间,1~5s
            /// </summary>
            public byte byIntervalTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 126, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_VIDEO_EPOLICE_PARAM
        {
            /// <summary>
            /// 是否启用，0-不启用，1-启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 识别的车道个数
            /// </summary>
            public byte byLaneNum;
            /// <summary>
            /// 闯红灯违规判断逻辑，设置值为：0-按方向，1-按车道
            /// </summary>
            public byte byLogicJudge;
            public byte byRes1;
            /// <summary>
            /// 牌识参数
            /// </summary>
            public NET_ITC_PLATE_RECOG_PARAM struPlateRecog;
            /// <summary>
            /// 交通信号灯参数
            /// </summary>
            public NET_ITC_TRAFFIC_LIGHT_PARAM struTrafficLight;
            /// <summary>
            /// 单车道参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ITC_LANE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_ITC_LANE_VIDEO_EPOLICE_PARAM[] struLaneParam;
            /// <summary>
            /// 车道边界线（最右边车道的边界线）
            /// </summary>
            public NET_ITC_LINE struLaneBoundaryLine;
            /// <summary>
            /// 左转弯分界线
            /// </summary>
            public NET_ITC_LINE struLeftLine;
            /// <summary>
            /// 右转弯分界线
            /// </summary>
            public NET_ITC_LINE struRightLine;
            /// <summary>
            /// 上部斑马线
            /// </summary>
            public NET_ITC_LINE struTopZebraLine;
            /// <summary>
            /// 下部斑马线
            /// </summary>
            public NET_ITC_LINE struBotZebraLine;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 视频电警线结构
        /// </summary>
        //视频电警线结构
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_LINE
        {
            /// <summary>
            /// 线参数
            /// </summary>
            public NET_VCA_LINE struLine;
            /// <summary>
            /// 线类型，详见ITC_LINE_TYPE
            /// </summary>
            public byte byLineType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 多边型结构体
        /// </summary>
        //多边型结构体
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_POLYGON
        {
            /// <summary>
            /// 有效点 大于等于3，若是3点在一条线上认为是无效区域，线交叉认为是无效区域
            /// </summary>
            public uint dwPointNum;
            /// <summary>
            /// 多边形边界点,最多20个
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_POINT[] struPos;
        }

        /// <summary>
        /// 违规检测线参数结构
        /// </summary>
        //违规检测线参数结构
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_VIOLATION_DETECT_LINE
        {
            /// <summary>
            /// 车道线参数
            /// </summary>
            public NET_ITC_LINE struLaneLine;
            /// <summary>
            /// 停止线参数
            /// </summary>
            public NET_ITC_LINE struStopLine;
            /// <summary>
            /// 闯红灯触发线参数
            /// </summary>
            public NET_ITC_LINE struRedLightLine;
            /// <summary>
            /// 直行触发位置取消线
            /// </summary>
            public NET_ITC_LINE struCancelLine;
            /// <summary>
            /// 待行区停止线参数
            /// </summary>
            public NET_ITC_LINE struWaitLine;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.Struct)]
            public NET_ITC_LINE[] struRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_ITC_LANE_VIDEO_EPOLICE_PARAM
        {
            /// <summary>
            /// 关联的车道号
            /// </summary>
            public byte byLaneNO;
            /// <summary>
            /// 线圈灵敏度，[1,100]
            /// </summary>
            public byte bySensitivity;
            /// <summary>
            /// 启用雷达测试0-不启用，1-启用
            /// </summary>
            public byte byEnableRadar;
            /// <summary>
            /// 关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
            /// 该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
            /// </summary>
            public byte byRelaLaneDirectionType;
            /// <summary>
            /// 车道参数
            /// </summary>
            public NET_ITC_LANE_LOGIC_PARAM struLane;
            /// <summary>
            /// 违规检测参数
            /// </summary>
            public NET_ITC_VIOLATION_DETECT_PARAM struVioDetect;
            /// <summary>
            /// 违规检测线
            /// </summary>
            public NET_ITC_VIOLATION_DETECT_LINE struLine;
            /// <summary>
            /// 牌识区域参数
            /// </summary>
            public NET_ITC_POLYGON struPlateRecog;
            /// <summary>
            /// 闯红灯周期录像标志，0-不录像，1-录像
            /// </summary>
            public byte byRecordEnable;
            /// <summary>
            /// 闯红灯录像类型，0-预录，1-延时录像
            /// </summary>
            public byte byRecordType;
            /// <summary>
            /// 闯红灯录像片段预录时间（默认0），单位：秒
            /// </summary>
            public byte byPreRecordTime;
            /// <summary>
            /// 闯红灯录像片段延时时间（默认0），单位：秒
            /// </summary>
            public byte byRecordDelayTime;
            /// <summary>
            /// 闯红灯周期录像超时时间（秒）
            /// </summary>
            public byte byRecordTimeOut;
            /// <summary>
            /// 车速限制值，单位km/h
            /// </summary>
            public byte byCarSpeedLimit;
            /// <summary>
            /// 标志限速，单位km/h
            /// </summary>
            public byte byCarSignSpeed;
            /// <summary>
            /// 抓拍图片预录时间点；0-默认值（第二张图片），1-第一张图片，2-第二张图片，3-第三张图片
            /// </summary>
            public byte bySnapPicPreRecord;
            /// <summary>
            /// 抓拍间隔参数（20byte）
            /// </summary>
            public NET_ITC_INTERVAL_PARAM struInterval;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 36, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SPRCFG
        {
            public uint dwSize;
            /// <summary>
            /// 设备运行省份的汉字简写
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHJC_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byDefaultCHN;
            /// <summary>
            /// 0:不发送车牌彩色图,1:发送车牌彩色图
            /// </summary>
            public byte byPlateOSD;
            /// <summary>
            /// 0-不传送近景JPEG图,1-传送近景JPEG图
            /// </summary>
            public byte bySendJPEG1;
            /// <summary>
            /// 0-不传送远景JPEG图,1-传送远景JPEG图
            /// </summary>
            public byte bySendJPEG2;
            /// <summary>
            /// 车牌设计宽度
            /// </summary>
            public ushort wDesignedPlateWidth;
            /// <summary>
            /// 识别的车道数
            /// </summary>
            public byte byTotalLaneNum;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// 识别的车道号，按位表示，bit0表示车道1是否识别，0-不识别，1-识别
            /// </summary>
            public ushort wRecognizedLane;
            /// <summary>
            /// 车道识别区域
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LANERECT_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_RECT[] struLaneRect;
            /// <summary>
            /// 识别的类型，
            /// bit0-背向识别：0-正向车牌识别，1-背向识别(尾牌识别) ；
            /// bit1-大车牌识别或小车牌识别：0-小车牌识别，1-大车牌识别 ；
            /// bit2-车身颜色识别：0-不采用车身颜色识别，在背向识别或小车牌识别时禁止启用，1-车身颜色识别；
            /// bit3-农用车识别：0-不采用农用车识别，1-农用车识别；
            /// bit4-模糊识别：0-不采用模糊识别，1-模糊识别；
            /// bit5-帧定位或场定位：0-帧定位，1-场定位；
            /// bit6-帧识别或场识别：0-帧识别，1-场识别；
            /// bit7-晚上或白天：0-白天，1-晚上
            /// </summary>
            public uint dwRecogMode;
            /// <summary>
            /// 是否发送原图：0-不发送，1-发送
            /// </summary>
            public byte bySendPRRaw;
            /// <summary>
            /// 是否发送车牌二值图：0-不发送，1-发送
            /// </summary>
            public byte bySendBinImage;
            /// <summary>
            /// 延时抓拍控制,单位：帧
            /// </summary>
            public byte byDelayCapture;
            /// <summary>
            /// 使用LED控制，0-否，1-是
            /// </summary>
            public byte byUseLED;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 68, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLCCFG
        {
            public uint dwSize;
            /// <summary>
            /// 是否启用车牌亮度补偿（默认启用）：0-关闭，1-启用
            /// </summary>
            public byte byPlcEnable;
            /// <summary>
            /// 车牌的预期亮度（默认值50）, 范围[0, 100]
            /// </summary>
            public byte byPlateExpectedBright;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 是否考虑闪光灯的影响: 0 - 否;  1 - 是(默认);
            /// </summary>
            public byte byTradeoffFlash;
            /// <summary>
            /// 使用闪光灯补光时, 如果考虑减弱闪光灯的亮度增强效应, 则需要设为1;否则为0
            /// </summary>
            public byte byCorrectFactor;
            /// <summary>
            /// 是否该线圈的亮度，按位表示，0-不统计，1-统计
            /// </summary>
            public ushort wLoopStatsEn;
            /// <summary>
            /// 车牌亮度补偿灵敏度(虚拟线圈模式起效)，取值范围1~100
            /// </summary>
            public byte byPlcBrightOffset;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 19, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEVICESTATECFG
        {
            public uint dwSize;
            /// <summary>
            /// 预览连接个数
            /// </summary>
            public ushort wPreviewNum;
            /// <summary>
            /// 布防连接个数
            /// </summary>
            public ushort wFortifyLinkNum;
            /// <summary>
            /// 预览的用户IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LINK, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPADDR[] struPreviewIP;
            /// <summary>
            /// 布防连接的用户IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_FORTIFY_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_IPADDR[] struFortifyIP;
            /// <summary>
            /// 帧率：0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20; 14-15; 15-18; 16-22;
            /// </summary>
            public uint dwVideoFrameRate;
            /// <summary>
            /// 分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
            /// </summary>
            public byte byResolution;
            /// <summary>
            /// 抓拍分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
            /// </summary>
            public byte bySnapResolution;
            /// <summary>
            /// 传输类型：0-主码流；1-子码流
            /// </summary>
            public byte byStreamType;
            /// <summary>
            /// 触发模式：0-视频触发；1-普通触发
            /// </summary>
            public byte byTriggerType;
            /// <summary>
            /// SD卡容量
            /// </summary>
            public uint dwSDVolume;
            /// <summary>
            /// SD卡剩余空间
            /// </summary>
            public uint dwSDFreeSpace;
            /// <summary>
            /// 车检器状态：0-未使用；1-正常；2-异常
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DRIVECHAN_NUM * MAX_COIL_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byDetectorState;
            /// <summary>
            /// 车检器连接状态：0-未连接；1-连接
            /// </summary>
            public byte byDetectorLinkState;
            /// <summary>
            /// SD卡状态 0－活动；1－休眠；2－异常，3-无sd卡
            /// </summary>
            public byte bySDStatus;
            /// <summary>
            /// 布防等级，0-无，1-一等级（高），2-二等级（中），3-三等级（低）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_FORTIFY_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byFortifyLevel;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 116, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_POSTEPOLICECFG
        {
            public uint dwSize;
            /// <summary>
            /// 线圈距离,单位cm，取值范围[0,20000]
            /// </summary>
            public uint dwDistance;
            /// <summary>
            /// 信号灯通道号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SIGNALLIGHT_NUM, ArraySubType = UnmanagedType.U4)]
            public uint[] dwLightChan;
            /// <summary>
            /// 标志限速，单位km/h，取值范围[0,255]
            /// </summary>
            public byte byCapSpeed;
            /// <summary>
            /// 限速值，单位km/h，取值范围[0,255]
            /// </summary>
            public byte bySpeedLimit;
            /// <summary>
            /// 车流方向，0-由东向西，1-由西向东，2-由南向北，3-由北向南
            /// </summary>
            public byte byTrafficDirection;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// 触发延迟距离 ，单位：分米
            /// </summary>
            public ushort wLoopPreDist;
            /// <summary>
            /// 触发硬延时时间 ，单位：毫秒
            /// </summary>
            public ushort wTrigDelay;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 124, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// *************************** end ********************************************
        /// </summary>
        public const int IPC_PROTOCOL_NUM = 50;

        /// <summary>
        /// 协议类型
        /// </summary>
        //协议类型
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PROTO_TYPE
        {
            /// <summary>
            /// ipc协议值
            /// </summary>
            public uint dwType;
            /// <summary>
            /// 协议描述字段
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = DESC_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDescribe;
        }

        /// <summary>
        /// 协议列表
        /// </summary>
        //协议列表
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPC_PROTO_LIST
        {
            public uint dwSize;
            /// <summary>
            /// 有效的ipc协议数目
            /// </summary>
            public uint dwProtoNum;
            /// <summary>
            /// 有效的ipc协议
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = IPC_PROTOCOL_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_PROTO_TYPE[] struProto;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 协议列表V41
        /// </summary>
        //协议列表V41
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPC_PROTO_LIST_V41
        {
            public uint dwSize;
            /// <summary>
            /// 有效的ipc协议数目
            /// </summary>
            public uint dwProtoNum;
            /// <summary>
            /// 协议列表缓冲区, dwProtoNum 个NET_DVR_PROTO_TYPE结构
            /// </summary>
            public IntPtr pBuffer;
            /// <summary>
            /// 缓冲区长度
            /// </summary>
            public uint dwBufferLen;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 最大警戒线条数
        /// </summary>
        public const int MAX_ALERTLINE_NUM = 8;

        /// <summary>
        /// 越界侦测查询条件
        /// </summary>
        //越界侦测查询条件
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TRAVERSE_PLANE_SEARCHCOND
        {
            /// <summary>
            /// 穿越境界面参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALERTLINE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_TRAVERSE_PLANE[] struVcaTraversePlane;
            /// <summary>
            /// 智能报警提前时间 单位:秒
            /// </summary>
            public uint dwPreTime;
            /// <summary>
            /// 智能报警延迟时间 单位:秒
            /// </summary>
            public uint dwDelayTime;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5656, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 最大区域数数
        /// </summary>
        public const int MAX_INTRUSIONREGION_NUM = 8;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INTRUSION_SEARCHCOND
        {
            /// <summary>
            /// 入侵区域
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_INTRUSIONREGION_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_INTRUSION[] struVcaIntrusion;
            /// <summary>
            /// 智能报警提前时间 单位:秒
            /// </summary>
            public uint dwPreTime;
            /// <summary>
            /// 智能报警延迟时间 单位:秒
            /// </summary>
            public uint dwDelayTime;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5400, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_DVR_AREA_SMARTSEARCH_COND_UNION
        {
            /// <summary>
            /// 结构体长度
            /// </summary>
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6144, ArraySubType = UnmanagedType.I1)]
            public byte[] byLen;
        }

        /// <summary>
        /// 智能搜索参数
        /// </summary>
        //智能搜索参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SMART_SEARCH_PARAM
        {
            /// <summary>
            /// 通道号
            /// </summary>
            public byte byChan;
            /// <summary>
            /// 智能查找联合体NET_DVR_AREA_SMARTSEARCH_COND_UNION的索引
            /// </summary>
            public byte bySearchCondType;
            /// <summary>
            /// 0-移动侦测区域 ，1-越界侦测， 2-区域入侵
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 录像开始的时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 录像停止的时间
            /// </summary>
            public NET_DVR_TIME struEndTime;
            /// <summary>
            /// 智能查找条件
            /// </summary>
            public NET_DVR_AREA_SMARTSEARCH_COND_UNION uSmartSearchCond;
            /// <summary>
            /// 移动侦测搜索灵敏度,1	>80%  2 40%~80%  3 1%~40%
            /// </summary>
            public byte bySensitivity;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SMART_SEARCH_RET
        {
            /// <summary>
            /// 移动侦测报警开始的时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 事件停止的时间
            /// </summary>
            public NET_DVR_TIME struEndTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// IPSAN 文件目录查找
        /// </summary>
        //IPSAN 文件目录查找
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPSAN_SERACH_PARAM
        {
            /// <summary>
            /// IPSAN IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// IPSAN  端口
            /// </summary>
            public ushort wPort;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 10, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPSAN_SERACH_RET
        {
            /// <summary>
            /// 返回的文件目录
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byDirectory;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// DVR设备参数
        /// </summary>
        //DVR设备参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEVICECFG_V40
        {
            public uint dwSize;
            /// <summary>
            /// DVR名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sDVRName;
            /// <summary>
            /// DVR ID,用于遥控器 //V1.4(0-99), V1.5(0-255)
            /// </summary>
            public uint dwDVRID;
            /// <summary>
            /// 是否循环录像,0:不是; 1:是
            /// </summary>
            public uint dwRecycleRecord;
            /// <summary>
            /// 以下不可更改
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SERIALNO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sSerialNumber;
            /// <summary>
            /// 软件版本号,高16位是主版本,低16位是次版本
            /// </summary>
            public uint dwSoftwareVersion;
            /// <summary>
            /// 软件生成日期,0xYYYYMMDD
            /// </summary>
            public uint dwSoftwareBuildDate;
            /// <summary>
            /// DSP软件版本,高16位是主版本,低16位是次版本
            /// </summary>
            public uint dwDSPSoftwareVersion;
            /// <summary>
            /// DSP软件生成日期,0xYYYYMMDD
            /// </summary>
            public uint dwDSPSoftwareBuildDate;
            /// <summary>
            /// 前面板版本,高16位是主版本,低16位是次版本
            /// </summary>
            public uint dwPanelVersion;
            /// <summary>
            /// 硬件版本,高16位是主版本,低16位是次版本
            /// </summary>
            public uint dwHardwareVersion;
            /// <summary>
            /// DVR报警输入个数
            /// </summary>
            public byte byAlarmInPortNum;
            /// <summary>
            /// DVR报警输出个数
            /// </summary>
            public byte byAlarmOutPortNum;
            /// <summary>
            /// DVR 232串口个数
            /// </summary>
            public byte byRS232Num;
            /// <summary>
            /// DVR 485串口个数
            /// </summary>
            public byte byRS485Num;
            /// <summary>
            /// 网络口个数
            /// </summary>
            public byte byNetworkPortNum;
            /// <summary>
            /// DVR 硬盘控制器个数
            /// </summary>
            public byte byDiskCtrlNum;
            /// <summary>
            /// DVR 硬盘个数
            /// </summary>
            public byte byDiskNum;
            /// <summary>
            /// DVR类型, 1:DVR 2:ATM DVR 3:DVS ......
            /// </summary>
            public byte byDVRType;
            /// <summary>
            /// DVR 通道个数
            /// </summary>
            public byte byChanNum;
            /// <summary>
            /// 起始通道号,例如DVS-1,DVR - 1
            /// </summary>
            public byte byStartChan;
            /// <summary>
            /// DVR 解码路数
            /// </summary>
            public byte byDecordChans;
            /// <summary>
            /// VGA口的个数
            /// </summary>
            public byte byVGANum;
            /// <summary>
            /// USB口的个数
            /// </summary>
            public byte byUSBNum;
            /// <summary>
            /// 辅口的个数
            /// </summary>
            public byte byAuxoutNum;
            /// <summary>
            /// 语音口的个数
            /// </summary>
            public byte byAudioNum;
            /// <summary>
            /// 最大数字通道数 低8位，高8位见byHighIPChanNum
            /// </summary>
            public byte byIPChanNum;
            /// <summary>
            /// 零通道编码个数
            /// </summary>
            public byte byZeroChanNum;
            /// <summary>
            /// 能力，位与结果为0表示不支持，1表示支持，
            /// </summary>
            public byte bySupport;
            /// <summary>
            /// bySupport & 0x1, 表示是否支持智能搜索
            /// bySupport & 0x2, 表示是否支持备份
            /// bySupport & 0x4, 表示是否支持压缩参数能力获取
            /// bySupport & 0x8, 表示是否支持多网卡
            /// bySupport & 0x10, 表示支持远程SADP
            /// bySupport & 0x20, 表示支持Raid卡功能
            /// bySupport & 0x40, 表示支持IPSAN搜索
            /// bySupport & 0x80, 表示支持rtp over rtsp
            /// </summary>
            public byte byEsataUseage;
            /// <summary>
            /// 0-关闭即插即用，1-打开即插即用
            /// </summary>
            public byte byIPCPlug;
            /// <summary>
            /// 0-盘组模式,1-磁盘配额, 2抽帧模式
            /// </summary>
            public byte byStorageMode;
            /// <summary>
            /// 能力，位与结果为0表示不支持，1表示支持
            /// </summary>
            public byte bySupport1;
            /// <summary>
            /// bySupport1 & 0x1, 表示是否支持snmp v30
            /// bySupport1 & 0x2, 支持区分回放和下载
            /// bySupport1 & 0x4, 是否支持布防优先级
            /// bySupport1 & 0x8, 智能设备是否支持布防时间段扩展
            /// bySupport1 & 0x10, 表示是否支持多磁盘数（超过33个）
            /// bySupport1 & 0x20, 表示是否支持rtsp over http
            /// </summary>
            public ushort wDevType;
            /// <summary>
            /// 设备型号名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = DEV_TYPE_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDevTypeName;
            /// <summary>
            /// 能力集扩展，位与结果为0表示不支持，1表示支持
            /// </summary>
            public byte bySupport2;
            /// <summary>
            /// bySupport2 & 0x1, 表示是否支持扩展的OSD字符叠加(终端和抓拍机扩展区分)
            /// </summary>
            public byte byAnalogAlarmInPortNum;
            /// <summary>
            /// 模拟报警输入起始号
            /// </summary>
            public byte byStartAlarmInNo;
            /// <summary>
            /// 模拟报警输出起始号
            /// </summary>
            public byte byStartAlarmOutNo;
            /// <summary>
            /// IP报警输入起始号  0-无效
            /// </summary>
            public byte byStartIPAlarmInNo;
            /// <summary>
            /// IP报警输出起始号 0-无效
            /// </summary>
            public byte byStartIPAlarmOutNo;
            /// <summary>
            /// 数字通道个数，高8位
            /// </summary>
            public byte byHighIPChanNum;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 9, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        public const int MAX_ZEROCHAN_NUM = 16;

        /// <summary>
        /// 零通道压缩配置参数
        /// </summary>
        //零通道压缩配置参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ZEROCHANCFG
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 0-停止零通道编码，1-表示启用零通道编码
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K
            /// * 12-320K 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K
            /// * 23-2048K
            /// * 最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)
            /// </summary>
            public uint dwVideoBitrate;
            /// <summary>
            /// 帧率 0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20,
            /// </summary>
            public uint dwVideoFrameRate;
            /// <summary>
            /// V2.0增加14-15, 15-18, 16-22;
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 零通道缩放参数
        /// </summary>
        //零通道缩放参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ZERO_ZOOMCFG
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 画面中的坐标点
            /// </summary>
            public NET_VCA_POINT struPoint;
            /// <summary>
            /// 现在的状态，0-缩小，1-放大
            /// </summary>
            public byte byState;
            /// <summary>
            /// 预览数目,0-1画面,1-4画面,2-9画面,3-16画面 该参数只读
            /// </summary>
            public byte byPreviewNumber;
            /// <summary>
            /// 画面通道信息 该参数只读
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOW_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byPreviewSeq;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        public const int DESC_LEN_64 = 64;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SNMPCFG
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 0-禁用SNMP，1-表示启用SNMP
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// snmp 版本  v1 = 1, v2 =2, v3 =3，设备目前不支持 v3
            /// </summary>
            public ushort wVersion;
            /// <summary>
            /// snmp消息接收端口，默认 161
            /// </summary>
            public ushort wServerPort;
            /// <summary>
            /// 读共同体，最多31,默认"public"
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byReadCommunity;
            /// <summary>
            /// 写共同体,最多31 字节,默认 "private"
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byWriteCommunity;
            /// <summary>
            /// 自陷主机ip地址描述，支持IPV4 IPV6和域名描述
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = DESC_LEN_64, ArraySubType = UnmanagedType.I1)]
            public byte[] byTrapHostIP;
            /// <summary>
            /// trap主机端口
            /// </summary>
            public ushort wTrapHostPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byTrapName;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 70, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SNMPv3_USER
        {
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byUserName;
            /// <summary>
            /// 安全级别 1-无校验 2-无授权校验 3-授权校验
            /// </summary>
            public byte bySecLevel;
            /// <summary>
            /// 认证类型 0-MD5认证 1-SHA认证 2: none
            /// </summary>
            public byte byAuthtype;
            /// <summary>
            /// 0: DES; 1: AES; 2: none;
            /// </summary>
            public byte byPrivtype;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 认证密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byAuthpass;
            /// <summary>
            /// 加密密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPrivpass;
        }

        /// <summary>
        /// snmpv30
        /// </summary>
        //snmpv30
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SNMPCFG_V30
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 0-禁用SNMP V1，1-表示启用SNMP V1
            /// </summary>
            public byte byEnableV1;
            /// <summary>
            /// 0-禁用SNMP V2，1-表示启用SNMP V2
            /// </summary>
            public byte byEnableV2;
            /// <summary>
            /// 0-禁用SNMP V3，1-表示启用SNMP V3
            /// </summary>
            public byte byEnableV3;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// snmp消息接收端口，默认 161
            /// </summary>
            public ushort wServerPort;
            /// <summary>
            /// 读共同体，最多31,默认"public"
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byReadCommunity;
            /// <summary>
            /// 写共同体,最多31 字节,默认 "private"
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byWriteCommunity;
            /// <summary>
            /// 自陷主机ip地址描述，支持IPV4 IPV6和域名描述
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = DESC_LEN_64, ArraySubType = UnmanagedType.I1)]
            public byte[] byTrapHostIP;
            /// <summary>
            /// trap主机端口
            /// </summary>
            public ushort wTrapHostPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 读写用户
            /// </summary>
            public NET_DVR_SNMPv3_USER struRWUser;
            /// <summary>
            /// 只读用户
            /// </summary>
            public NET_DVR_SNMPv3_USER struROUser;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byTrapName;
        }
        /// <summary>
        /// 正在处理
        /// </summary>
        public const int PROCESSING = 0;
        /// <summary>
        /// 过程完成
        /// </summary>
        public const int PROCESS_SUCCESS = 100;
        /// <summary>
        /// 过程异常
        /// </summary>
        public const int PROCESS_EXCEPTION = 400;
        /// <summary>
        /// 过程失败
        /// </summary>
        public const int PROCESS_FAILED = 500;
        /// <summary>
        /// 一键配置至少3块硬盘
        /// </summary>
        public const int PROCESS_QUICK_SETUP_PD_COUNT = 501;
        public const int SOFTWARE_VERSION_LEN = 48;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SADPINFO
        {
            /// <summary>
            /// 设备IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// 设备端口号
            /// </summary>
            public ushort wPort;
            /// <summary>
            /// 设备厂家类型
            /// </summary>
            public ushort wFactoryType;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = SOFTWARE_VERSION_LEN)]
            public string chSoftwareVersion;
            /// <summary>
            /// 序列号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 16)]
            public string chSerialNo;
            /// <summary>
            /// 编码通道个数
            /// </summary>
            public ushort wEncCnt;
            /// <summary>
            /// MAC 地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMACAddr;
            /// <summary>
            /// DVR IP地址掩码
            /// </summary>
            public NET_DVR_IPADDR struSubDVRIPMask;
            /// <summary>
            /// 网关
            /// </summary>
            public NET_DVR_IPADDR struGatewayIpAddr;
            /// <summary>
            /// 域名服务器1的IP地址
            /// </summary>
            public NET_DVR_IPADDR struDnsServer1IpAddr;
            /// <summary>
            /// 域名服务器2的IP地址
            /// </summary>
            public NET_DVR_IPADDR struDnsServer2IpAddr;
            public byte byDns;
            public byte byDhcp;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 158, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 搜索到设备最大数目
        /// </summary>
        public const int MAX_SADP_NUM = 256;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SADPINFO_LIST
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 搜索到设备数目
            /// </summary>
            public ushort wSadpNum;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 搜索
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SADP_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SADPINFO[] struSadpInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SADP_VERIFY
        {
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = PASSWD_LEN)]
            public string chPassword;
            public NET_DVR_IPADDR struOldIP;
            public ushort wOldPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 62, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VIDEO_CALL_COND
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VIDEO_CALL_PARAM
        {
            public uint dwSize;
            /// <summary>
            /// 信令类型  0-请求呼叫，1-取消本次呼叫，2-接听本次呼叫 3-拒绝本地来电呼叫 4-被叫响铃超时 5-结束本次通话，6-设备正在通话中，7-客户端正在通话中，8室内机不在线
            /// </summary>
            public uint dwCmdType;
            /// <summary>
            /// 期号, 范围[0,9]
            /// </summary>
            public ushort wPeriod;
            /// <summary>
            /// 楼号
            /// </summary>
            public ushort wBuildingNumber;
            /// <summary>
            /// 单元号
            /// </summary>
            public ushort wUnitNumber;
            /// <summary>
            /// 层号
            /// </summary>
            public ushort wFloorNumber;
            /// <summary>
            /// 房间号
            /// </summary>
            public ushort wRoomNumber;
            /// <summary>
            /// 设备编号
            /// </summary>
            public ushort wDevIndex;
            /// <summary>
            /// 设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机，7-8700客户端，8-4200客户端，9-APP
            /// </summary>
            public byte byUnitType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 115, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 开锁记录
        /// </summary>
        //开锁记录
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_UNLOCK_RECORD_INFO
        {
            /// <summary>
            /// 开锁方式，参考UNLOCK_TYPE_ENUM
            /// </summary>
            public byte byUnlockType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 操作发起源信息，刷卡开锁时为卡号，蓝牙开锁时为萤石的APP账号，二维码开锁时为访客的手机号，其余情况下为设备编号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byControlSrc;
            /// <summary>
            /// 图片数据长度
            /// </summary>
            public uint dwPicDataLen;
            /// <summary>
            /// 图片指针
            /// </summary>
            public IntPtr pImage;
            /// <summary>
            /// 持卡人ID
            /// </summary>
            public uint dwCardUserID;
            /// <summary>
            /// 刷卡开锁时有效，为楼层号
            /// </summary>
            public ushort nFloorNumber;
            /// <summary>
            /// 操作发起源附加信息，刷卡开锁时有效，为房间号，
            /// </summary>
            public ushort wRoomNumber;
            /// <summary>
            /// （对于门口机，0-表示本机控制器上接的锁、1-表示外接控制器上接的锁）
            /// </summary>
            public ushort wLockID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 刷卡开锁时有效，锁名称，对应门参数配置中门名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = LOCK_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byLockName;
            /// <summary>
            /// 工号（人员ID）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_SDK_EMPLOYEE_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byEmployeeNo;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 136, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 公告信息阅读回执
        /// </summary>
        //公告信息阅读回执
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_NOTICEDATA_RECEIPT_INFO
        {
            /// <summary>
            /// 公告编号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NOTICE_NUMBER_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byNoticeNumber;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 224, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 认证记录（设备未实现）
        /// </summary>
        //认证记录（设备未实现）
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AUTH_INFO
        {
            /// <summary>
            /// 认证结果：0-无效，1-认证成功，2-认证失败
            /// </summary>
            public byte byAuthResult;
            /// <summary>
            /// 认证方式：0-无效，1-指纹，2-人脸
            /// </summary>
            public byte byAuthType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 卡号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCardNo;
            /// <summary>
            /// 图片数据长度（当认证方式byAuthType为人脸时有效）
            /// </summary>
            public uint dwPicDataLen;
            /// <summary>
            /// 图片指针（当认证方式byAuthType为人脸时有效）
            /// </summary>
            public IntPtr pImage;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 212, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON
        {
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byLen;
        }

        /// <summary>
        /// 可视对讲事件记录
        /// </summary>
        public struct NET_DVR_VIDEO_INTERCOM_EVENT
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 时间
            /// </summary>
            public NET_DVR_TIME_EX struTime;
            /// <summary>
            /// 设备编号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DEV_NUMBER_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDevNumber;
            /// <summary>
            /// 事件信息类型，1-开锁记录，2-公告信息阅读回执，3-认证记录，4-车牌信息上传，5非法卡刷卡事件，6-门口机发卡记录(需要启动门口机发卡功能，刷卡时才会上传该事件)
            /// </summary>
            public byte byEventType;
            /// <summary>
            /// 图片数据传输方式: 0-二进制；1-url
            /// </summary>
            public byte byPicTransType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 事件信息，具体内容参考byEventType取值
            /// </summary>
            public NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON uEventInfo;
            /// <summary>
            /// IOT通道号
            /// </summary>
            public uint dwIOTChannelNo;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 252, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        public struct NET_DVR_CONTROL_GATEWAY
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 门禁序号，从1开始
            /// </summary>
            public uint dwGatewayIndex;
            /// <summary>
            /// 操作命令，0-关闭，1-打开，2-常开（通道状态），3-恢复（普通状态）
            /// </summary>
            public byte byCommand;
            /// <summary>
            /// 锁类型，0-普通（以前默认都为0）,1-智能锁
            /// </summary>
            public byte byLockType;
            /// <summary>
            /// 锁ID，从1开始（远程开门口机锁时，0表示门口机本机控制器上接的锁、1表示外接控制器上接的锁）
            /// </summary>
            public ushort wLockID;
            /// <summary>
            /// 操作发起源信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byControlSrc;
            /// <summary>
            /// 开锁类型，1-显示，2-通话
            /// </summary>
            public byte byControlType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
            /// <summary>
            /// 锁密码，当byLockType为智能锁时有效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPassword;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 108, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// XML透传接口
        /// </summary>
        //XML透传接口
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_XML_CONFIG_INPUT
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 请求信令，字符串格式
            /// </summary>
            public IntPtr lpRequestUrl;
            public uint dwRequestUrlLen;
            /// <summary>
            /// 输入参数缓冲区，XML格式
            /// </summary>
            public IntPtr lpInBuffer;
            public uint dwInBufferSize;
            /// <summary>
            /// 接收超时时间，单位：ms，填0则使用默认超时5s
            /// </summary>
            public uint dwRecvTimeOut;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_XML_CONFIG_OUTPUT
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 输出参数缓冲区，XML格式
            /// </summary>
            public IntPtr lpOutBuffer;
            public uint dwOutBufferSize;
            /// <summary>
            /// 实际输出的XML内容大小
            /// </summary>
            public uint dwReturnedXMLSize;
            /// <summary>
            /// 返回的状态参数(XML格式：ResponseStatus)，获取命令成功时不会赋值，如果不需要，可以置NULL
            /// </summary>
            public IntPtr lpStatusBuffer;
            /// <summary>
            /// 状态缓冲区大小(内存大小)
            /// </summary>
            public uint dwStatusSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CHANNEL_GROUP
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 组号，从0开始，即0表示第1组，1表示第2组，依次类推
            /// </summary>
            public uint dwGroup;
            /// <summary>
            /// 设备区域设置ID
            /// </summary>
            public byte byID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 场景位置索引号，IPC为0，IPD从1开始
            /// </summary>
            public uint dwPositionNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 56, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_TRAVERSE_PLANE_DETECTION
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 使能越界侦测功能：0- 否，1- 是
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 启用支持智能后检索：0- 不启用，1- 启用
            /// </summary>
            public byte byEnableDualVca;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 警戒线参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALERTLINE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_TRAVERSE_PLANE[] struAlertParam;
            /// <summary>
            /// 布防时间，每周7天，每天最多设置8个时间段
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmSched;
            /// <summary>
            /// 异常处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V40 struHandleException;
            public uint dwMaxRelRecordChanNum;
            public uint dwRelRecordChanNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.U4)]
            public uint[] byRelRecordChan;
            /// <summary>
            /// 假日布防时间，最多设置8个时间段
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struHolidayTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 100, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_STD_CONFIG
        {
            public IntPtr lpCondBuffer;
            public uint dwCondSize;
            public IntPtr lpInBuffer;
            public uint dwInSize;
            public IntPtr lpOutBuffer;
            public uint dwOutSize;
            public IntPtr lpStatusBuffer;
            public uint dwStatusSize;
            public IntPtr lpXmlBuffer;
            public uint dwXmlSize;
            public byte byDataType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 23, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_THERMOMETRY_COND
        {
            public uint dwSize;
            public uint dwChannel;
            public ushort wPresetNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 62, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_THERMOMETRY_TRIGGER_COND
        {
            public uint dwSize;
            public uint dwChan;
            public uint dwPreset;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_EVENT_TRIGGER
        {
            public uint dwSize;
            public NET_DVR_HANDLEEXCEPTION_V41 struHandleException;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRelRecordChan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_PRESETCHAN_INFO[] struPresetChanInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CRUISECHAN_INFO[] struCruiseChanInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_PTZTRACKCHAN_INFO[] struPtzTrackInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_THERMOMETRY_ALARMRULE
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = THERMOMETRY_ALARMRULE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_THERMOMETRY_ALARMRULE_PARAM[] struThermometryAlarmRuleParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_THERMOMETRY_ALARMRULE_PARAM
        {
            public byte byEnabled;
            public byte byRuleID;
            public byte byRule;
            public byte byRes;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = NAME_LEN)]
            public string szRuleName;
            public float fAlert;
            public float fAlarm;
            public float fThreshold;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_THERMOMETRY_ALARM
        {
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 规则ID
            /// </summary>
            public byte byRuleID;
            /// <summary>
            /// 测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
            /// </summary>
            public byte byThermometryUnit;
            /// <summary>
            /// 预置点号
            /// </summary>
            public ushort wPresetNo;
            /// <summary>
            /// ptz坐标信息
            /// </summary>
            public NET_PTZ_INFO struPtzInfo;
            /// <summary>
            /// 0-预警 1-报警
            /// </summary>
            public byte byAlarmLevel;
            /// <summary>
            /// 报警类型 0-最高温度 1-最低温度 2-平均温度 3-温差 4-温度突升 5-温度突降
            /// </summary>
            public byte byAlarmType;
            /// <summary>
            /// 0-大于，1-小于
            /// </summary>
            public byte byAlarmRule;
            /// <summary>
            /// 规则标定类型 0-点，1-框，2线
            /// </summary>
            public byte byRuleCalibType;
            /// <summary>
            /// 点测温坐标（当规则标定类型为点的时候生效）
            /// </summary>
            public NET_VCA_POINT struPoint;
            /// <summary>
            /// 区域（当规则标定类型为框的时候生效）
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            /// <summary>
            /// 配置规则温度,精确到小数点后一位(-40-1000),（浮点数+100）
            /// </summary>
            public float fRuleTemperature;
            /// <summary>
            /// 当前温度,精确到小数点后一位(-40-1000),（浮点数+100）
            /// </summary>
            public float fCurrTemperature;
            /// <summary>
            /// 可见光图片长度
            /// </summary>
            public uint dwPicLen;
            /// <summary>
            /// 热成像图片长度
            /// </summary>
            public uint dwThermalPicLen;
            /// <summary>
            /// 热成像附加信息长度
            /// </summary>
            public uint dwThermalInfoLen;
            public IntPtr pPicBuff;
            /// <summary>
            /// 可见光图片指针
            /// </summary>
            public IntPtr pThermalPicBuff;
            /// <summary>
            /// 热成像附加信息指针
            /// </summary>
            public IntPtr pThermalInfoBuff;
            /// <summary>
            /// 线、框测温最高温度位置坐标（当规则标定类型为线、框的时候生效）
            /// </summary>
            public NET_VCA_POINT struHighestPoint;
            /// <summary>
            /// 容差温度,精确到小数点后一位(-40-1000),（浮点数+100）
            /// </summary>
            public float fToleranceTemperature;
            /// <summary>
            /// 温度预警等待时间 单位秒 范围为0-200秒，默认为0秒
            /// </summary>
            public uint dwAlertFilteringTime;
            /// <summary>
            /// 温度报警等待时间 单位秒 范围为0-200秒，默认为0秒
            /// </summary>
            public uint dwAlarmFilteringTime;
            /// <summary>
            /// 温度突变记录周期，单位秒
            /// </summary>
            public uint dwTemperatureSuddenChangeCycle;
            /// <summary>
            /// 温度突变值,精确到小数点后一位(大于0)
            /// </summary>
            public float fTemperatureSuddenChangeValue;
            /// <summary>
            /// 图片数据传输方式: 0-二进制；1-url
            /// </summary>
            public byte byPicTransType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 可见光通道通道号
            /// </summary>
            public uint dwVisibleChannel;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// TMA测温配置规则温度,精确到小数点后一位(-40-1000),（浮点数+100）
            /// </summary>
            public float fAlarmRuleTemperature;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_SDK_MANUALTHERM_BASICPARAM
        {
            public uint dwSize;
            /// <summary>
            /// 距离(m)[0, 10000]
            /// </summary>
            public ushort wDistance;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 发射率(发射率 精确到小数点后两位)[0.01, 1.00](即：物体向外辐射能量的本领)
            /// </summary>
            public float fEmissivity;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_SDK_POINT_THERMOMETRY
        {
            /// <summary>
            /// 点测温当前温度, 当标定为0-点时生效。精确到小数点后一位(-40-1000),（浮点数+100）*10
            /// </summary>
            public float fPointTemperature;
            /// <summary>
            /// 点测温坐标（当规则标定类型为“点”的时候生效）
            /// </summary>
            public NET_VCA_POINT struPoint;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_SDK_REGION_THERMOMETRY
        {
            /// <summary>
            /// 最高温度,精确到小数点后一位(-40-1000),（浮点数+100）*10 */
            /// </summary>
            public float fMaxTemperature;
            /// <summary>
            /// 最低温度,精确到小数点后一位(-40-1000),（浮点数+100）*10 */
            /// </summary>
            public float fMinTemperature;
            /// <summary>
            /// 平均温度,精确到小数点后一位(-40-1000),（浮点数+100）*10 */
            /// </summary>
            public float fAverageTemperature;
            /// <summary>
            /// 温差,精确到小数点后一位(-40-1000),（浮点数+100）*10 */
            /// </summary>
            public float fTemperatureDiff;
            /// <summary>
            /// 区域、线（当规则标定类型为“框”或者“线”的时候生效）
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_SDK_MANUALTHERM_RULE
        {
            /// <summary>
            /// 规则ID 0-表示无效，从1开始 （list内部判断数据有效性）
            /// </summary>
            public byte byRuleID;
            /// <summary>
            /// 是否启用
            /// </summary>
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] szRuleName;
            /// <summary>
            /// 规则标定类型 0-点，1-框，2-线
            /// </summary>
            public byte byRuleCalibType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 点测温，当标定为0-点时生效
            /// </summary>
            public NET_SDK_POINT_THERMOMETRY struPointTherm;
            /// <summary>
            /// 区域测温，当标定为1-框、2-线时生效。
            /// </summary>
            public NET_SDK_REGION_THERMOMETRY struRegionTherm;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 512, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_SDK_MANUAL_THERMOMETRY
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 相对时标（只读）
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标（只读）
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
            /// </summary>
            public byte byThermometryUnit;
            /// <summary>
            /// 数据状态类型:0-检测中，1-开始，2-结束（只读）
            /// </summary>
            public byte byDataType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public NET_SDK_MANUALTHERM_RULE struRuleInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 512, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 实时温度检测条件结构
        /// </summary>
        //实时温度检测条件结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_REALTIME_THERMOMETRY_COND
        {
            public uint dwSize;
            /// <summary>
            /// 通道号，从1开始，0xffffffff代表获取全部通道
            /// </summary>
            public uint dwChan;
            /// <summary>
            /// 规则ID 0-代表获取全部规则，具体规则ID从1开始
            /// </summary>
            public byte byRuleID;
            /// <summary>
            /// 1-定时模式：设备每隔一秒上传各个规则测温数据的最高温、最低温和平均温度值、温差
            /// 2-温差模式：若上一秒与下一秒的最高温或者最低温或者平均温或者温差值的温差大于等于2摄氏度，则上传最高温、最低温和平均温度值。若大于等于一个小时温差值均小于2摄氏度，则上传最高温、最低温、平均温和温差值
            /// </summary>
            public byte byMode;
            /// <summary>
            /// 上传间隔，仅温差模式支持，1~3600S，填0则默认3600S上传一次
            /// </summary>
            public ushort wInterval;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 60, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_POINT_THERM_CFG
        {
            /// <summary>
            /// 当前温度
            /// </summary>
            public float fTemperature;
            /// <summary>
            /// 点测温坐标（当规则标定类型为点的时候生效）
            /// </summary>
            public NET_VCA_POINT struPoint;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 120, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LINEPOLYGON_THERM_CFG
        {
            /// <summary>
            /// 最高温
            /// </summary>
            public float fMaxTemperature;
            /// <summary>
            /// 最低温
            /// </summary>
            public float fMinTemperature;
            /// <summary>
            /// 平均温
            /// </summary>
            public float fAverageTemperature;
            /// <summary>
            /// 温差
            /// </summary>
            public float fTemperatureDiff;
            /// <summary>
            /// 区域（当规则标定类型为框/线的时候生效）
            /// </summary>
            public NET_VCA_POLYGON struRegion;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_THERMOMETRY_UPLOAD
        {
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 规则名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] szRuleName;
            /// <summary>
            /// 规则ID号
            /// </summary>
            public byte byRuleID;
            /// <summary>
            /// 规则标定类型 0-点，1-框，2-线
            /// </summary>
            public byte byRuleCalibType;
            /// <summary>
            /// 预置点号
            /// </summary>
            public ushort wPresetNo;
            public NET_DVR_POINT_THERM_CFG struPointThermCfg;
            public NET_DVR_LINEPOLYGON_THERM_CFG struLinePolygonThermCfg;
            /// <summary>
            /// 测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
            /// </summary>
            public byte byThermometryUnit;
            /// <summary>
            /// 数据状态类型:0-检测中，1-开始，2-结束
            /// </summary>
            public byte byDataType;
            public byte byRes1;
            /// <summary>
            /// bit0-中心点测温：0-不支持，1-支持；
            /// bit1-最高点测温：0-不支持，1-支持；
            /// bit2-最低点测温：0-不支持，1-支持；
            /// </summary>
            public byte bySpecialPointThermType;
            /// <summary>
            /// 中心点温度,精确到小数点后一位(-40-1500),（浮点数+100）*10 （由bySpecialPointThermType判断是否支持中心点）
            /// </summary>
            public float fCenterPointTemperature;
            /// <summary>
            /// 最高点温度,精确到小数点后一位(-40-1500),（浮点数+100）*10（由bySpecialPointThermType判断是否支持最高点）
            /// </summary>
            public float fHighestPointTemperature;
            /// <summary>
            /// 最低点温度,精确到小数点后一位(-40-1500),（浮点数+100）*10（由bySpecialPointThermType判断是否支持最低点）
            /// </summary>
            public float fLowestPointTemperature;
            /// <summary>
            /// 线、框测温最高温度位置坐标（当规则标定类型为线、框的时候生效）
            /// </summary>
            public NET_VCA_POINT struHighestPoint;
            /// <summary>
            /// 线、框测温最低温度位置坐标（当规则标定类型为线、框的时候生效）
            /// </summary>
            public NET_VCA_POINT struLowestPoint;
            /// <summary>
            /// 是否数据冻结 0-否 1-是
            /// </summary>
            public byte yIsFreezedata;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 通道号，查询条件中通道号为0xffffffff时该字段生效
            /// </summary>
            public uint dwChan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 88, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// *************************** end ********************************************
        /// *****************************备份结构 begin*******************************
        /// 获取备份设备信息接口定义
        /// </summary>
        public const int DESC_LEN_32 = 32;
        /// <summary>
        /// 节点个数
        /// </summary>
        public const int MAX_NODE_NUM = 256;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DESC_NODE
        {
            public int iValue;
            /// <summary>
            /// 描述字段
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = DESC_LEN_32, ArraySubType = UnmanagedType.I1)]
            public byte[] byDescribe;
            /// <summary>
            /// 获取磁盘列表专用,单位为M
            /// </summary>
            public uint dwFreeSpace;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISKABILITY_LIST
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 能力结点个数
            /// </summary>
            public uint dwNodeNum;
            /// <summary>
            /// 描述参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NODE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_DESC_NODE[] struDescNode;
        }
        /// <summary>
        /// 备份进度列表
        /// </summary>
        public const int BACKUP_SUCCESS = 100;
        /// <summary>
        /// 备份设备已满，更换设备继续备份
        /// </summary>
        public const int BACKUP_CHANGE_DEVICE = 101;
        /// <summary>
        /// 正在搜索备份设备
        /// </summary>
        public const int BACKUP_SEARCH_DEVICE = 300;
        /// <summary>
        /// 正在搜索录像文件
        /// </summary>
        public const int BACKUP_SEARCH_FILE = 301;
        /// <summary>
        /// 正在搜索日志文件
        /// </summary>
        public const int BACKUP_SEARCH_LOG_FILE = 302;
        /// <summary>
        /// 备份异常
        /// </summary>
        public const int BACKUP_EXCEPTION = 400;
        /// <summary>
        /// 备份失败
        /// </summary>
        public const int BACKUP_FAIL = 500;
        /// <summary>
        /// 时间段内无录像文件
        /// </summary>
        public const int BACKUP_TIME_SEG_NO_FILE = 501;
        /// <summary>
        /// 申请不到资源
        /// </summary>
        public const int BACKUP_NO_RESOURCE = 502;
        /// <summary>
        /// 备份设备容量不足
        /// </summary>
        public const int BACKUP_DEVICE_LOW_SPACE = 503;
        /// <summary>
        /// 刻录光盘封盘
        /// </summary>
        public const int BACKUP_DISK_FINALIZED = 504;
        /// <summary>
        /// 刻录光盘异常
        /// </summary>
        public const int BACKUP_DISK_EXCEPTION = 505;
        /// <summary>
        /// 备份设备不存在
        /// </summary>
        public const int BACKUP_DEVICE_NOT_EXIST = 506;
        /// <summary>
        /// 有其他备份操作在进行
        /// </summary>
        public const int BACKUP_OTHER_BACKUP_WORK = 507;
        /// <summary>
        /// 用户没有操作权限
        /// </summary>
        public const int BACKUP_USER_NO_RIGHT = 508;
        /// <summary>
        /// 操作失败
        /// </summary>
        public const int BACKUP_OPERATE_FAIL = 509;
        /// <summary>
        /// 硬盘中无日志
        /// </summary>
        public const int BACKUP_NO_LOG_FILE = 510;

        /// <summary>
        /// 备份过程接口定义
        /// </summary>
        //备份过程接口定义
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_BACKUP_NAME_PARAM
        {
            /// <summary>
            /// 文件个数
            /// </summary>
            public uint dwFileNum;
            /// <summary>
            /// 文件列表
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RECORD_FILE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_FINDDATA_V30[] struFileList;
            /// <summary>
            /// 备份磁盘描述
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = DESC_LEN_32, ArraySubType = UnmanagedType.I1)]
            public byte[] byDiskDes;
            /// <summary>
            /// 是否备份播放器
            /// </summary>
            public byte byWithPlayer;
            /// <summary>
            /// 是否继续备份 0不继续 1继续
            /// </summary>
            public byte byContinue;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 34, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_BACKUP_TIME_PARAM
        {
            /// <summary>
            /// 按时间备份的通道
            /// </summary>
            public int lChannel;
            /// <summary>
            /// 备份的起始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 备份的终止时间
            /// </summary>
            public NET_DVR_TIME struStopTime;
            /// <summary>
            /// 备份磁盘描述
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = DESC_LEN_32, ArraySubType = UnmanagedType.I1)]
            public byte[] byDiskDes;
            /// <summary>
            /// 是否备份播放器
            /// </summary>
            public byte byWithPlayer;
            /// <summary>
            /// 是否继续备份 0不继续 1继续
            /// </summary>
            public byte byContinue;
            /// <summary>
            /// 0 不抽帧  1 抽帧
            /// </summary>
            public byte byDrawFrame;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 33, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// ******************************* end ******************************************
        /// </summary>
        public enum COMPRESSION_ABILITY_TYPE
        {
            /// <summary>
            /// 码流压缩类型
            /// </summary>
            COMPRESSION_STREAM_ABILITY = 0,
            /// <summary>
            /// 主码流压缩分辨率
            /// </summary>
            MAIN_RESOLUTION_ABILITY = 1,
            /// <summary>
            /// 子码流压缩分辨率
            /// </summary>
            SUB_RESOLUTION_ABILITY = 2,
            /// <summary>
            /// 事件压缩参数分辨率
            /// </summary>
            EVENT_RESOLUTION_ABILITY = 3,
            /// <summary>
            /// 帧率能力
            /// </summary>
            FRAME_ABILITY = 4,
            /// <summary>
            /// 位率类型能力
            /// </summary>
            BITRATE_TYPE_ABILITY = 5,
            /// <summary>
            /// 位率上限
            /// </summary>
            BITRATE_ABILITY = 6,
            /// <summary>
            /// 三码流压缩分辨率
            /// </summary>
            THIRD_RESOLUTION_ABILITY = 7,
            /// <summary>
            /// 码流类型
            /// </summary>
            STREAM_TYPE_ABILITY = 8,
            /// <summary>
            /// 图像质量
            /// </summary>
            PIC_QUALITY_ABILITY = 9,
            /// <summary>
            /// BP帧间隔
            /// </summary>
            INTERVAL_BPFRAME_ABILITY = 10,
            /// <summary>
            /// 视频编码能力
            /// </summary>
            VIDEO_ENC_ABILITY = 11,
            /// <summary>
            /// 音频编码能力
            /// </summary>
            AUDIO_ENC_ABILITY = 12,
            /// <summary>
            /// 视频编码复杂度能力
            /// </summary>
            VIDEO_ENC_COMPLEXITY_ABILITY = 13,
            /// <summary>
            /// 封装格式能力
            /// </summary>
            FORMAT_ABILITY = 14
        }

        /// <summary>
        /// 能力列表
        /// </summary>
        //能力列表
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ABILITY_LIST
        {
            /// <summary>
            /// 能力类型 COMPRESSION_ABILITY_TYPE
            /// </summary>
            public uint dwAbilityType;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 能力结点个数
            /// </summary>
            public uint dwNodeNum;
            /// <summary>
            /// 描述参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NODE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_DESC_NODE[] struDescNode;
        }
        /// <summary>
        /// 最大能力项
        /// </summary>
        public const int MAX_ABILITYTYPE_NUM = 12;

        /// <summary>
        /// 压缩参数能力列表
        /// </summary>
        // 压缩参数能力列表
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_COMPRESSIONCFG_ABILITY
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 能力类型个数
            /// </summary>
            public uint dwAbilityNum;
            /// <summary>
            /// 描述参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ABILITYTYPE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ABILITY_LIST[] struAbilityNode;
        }

        /// <summary>
        /// 模式A
        /// </summary>
        //模式A 
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HOLIDATE_MODEA
        {
            /// <summary>
            /// 开始月 从1开始
            /// </summary>
            public byte byStartMonth;
            /// <summary>
            /// 开始日 从1开始
            /// </summary>
            public byte byStartDay;
            /// <summary>
            /// 结束月
            /// </summary>
            public byte byEndMonth;
            /// <summary>
            /// 结束日
            /// </summary>
            public byte byEndDay;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HOLIDATE_MODEB
        {
            /// <summary>
            /// 从1开始
            /// </summary>
            public byte byStartMonth;
            /// <summary>
            /// 第几个星期 从1开始
            /// </summary>
            public byte byStartWeekNum;
            /// <summary>
            /// 星期几
            /// </summary>
            public byte byStartWeekday;
            /// <summary>
            /// 从1开始
            /// </summary>
            public byte byEndMonth;
            /// <summary>
            /// 第几个星期 从1开始
            /// </summary>
            public byte byEndWeekNum;
            /// <summary>
            /// 星期几
            /// </summary>
            public byte byEndWeekday;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HOLIDATE_MODEC
        {
            /// <summary>
            /// 年
            /// </summary>
            public ushort wStartYear;
            /// <summary>
            /// 月
            /// </summary>
            public byte byStartMon;
            /// <summary>
            /// 日
            /// </summary>
            public byte byStartDay;
            /// <summary>
            /// 年
            /// </summary>
            public ushort wEndYear;
            /// <summary>
            /// 月
            /// </summary>
            public byte byEndMon;
            /// <summary>
            /// 日
            /// </summary>
            public byte byEndDay;
        }

        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_DVR_HOLIDATE_UNION
        {
            /// <summary>
            /// 联合体大小 12字节
            /// </summary>
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.U4)]
            public uint[] dwSize;
        }

        public enum HOLI_DATE_MODE
        {
            HOLIDATE_MODEA = 0,
            HOLIDATE_MODEB,
            HOLIDATE_MODEC
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HOLIDAY_PARAM
        {
            /// <summary>
            /// 是否启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 日期模式 0-模式A 1-模式B 2-模式C
            /// </summary>
            public byte byDateMode;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 假日日期
            /// </summary>
            public NET_DVR_HOLIDATE_UNION uHolidate;
            /// <summary>
            /// 假日名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byName;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        public const int MAX_HOLIDAY_NUM = 32;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HOLIDAY_PARAM_CFG
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 假日参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_HOLIDAY_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_HOLIDAY_PARAM[] struHolidayParam;
            /// <summary>
            /// 保留参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 假日报警处理方式
        /// </summary>
        //假日报警处理方式
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HOLIDAY_HANDLE
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 布防时间段
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 240, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HOLIDAY_RECORD
        {
            public uint dwSize;
            /// <summary>
            /// 录像参数
            /// </summary>
            public NET_DVR_RECORDDAY struRecDay;
            /// <summary>
            /// 录像时间段
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_RECORDSCHED[] struRecordSched;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        public const int MAX_LINK_V30 = 128;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ONE_LINK
        {
            /// <summary>
            /// 客户端IP
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// 通道号
            /// </summary>
            public int lChannel;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LINK_STATUS
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 连接的数目
            /// </summary>
            public ushort wLinkNum;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 连接的客户端信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LINK_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ONE_LINK[] struOneLink;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        public const int MAX_BOND_NUM = 2;

        /// <summary>
        /// 单BONDING网卡配置结构体
        /// </summary>
        //单BONDING网卡配置结构体
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_ONE_BONDING
        {
            public byte byMode;
            public byte byUseDhcp;
            public byte byMasterCard;
            public byte byStatus;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NETWORK_CARD, ArraySubType = UnmanagedType.I1)]
            public byte[] byBond;
            public NET_DVR_ETHERNET_V30 struEtherNet;
            public NET_DVR_IPADDR struGatewayIpAddr;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// BONDING网卡配置结构体
        /// </summary>
        //BONDING网卡配置结构体
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_NETWORK_BONDING
        {
            public uint dwSize;
            public byte byEnable;
            public byte byNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_BOND_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_ONE_BONDING[] struOneBond;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 磁盘配额
        /// </summary>
        //磁盘配额
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISK_QUOTA
        {
            /// <summary>
            /// 磁盘配额类型,1 - 按容量
            /// </summary>
            public byte byQuotaType;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 分配的磁盘容量高32位 单位MB
            /// </summary>
            public uint dwHCapacity;
            /// <summary>
            /// 分配的磁盘容量低32位 单位MB
            /// </summary>
            public uint dwLCapacity;
            /// <summary>
            /// 已使用的磁盘大小高32位 单位MB
            /// </summary>
            public uint dwHUsedSpace;
            /// <summary>
            /// 已使用的磁盘大小低32位 单位MB
            /// </summary>
            public uint dwLUsedSpace;
            /// <summary>
            /// 分配的磁盘比例,单位:%
            /// </summary>
            public byte byQuotaRatio;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 21, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISK_QUOTA_CFG
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 图片配额
            /// </summary>
            public NET_DVR_DISK_QUOTA struPicQuota;
            /// <summary>
            /// 录像配额
            /// </summary>
            public NET_DVR_DISK_QUOTA struRecordQuota;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 60, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TIMING_CAPTURE
        {
            /// <summary>
            /// 定时抓图图片质量
            /// </summary>
            public NET_DVR_JPEGPARA struJpegPara;
            /// <summary>
            /// 定时抓图时间间隔,单位s   1-1s 2-2s 3-3s 4-4s 5-5s
            /// </summary>
            public uint dwPicInterval;
            /// <summary>
            /// 6-10m 7-30m 8-1h 9-12h 10-24h
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_REL_CAPTURE_CHAN
        {
            /// <summary>
            /// 按位表示
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byChan;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        public const int MAX_PIC_EVENT_NUM = 32;
        public const int MAX_ALARMIN_CAPTURE = 16;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_REL_CAPTURE_CHAN_V40
        {
            /// <summary>
            /// 最大可触发的关联通道数-只读属性
            /// </summary>
            public uint dwMaxRelCaptureChanNum;
            /// <summary>
            /// 触发的关联抓图通道号，按值表示，采用紧凑型排列,0xffffffff表示后续无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwChanNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_EVENT_CAPTURE_V40
        {
            /// <summary>
            /// 事件抓图图片质量
            /// </summary>
            public NET_DVR_JPEGPARA struJpegPara;
            /// <summary>
            /// 事件抓图时间间隔  单位为秒
            /// </summary>
            public uint dwPicInterval;
            /// <summary>
            /// 数组下标 0 移动侦测触发抓图 1 视频遮挡触发抓图 2 视频丢失触发抓图,数组3表示PIR报警抓图，数组4表示无线报警抓图，数组5表示呼救报警抓图,数组6表示智能抓图
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_PIC_EVENT_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_REL_CAPTURE_CHAN_V40[] struRelCaptureChan;
            /// <summary>
            /// 报警输入触发抓图，下标0 代表报警输入1 依次类推
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMIN_CAPTURE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_REL_CAPTURE_CHAN_V40[] struAlarmInCapture;
            /// <summary>
            /// 设备支持的最大报警输入组数，每组16个报警输入
            /// </summary>
            public uint dwMaxGroupNum;
            /// <summary>
            /// 抓图张数
            /// </summary>
            public byte byCapTimes;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 59, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_EVENT_CAPTURE
        {
            /// <summary>
            /// 事件抓图图片质量
            /// </summary>
            public NET_DVR_JPEGPARA struJpegPara;
            /// <summary>
            /// 事件抓图时间间隔  单位为秒  1-1s 2-2s 3-3s 4-4s 5-5s
            /// * 6-10m 7-30m 8-1h 9-12h 10-24h
            /// </summary>
            public uint dwPicInterval;
            /// <summary>
            /// 数组下标 0 移动侦测触发抓图 1 视频遮挡触发抓图,
            /// * 2 视频丢失触发抓图,数组3表示PIR报警抓图，数组4表示无线报警抓图，
            /// * 数组5表示呼救报警抓图,数组6表示智能抓图， 数组7表示人脸侦测
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_PIC_EVENT_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_REL_CAPTURE_CHAN[] struRelCaptureChan;
            /// <summary>
            /// 报警输入触发抓图，下标0 代表报警输入1 依次类推
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ALARMIN_CAPTURE, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_REL_CAPTURE_CHAN[] struAlarmInCapture;
            /// <summary>
            /// 抓图张数
            /// </summary>
            public byte byCapTimes;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 59, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_JPEG_CAPTURE_CFG_V40
        {
            /// <summary>
            /// 结构体长度
            /// </summary>
            public uint dwSize;
            public NET_DVR_TIMING_CAPTURE struTimingCapture;
            public NET_DVR_EVENT_CAPTURE_V40 struEventCapture;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_JPEG_CAPTURE_CFG
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            public NET_DVR_TIMING_CAPTURE struTimingCapture;
            public NET_DVR_EVENT_CAPTURE struEventCapture;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CAPTURE_DAY
        {
            /// <summary>
            /// 是否全天抓图
            /// </summary>
            public byte byAllDayCapture;
            /// <summary>
            /// 抓图类型：0-定时抓图，1-移动侦测抓图，2-报警抓图，3-移动侦测或报警抓图，4-移动侦测和报警抓图，6-智能报警抓图
            /// </summary>
            public byte byCaptureType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CAPTURE_SCHED
        {
            /// <summary>
            /// 抓图时间段
            /// </summary>
            public NET_DVR_SCHEDTIME struCaptureTime;
            /// <summary>
            /// 抓图类型：0-定时抓图，1-移动侦测抓图，2-报警抓图，3-移动侦测或报警抓图，4-移动侦测和报警抓图，6-智能报警抓图
            /// </summary>
            public byte byCaptureType;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 通道抓图计划
        /// </summary>
        //通道抓图计划
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCHED_CAPTURECFG
        {
            /// <summary>
            /// 结构体
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 是否抓图
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 全天抓图计划
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CAPTURE_DAY[] struCaptureDay;
            /// <summary>
            /// 时间段抓图布防计划
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CAPTURE_SCHED[] struCaptureSched;
            /// <summary>
            /// 假日抓图计划
            /// </summary>
            public NET_DVR_CAPTURE_DAY struCaptureHoliday;
            /// <summary>
            /// 时间段假日抓图布防计划
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TIMESEGMENT_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CAPTURE_SCHED[] struHolidaySched;
            /// <summary>
            /// 抓图保存最长时间 0xffffffff表示该值无效
            /// </summary>
            public uint dwRecorderDuration;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FLOW_TEST_PARAM
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 网卡索引
            /// </summary>
            public int lCardIndex;
            /// <summary>
            /// 设备上传流量时间间隔, 单位:100ms
            /// </summary>
            public uint dwInterval;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FLOW_INFO
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 发送流量大小,单位kbps
            /// </summary>
            public uint dwSendFlowSize;
            /// <summary>
            /// 接收流量大小,单位kbps
            /// </summary>
            public uint dwRecvFlowSize;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 录像标签
        /// </summary>
        public const int LABEL_NAME_LEN = 40;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RECORD_LABEL
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 标签的时间
            /// </summary>
            public NET_DVR_TIME struTimeLabel;
            /// <summary>
            /// 是否快速添加 快速添加时标签名称无效
            /// </summary>
            public byte byQuickAdd;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 标签的名称 长度为40字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = LABEL_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sLabelName;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        public const int LABEL_IDENTIFY_LEN = 64;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LABEL_IDENTIFY
        {
            /// <summary>
            /// 64字节标识
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = LABEL_IDENTIFY_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sLabelIdentify;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 删除的最大标签标识个数
        /// </summary>
        public const int MAX_DEL_LABEL_IDENTIFY = 20;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEL_LABEL_PARAM
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 按位表示,0x01表示按标识删除
            /// </summary>
            public byte byMode;
            public byte byRes1;
            /// <summary>
            /// 标签数目
            /// </summary>
            public ushort wLabelNum;
            /// <summary>
            /// 标签标识
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DEL_LABEL_IDENTIFY, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_LABEL_IDENTIFY[] struIndentify;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 160, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MOD_LABEL_PARAM
        {
            /// <summary>
            /// 要修改的标签标识
            /// </summary>
            public NET_DVR_LABEL_IDENTIFY struIndentify;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 修改后的标签名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = LABEL_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sLabelName;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 标签搜索结构体
        /// </summary>
        //标签搜索结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FIND_LABEL
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 查找的通道
            /// </summary>
            public int lChannel;
            /// <summary>
            /// 开始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 结束时间
            /// </summary>
            public NET_DVR_TIME struStopTime;
            /// <summary>
            /// 录像标签名称 如果标签名称为空，则搜索起止时间所有标签
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = LABEL_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sLabelName;
            /// <summary>
            /// 0:不抽帧，1：抽帧
            /// </summary>
            public byte byDrawFrame;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 39, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 标签信息结构体
        /// </summary>
        //标签信息结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FINDLABEL_DATA
        {
            /// <summary>
            /// 标签名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = LABEL_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sLabelName;
            /// <summary>
            /// 标签时间
            /// </summary>
            public NET_DVR_TIME struTimeLabel;
            /// <summary>
            /// 标签标识
            /// </summary>
            public NET_DVR_LABEL_IDENTIFY struLabelIdentify;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }
        public const int CARDNUM_LEN_V30 = 40;
        public const int PICTURE_NAME_LEN = 64;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FIND_PICTURE
        {
            /// <summary>
            /// 图片名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = PICTURE_NAME_LEN)]
            public string sFileName;
            /// <summary>
            /// 图片的时间
            /// </summary>
            public NET_DVR_TIME struTime;
            /// <summary>
            /// 图片的大小
            /// </summary>
            public uint dwFileSize;
            /// <summary>
            /// 卡号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = CARDNUM_LEN_V30)]
            public string sCardNum;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FIND_PICTURE_PARAM
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public int lChannel;
            public byte byFileType;
            /// <summary>
            /// 是否需要卡号
            /// </summary>
            public byte byNeedCard;
            /// <summary>
            /// 省份索引值
            /// </summary>
            public byte byProvince;
            /// <summary>
            /// 事件类型：0保留，1-交通事件；2-违章取证；3-其他事件
            /// </summary>
            public byte byEventType;
            /// <summary>
            /// 卡号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = CARDNUM_LEN_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] sCardNum;
            /// <summary>
            /// 查找图片的开始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 查找图片的结束时间
            /// </summary>
            public NET_DVR_TIME struStopTime;
            /// <summary>
            /// ITC3.7 新增
            /// </summary>
            public uint dwTrafficType;
            /// <summary>
            /// 车辆类型 参考 VCA_VEHICLE_TYPE
            /// </summary>
            public uint dwVehicleType;
            /// <summary>
            /// 违规检测类型参考 VCA_ILLEGAL_TYPE 当前不支持复选
            /// </summary>
            public uint dwIllegalType;
            /// <summary>
            /// 车道号(1~99)
            /// </summary>
            public byte byLaneNo;
            /// <summary>
            /// 0-保留,1-机动车(机动车子类型中支持车牌检索，省份检索),2-非机动车,3-行人
            /// </summary>
            public byte bySubHvtType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 车牌号码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LICENSE_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sLicense;
            /// <summary>
            /// 区域索引值 0-保留，1-欧洲(Europe Region)，2-俄语区域(Russian Region)，3-欧洲&俄罗斯(EU&CIS), 4-中东(Middle East),0xff-所有
            /// </summary>
            public byte byRegion;
            /// <summary>
            /// 国家索引值，参照：COUNTRY_INDEX
            /// </summary>
            public byte byCountry;
            /// <summary>
            /// 地区
            /// </summary>
            public byte byArea;
            /// <summary>
            /// 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
            /// </summary>
            public byte byISO8601;
            /// <summary>
            /// 开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
            /// </summary>
            public byte cStartTimeDifferenceH;
            /// <summary>
            /// 开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
            /// </summary>
            public byte cStartTimeDifferenceM;
            /// <summary>
            /// 结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
            /// </summary>
            public byte cStopTimeDifferenceH;
            /// <summary>
            /// 结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
            /// </summary>
            public byte cStopTimeDifferenceM;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ADDRESS
        {
            /// <summary>
            /// IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_DVR_PIC_EXTRA_INFO_UNION
        {
            /// <summary>
            /// 联合体长度，无实际意义
            /// </summary>
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 544, ArraySubType = UnmanagedType.I1)]
            public byte[] byUnionLen;
        }
        /// <summary>
        /// 人脸子图个数
        /// </summary>
        public const int MAX_FACE_PIC_NUM = 30;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FACE_EXTRA_INFO
        {
            /// <summary>
            /// 人脸子图坐标信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_FACE_PIC_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_RECT[] struVcaRect;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FIND_PICTURE_V50
        {
            /// <summary>
            /// 图片名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PICTURE_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sFileName;
            /// <summary>
            /// 图片的时间
            /// </summary>
            public NET_DVR_TIME struTime;
            /// <summary>
            /// 图片的大小
            /// </summary>
            public uint dwFileSize;
            /// <summary>
            /// 卡号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = CARDNUM_LEN_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] sCardNum;
            /// <summary>
            /// 参考结构 VCA_PLATE_COLOR
            /// </summary>
            public byte byPlateColor;
            /// <summary>
            /// 参考结构 VLR_VEHICLE_CLASS
            /// </summary>
            public byte byVehicleLogo;
            /// <summary>
            /// 文件类型， :0定时抓图1 移动侦测抓图 2 报警抓图3  报警 | 移动侦测抓图 4 报警 & 移动侦测抓图     6 手动抓图 ,9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警,    0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测
            /// </summary>
            public byte byFileType;
            /// <summary>
            /// 识别结果参考结构VTR_RESULT
            /// </summary>
            public byte byRecogResult;
            /// <summary>
            /// 车牌号码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LICENSE_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sLicense;
            /// <summary>
            /// 连续图片表示同一查找结果的时候，0-表示后面没有图片信息，1-表示后面还有图片信息。总共图片信息包括最后一张状态为0的图片。
            /// </summary>
            public byte byEventSearchStatus;
            /// <summary>
            /// 图片所在的地址信息，图片下载时用到
            /// </summary>
            public NET_DVR_ADDRESS struAddr;
            /// <summary>
            /// 是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效
            /// </summary>
            public byte byISO8601;
            /// <summary>
            /// 与UTC的时差（小时），-12 ... +14
            /// </summary>
            public byte cTimeDifferenceH;
            /// <summary>
            /// 与UTC的时差（分钟），-30,0, 30, 45
            /// </summary>
            public byte cTimeDifferenceM;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 253, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 图片附件信息
            /// </summary>
            public NET_DVR_PIC_EXTRA_INFO_UNION uPicExtraInfo;
        }
        /// <summary>
        /// 最大备份图片张数
        /// </summary>
        public const int MAX_RECORD_PICTURE_NUM = 50;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_BACKUP_PICTURE_PARAM
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            public uint dwPicNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RECORD_PICTURE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_FIND_PICTURE[] struPicture;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = DESC_LEN_32, ArraySubType = UnmanagedType.I1)]
            public byte[] byDiskDes;
            public byte byWithPlayer;
            /// <summary>
            /// 是否继续备份 0不继续 1继续
            /// </summary>
            public byte byContinue;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 34, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_COMPRESSION_LIMIT
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 待获取的压缩参数类型1,主码流2,子码流3,事件
            /// </summary>
            public byte byCompressType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 15, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 当前压缩参数配置
            /// </summary>
            public NET_DVR_COMPRESSIONCFG_V30 struCurrentCfg;
        }
        /// <summary>
        /// 准备升级
        /// </summary>
        public const int STEP_READY = 0;
        /// <summary>
        /// 接收升级包数据
        /// </summary>
        public const int STEP_RECV_DATA = 1;
        /// <summary>
        /// 升级系统
        /// </summary>
        public const int STEP_UPGRADE = 2;
        /// <summary>
        /// 备份系统
        /// </summary>
        public const int STEP_BACKUP = 3;
        /// <summary>
        /// 搜索升级文件
        /// </summary>
        public const int STEP_SEARCH = 255;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VIDEO_EFFECT
        {
            /// <summary>
            /// 亮度[0,255]
            /// </summary>
            public uint dwBrightValue;
            /// <summary>
            /// 对比度[0,255]
            /// </summary>
            public uint dwContrastValue;
            /// <summary>
            /// 饱和度[0,255]
            /// </summary>
            public uint dwSaturationValue;
            /// <summary>
            /// 色调[0,255]
            /// </summary>
            public uint dwHueValue;
            /// <summary>
            /// 锐度[0,255]
            /// </summary>
            public uint dwSharpness;
            /// <summary>
            /// 去噪[0,255]
            /// </summary>
            public uint dwDenoising;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VIDEO_INPUT_EFFECT
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 模式 0-标准 1-室内 2-弱光 3-室外  255-自定义
            /// </summary>
            public ushort wEffectMode;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 146, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 视频效果参数
            /// </summary>
            public NET_DVR_VIDEO_EFFECT struVideoEffect;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 60, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VIDEOPARA_V40
        {
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 视频参数类型 0-亮度 1-对比度 2-饱和度 3-色度 4-锐度 5-去噪
            /// </summary>
            public uint dwVideoParamType;
            /// <summary>
            /// 对应的视频参数值，范围依据能力集
            /// </summary>
            public uint dwVideoParamValue;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEFAULT_VIDEO_COND
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 模式
            /// </summary>
            public uint dwVideoMode;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ENCODE_JOINT_PARAM
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 0 没有关联 1 已经关联
            /// </summary>
            public byte byJointed;
            /// <summary>
            /// 被关联的设备类型  1 代表智能设备
            /// </summary>
            public byte byDevType;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 关联的被取流设备IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// 关联的被取流设备端口号
            /// </summary>
            public ushort wPort;
            /// <summary>
            /// 关联的被取流设备通道号
            /// </summary>
            public ushort wChannel;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VCA_CHAN_WORKSTATUS
        {
            /// <summary>
            /// 0-没有关联  1-已经关联
            /// </summary>
            public byte byJointed;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 关联的取流设备IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// 关联的取流设备端口号
            /// </summary>
            public ushort wPort;
            /// <summary>
            /// 关联的取流设备通道号
            /// </summary>
            public ushort wChannel;
            /// <summary>
            /// 0 - 未启用 1 - 启用
            /// </summary>
            public byte byVcaChanStatus;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 19, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VCA_DEV_WORKSTATUS
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 设备的状态0 - 正常工作 1- 不正常工作
            /// </summary>
            public byte byDeviceStatus;
            /// <summary>
            /// CPU使用率0-100 分别代表使用百分率
            /// </summary>
            public byte byCpuLoad;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_VCA_CHAN, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_VCA_CHAN_WORKSTATUS[] struVcaChanStatus;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct UNION_VIDEOPLATFORM_V40
        {
            /// <summary>
            /// 各个子窗口对应解码通道所对应的解码子系统的槽位号(对于视频综合平台中解码子系统有效)
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS, ArraySubType = UnmanagedType.I1)]
            public byte[] byJoinDecoderId;
            /// <summary>
            /// 显示窗口所解视频分辨率，1-D1,2-720P,3-1080P，设备端需要根据此//分辨率进行解码通道的分配，如1分屏配置成1080P，则设备会把4个解码通
            /// 道都分配给此解码通道
            /// </summary>
            public byte byDecResolution;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 143, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct UNION_NOTVIDEOPLATFORM_V40
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 160, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VGA_DISP_CHAN_CFG_V40
        {
            public uint dwSize;
            /// <summary>
            /// 音频是否开启
            /// </summary>
            public byte byAudio;
            /// <summary>
            /// 音频开启子窗口
            /// </summary>
            public byte byAudioWindowIdx;
            /// <summary>
            /// 分辨率，从能力集获取
            /// </summary>
            public byte byVgaResolution;
            /// <summary>
            /// 1:NTSC,2:PAL，0-NULL
            /// </summary>
            public byte byVedioFormat;
            /// <summary>
            /// 画面模式，能力集获取
            /// </summary>
            public uint dwWindowMode;
            /// <summary>
            /// 各个子窗口关联的解码通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS, ArraySubType = UnmanagedType.I1)]
            public byte[] byJoinDecChan;
            /// <summary>
            /// 是否处于放大状态，0：不放大，1：放大
            /// </summary>
            public byte byEnlargeStatus;
            /// <summary>
            /// 放大的子窗口号
            /// </summary>
            public byte byEnlargeSubWindowIndex;
            /// <summary>
            /// 显示模式，0---真实显示，1---缩放显示( 针对BNC )
            /// </summary>
            public byte byScale;
            /// <summary>
            /// 区分共用体，0-视频综合平台内部解码器显示通道配置，1-其他解码器显示通道配置
            /// </summary>
            public byte byUnionType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 120, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_V6SUBSYSTEMPARAM
        {
            /// <summary>
            /// 是否透传，0-否，1-是
            /// </summary>
            public byte bySerialTrans;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 35, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 获取V6子系统配置
        /// </summary>
        public const int NET_DVR_V6PSUBSYSTEMARAM_GET = 1501;
        /// <summary>
        /// 设置V6子系统配置
        /// </summary>
        public const int NET_DVR_V6PSUBSYSTEMARAM_SET = 1502;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CORRECT_DEADPIXEL_PARAM
        {
            public uint dwSize;
            /// <summary>
            /// 命令：0-进入坏点模式，1-添加坏点，2-保存坏点，3-退出坏点
            /// </summary>
            public uint dwCommand;
            /// <summary>
            /// 坏点X坐标
            /// </summary>
            public uint dwDeadPixelX;
            /// <summary>
            /// 坏点Y坐标
            /// </summary>
            public uint dwDeadPixelY;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 最大红绿灯区域个数
        /// </summary>
        public const int MAX_REDAREA_NUM = 6;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_REDAREACFG
        {
            public uint dwSize;
            /// <summary>
            /// 是否开启校正功能，0-关闭，1-开启
            /// </summary>
            public uint dwCorrectEnable;
            /// <summary>
            /// 校正级别，1(校正度最低)-10(校正度最高),默认为5
            /// </summary>
            public uint dwCorrectLevel;
            /// <summary>
            /// 校正区域个数
            /// </summary>
            public uint dwAreaNum;
            /// <summary>
            /// 校正区域
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_REDAREA_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_RECT[] struLaneRect;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HISTORICDATACFG
        {
            public uint dwSize;
            /// <summary>
            /// 历史数据个数
            /// </summary>
            public uint dwTotalNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 审讯重点标记信息长度
        /// </summary>
        public const int INQUEST_MESSAGE_LEN = 44;
        /// <summary>
        /// 最大审讯室个数
        /// </summary>
        public const int INQUEST_MAX_ROOM_NUM = 2;
        /// <summary>
        /// 支持同时恢复的片段数目
        /// </summary>
        public const int MAX_RESUME_SEGMENT = 2;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INQUEST_ROOM
        {
            /// <summary>
            /// 审讯室编号
            /// </summary>
            public byte byRoomIndex;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 23, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 最大刻录机数目
        /// </summary>
        public const int MAX_INQUEST_CDRW_NUM = 4;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INQUEST_CDRW_STATUS
        {
            /// <summary>
            /// 运行状态：0-审讯开始，
            /// 1-审讯过程中刻录，2-审讯停止，
            /// 3-刻录审讯文件,
            /// 4-备份(事后备份和本地备份)
            /// 5-空闲
            /// 6-初始化硬盘
            /// 7-恢复审讯
            /// </summary>
            public uint dwType;
            /// <summary>
            /// 数组0表示刻录机1
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_INQUEST_CDRW_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_INQUEST_CDRW[] strCDRWNum;
            /// <summary>
            /// 审讯开始的时间点
            /// </summary>
            public NET_DVR_TIME_EX struInquestStartTime;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INQUEST_CDRW
        {
            /// <summary>
            /// 刻录机状态是否有效,0-无效,1-有效
            /// </summary>
            public uint dwEnable;
            /// <summary>
            /// 当dwType=0时，
            /// 0-光盘正常，1-无光盘或光盘异常,
            /// 当dwType=1或2时，
            /// 0-刻录正常，1-无光盘或光盘异常，
            /// 2-光盘已封盘(81不支持)，3-光盘空间不足，
            /// 4-异常导致审讯终止(81不支持)
            /// 当dwType=3时，
            /// 0-刻录正常，1-无光盘或光盘异常，
            /// 2-光盘已封盘(81不支持)，3-光盘空间不足
            /// 当dwType=4时，
            /// 0-刻录正常，1-无光盘或光盘异常，
            /// 2-光盘已封盘(81不支持)，3-光盘空间不足
            /// 当dwType=5时,
            /// 0-光盘正常， 1-无光盘或光盘异常,
            /// 2-光盘已封盘(81不支持)
            /// 当dwType=6或7时,
            /// 0-刻录正常, 1-无光盘或光盘异常,
            /// 2-光盘已封盘(81不支持), 3-光盘空间不足
            /// </summary>
            public uint dwStatus;
            /// <summary>
            /// 光盘容量,单位M
            /// </summary>
            public uint dwVolumn;
            /// <summary>
            /// 光盘剩余容量,单位M
            /// </summary>
            public uint dwFreeSpace;
            /// <summary>
            /// 光盘剩余时间，单位秒
            /// </summary>
            public uint dwTimeLeft;
            /// <summary>
            /// 光盘类型
            /// </summary>
            public byte byCDType;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INQUEST_CDRW_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 刻录机的数量
            /// </summary>
            public uint dwNum;
            /// <summary>
            /// 是否选中该光驱
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRwSelectPara;
            /// <summary>
            /// 0表示循环刻录模式  1表示并行刻录模式(默认模式)
            /// </summary>
            public uint dwModeSelect;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// DVR 本地已经开始刻录
            /// </summary>
            public uint dwStartCDRW;
            /// <summary>
            /// 硬盘有异 常
            /// </summary>
            public uint dwHdExcp;
            /// <summary>
            /// 时间间隔，10分钟(0)、20分钟(1)、30分钟(2)
            /// </summary>
            public uint dwInterval;
            /// <summary>
            /// 光盘名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] sLable;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INQUEST_MESSAGE
        {
            /// <summary>
            /// 重点标记信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = INQUEST_MESSAGE_LEN)]
            public string sMessage;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 46, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INQUEST_SENSOR_DEVICE
        {
            /// <summary>
            /// 数据采集设备型号:0-无 1-米乐 2-镭彩 3-优力 4-佳盟 5-永控、6-垅上、7-维纳斯达
            /// </summary>
            public ushort wDeviceType;
            /// <summary>
            /// 数据采集设备地址
            /// </summary>
            public ushort wDeviceAddr;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 28, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INQUEST_SENSOR_INFO
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = INQUEST_MAX_ROOM_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_INQUEST_SENSOR_DEVICE[] struSensorDevice;
            /// <summary>
            /// 支持协议类型,按位表示, 新版本走能力集，不再扩展此字段
            /// </summary>
            public uint dwSupportPro;
            /// <summary>
            /// 0x1:米乐 0x2:镭彩 0x4:优力
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 120, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INQUEST_ROOM_INFO
        {
            /// <summary>
            /// 光盘名称，单室双刻光盘名称是一样的
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = NAME_LEN)]
            public string szCDName;
            /// <summary>
            /// 刻录计算类型0-按码率 1-按时间
            /// </summary>
            public byte byCalcType;
            /// <summary>
            /// 是否自动删除录像，0-不删除，即结束时保存录像 1-删除
            /// </summary>
            public byte byAutoDelRecord;
            /// <summary>
            /// 声音报警阀值
            /// </summary>
            public byte byAlarmThreshold;
            /// <summary>
            /// 审讯通道分辨率，0:720P  1:1080P
            /// </summary>
            public byte byInquestChannelResolution;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INQUEST_SYSTEM_INFO
        {
            /// <summary>
            /// 刻录模式:1 单室双刻模式 2 单室轮刻模式 3 双室双刻模式（修改需要重启设备）
            /// </summary>
            public uint dwRecordMode;
            /// <summary>
            /// 工作模式:0 标准模式 1 通用模式(保留，目前只有标准模式)
            /// </summary>
            public uint dwWorkMode;
            /// <summary>
            /// 设备分辨率，0:标清 1:D1 2:720P 3:1080P（高清审讯机不用此字段）
            /// </summary>
            public uint dwResolutionMode;
            /// <summary>
            /// 温湿度传感器配置
            /// </summary>
            public NET_DVR_INQUEST_SENSOR_INFO struSensorInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = INQUEST_MAX_ROOM_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_INQUEST_ROOM_INFO[] struInquestRoomInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INQUEST_RESUME_SEGMENT
        {
            /// <summary>
            /// 事件起始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 事件终止时间
            /// </summary>
            public NET_DVR_TIME struStopTime;
            /// <summary>
            /// 审讯室编号,从1开始
            /// </summary>
            public byte byRoomIndex;
            /// <summary>
            /// 刻录机编号,从1开始
            /// </summary>
            public byte byDriveIndex;
            /// <summary>
            /// 本片断的大小, 单位M
            /// </summary>
            public ushort wSegmetSize;
            /// <summary>
            /// 本片断在本次审讯中的序号,从1开始
            /// </summary>
            public uint dwSegmentNo;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INQUEST_RESUME_EVENT
        {
            /// <summary>
            /// 需恢复的事件个数
            /// </summary>
            public uint dwResumeNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RESUME_SEGMENT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_INQUEST_RESUME_SEGMENT[] struResumeSegment;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 200, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INQUEST_DEVICE_VERSION
        {
            /// <summary>
            /// 基线主版本.
            /// 0 : 未知
            /// 1 : 8000审讯DVR
            /// 次版本: 1 : 8000HD-S
            /// 2 : 8100审讯DVR
            /// 次版本: 1 : 审讯81SNL
            /// 2 : 审讯81SH
            /// 3 : 审讯81SFH
            /// 3 : 8608高清审讯机NVR
            /// 次版本: 1 : DS-8608SN-SP
            /// 2 : DS-8608SN-ST
            /// </summary>
            public byte byMainVersion;
            /// <summary>
            /// 基线次版本
            /// </summary>
            public byte bySubVersion;
            /// <summary>
            /// 升级版本,未升级为0
            /// </summary>
            public byte byUpgradeVersion;
            /// <summary>
            /// 定制版本,非定制为0
            /// </summary>
            public byte byCustomizeVersion;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 60, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISK_RAID_INFO
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 磁盘Raid是否禁用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 35, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SYNCHRONOUS_IPC
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 是否启用：为前端IPC同步设备参数
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPC_PASSWD
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// IPC的旧密码，传给DVR让DVR验证
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = PASSWD_LEN)]
            public string sOldPasswd;
            /// <summary>
            /// IPC的新密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = PASSWD_LEN)]
            public string sNewPasswd;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 通过获取DVR的网络状态：单位bps
        /// </summary>
        //通过获取DVR的网络状态：单位bps
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DEVICE_NET_USING_INFO
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 预览
            /// </summary>
            public uint dwPreview;
            /// <summary>
            /// 回放
            /// </summary>
            public uint dwPlayback;
            /// <summary>
            /// IPC接入
            /// </summary>
            public uint dwIPCModule;
            /// <summary>
            /// 网盘读写
            /// </summary>
            public uint dwNetDiskRW;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
        }

        /// <summary>
        /// 通过DVR设置前端IPC的IP地址
        /// </summary>
        //通过DVR设置前端IPC的IP地址
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IPC_NETCFG
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// IPC的IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// IPC的端口
            /// </summary>
            public ushort wPort;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 126)]
            public string res;
        }

        /// <summary>
        /// 按时间锁定
        /// </summary>
        //按时间锁定
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TIME_LOCK
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            public NET_DVR_TIME strBeginTime;
            public NET_DVR_TIME strEndTime;
            /// <summary>
            /// 通道号, 0xff表示所有通道
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 录像类型:  0xffffffff－全部，0－定时录像，1-移动侦测，2－报警触发，3-报警触发或移动侦测，4-报警触发和移动侦测，5-命令触发，6-手动录像，7-智能录像(同文件查找)
            /// </summary>
            public uint dwRecordType;
            /// <summary>
            /// 锁定持续时间,单位秒,0xffffffff表示永久锁定
            /// </summary>
            public uint dwLockDuration;
            /// <summary>
            /// 加锁时有效，当dwLockDuration不为永久锁定时，锁定持续的时间到此时间点就自动解锁
            /// </summary>
            public NET_DVR_TIME_EX strUnlockTimePoint;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LOCK_RETURN
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            public NET_DVR_TIME strBeginTime;
            public NET_DVR_TIME strEndTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 67DVS
        /// 证书下载类型
        /// </summary>
        public enum NET_SDK_UPLOAD_TYPE
        {
            UPGRADE_CERT_FILE = 0,
            UPLOAD_CERT_FILE = 1,
            TRIAL_CERT_FILE = 2,
            CONFIGURATION_FILE = 3
        }

        public enum NET_SDK_DOWNLOAD_TYPE
        {
            /// <summary>
            /// 下载证书
            /// </summary>
            NET_SDK_DOWNLOAD_CERT = 0,
            /// <summary>
            /// 下载IPC配置文件
            /// </summary>
            NET_SDK_DOWNLOAD_IPC_CFG_FILE = 1,
            /// <summary>
            /// 下载基准场景图片
            /// </summary>
            NET_SDK_DOWNLOAD_BASELINE_SCENE_PIC = 2,
            /// <summary>
            /// 下载VQD报警图片
            /// </summary>
            NET_SDK_DOWNLOAD_VQD_ALARM_PIC = 3,
            /// <summary>
            /// 下载配置文件
            /// </summary>
            NET_SDK_DOWNLOAD_CONFIGURATION_FILE = 4
        }

        /// <summary>
        /// 下载状态
        /// </summary>
        public enum NET_SDK_DOWNLOAD_STATUS
        {
            /// <summary>
            /// 下载成功
            /// </summary>
            NET_SDK_DOWNLOAD_STATUS_SUCCESS = 1,
            /// <summary>
            /// 正在下载
            /// </summary>
            NET_SDK_DOWNLOAD_STATUS_PROCESSING,
            /// <summary>
            /// 下载失败
            /// </summary>
            NET_SDK_DOWNLOAD_STATUS_FAILED,
            /// <summary>
            /// 未知错误
            /// </summary>
            NET_SDK_DOWNLOAD_STATUS_UNKOWN_ERROR
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_BONJOUR_CFG
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// Bonjour使能 0 ：开启 1：关闭
            /// </summary>
            public byte byEnableBonjour;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 服务名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byFriendlyName;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SOCKS_CFG
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 使能 0：关闭 1：开启
            /// </summary>
            public byte byEnableSocks;
            /// <summary>
            /// SOCKS版本 4：SOCKS4   5：SOCKS5
            /// </summary>
            public byte byVersion;
            /// <summary>
            /// 代理端口，默认1080
            /// </summary>
            public ushort wProxyPort;
            /// <summary>
            /// 代理IP地址，可以是域名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byProxyaddr;
            /// <summary>
            /// 用户名 SOCKS才用
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byUserName;
            /// <summary>
            /// 密码SOCKS5才用
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPassword;
            /// <summary>
            /// 不使用socks代理的网段，格式为"ip/netmask;ip/netmask;…"
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LOCAL_ADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byLocalAddr;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_QOS_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 管理数据的DSCP值 [0-63]
            /// </summary>
            public byte byManageDscp;
            /// <summary>
            /// 报警数据的DSCP值 [0-63]
            /// </summary>
            public byte byAlarmDscp;
            /// <summary>
            /// 视频数据的DSCP值 [0-63]，byFlag为0时，表示音视频
            /// </summary>
            public byte byVideoDscp;
            /// <summary>
            /// 音频数据的DSCP值 [0-63]，byFlag为1时有效
            /// </summary>
            public byte byAudioDscp;
            /// <summary>
            /// 0：音视频合一，1：音视频分开
            /// </summary>
            public byte byFlag;
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 126, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HTTPS_CFG
        {
            public uint dwSize;
            /// <summary>
            /// HTTPS端口
            /// </summary>
            public ushort wHttpsPort;
            /// <summary>
            /// 使能 0：关闭 1：开启
            /// </summary>
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 125, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 证书相关
        /// </summary>
        //证书相关
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CERT_NAME
        {
            /// <summary>
            /// 国家代号 CN等
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_COUNTRY_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCountry;
            /// <summary>
            /// 洲或省
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byState;
            /// <summary>
            /// 地区
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byLocality;
            /// <summary>
            /// 组织
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byOrganization;
            /// <summary>
            /// 单位
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byUnit;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byCommonName;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOMAIN_NAME, ArraySubType = UnmanagedType.I1)]
            public byte[] byEmail;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CERT_PARAM
        {
            public uint dwSize;
            /// <summary>
            /// 证书种类，0-802.1x,1-HTTPS
            /// </summary>
            public ushort wCertFunc;
            /// <summary>
            /// 证书类型，0-CA，1-Certificate,2-私钥文件
            /// </summary>
            public ushort wCertType;
            /// <summary>
            /// 证书文件类型，0-PEM,1-PFX
            /// </summary>
            public byte byFileType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 35, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 上传证书
        /// </summary>
        public const int UPLOAD_CERTIFICATE = 1;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CERT_INFO
        {
            public uint dwSize;
            /// <summary>
            /// 证书参数
            /// </summary>
            public NET_DVR_CERT_PARAM struCertParam;
            /// <summary>
            /// 有效天数，类型为自签名时有效
            /// </summary>
            public uint dwValidDays;
            /// <summary>
            /// 私钥密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPasswd;
            /// <summary>
            /// 证书名称
            /// </summary>
            public NET_DVR_CERT_NAME struCertName;
            /// <summary>
            /// 证书发行者名称（自签名证书信息获取时有效）
            /// </summary>
            public NET_DVR_CERT_NAME struIssuerName;
            /// <summary>
            /// 证书创建时间（自签名证书信息获取时有效）
            /// </summary>
            public NET_DVR_TIME_EX struBeginTime;
            /// <summary>
            /// 证书截止时间（自签名证书信息获取时有效）
            /// </summary>
            public NET_DVR_TIME_EX struEndTime;
            /// <summary>
            /// 证书标识码（自签名证书信息获取时有效）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] serialNumber;
            public byte byVersion;
            /// <summary>
            /// 加密类型 0-RSA  1-DSA
            /// </summary>
            public byte byKeyAlgorithm;
            /// <summary>
            /// 加密长度 0-512  1-1024、 2-2048
            /// </summary>
            public byte byKeyLen;
            /// <summary>
            /// 签名算法类型（自签名证书信息获取时有效）
            /// </summary>
            public byte bySignatureAlgorithm;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// channel record status
        /// ***通道录像状态*****//
        /// </summary>
        //channel record status
        //***通道录像状态*****//
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CHANS_RECORD_STATUS
        {
            /// <summary>
            /// 是否有效
            /// </summary>
            public byte byValid;
            /// <summary>
            /// (只读)录像类型, 按位表示:0: 不在录像；1：在录像 2-空闲
            /// 3-无连接 4-无输入视频 5-未加载 6-存档中
            /// 7-回传中 8-用户名或密码错 9-未验证
            /// 10-存档中和录像中 11-录像回传中和录像中
            /// </summary>
            public byte byRecord;
            /// <summary>
            /// 通道号
            /// </summary>
            public ushort wChannelNO;
            /// <summary>
            /// 关联磁盘
            /// </summary>
            public uint dwRelatedHD;
            /// <summary>
            /// 断网录像功能 0-关闭 1-开启
            /// </summary>
            public byte byOffLineRecord;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IP_ALARM_GROUP_NUM
        {
            public uint dwSize;
            /// <summary>
            /// IP通道报警输入组数
            /// </summary>
            public uint dwIPAlarmInGroup;
            /// <summary>
            /// IP通道报警输入个数
            /// </summary>
            public uint dwIPAlarmInNum;
            /// <summary>
            /// IP通道报警输出组数
            /// </summary>
            public uint dwIPAlarmOutGroup;
            /// <summary>
            /// IP通道报警输出个数
            /// </summary>
            public uint dwIPAlarmOutNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// ****NVR end***//
        /// </summary>
        //****NVR end***//
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CHAN_GROUP_RECORD_STATUS
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 一组64个
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CHANS_RECORD_STATUS[] struChanStatus;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RECTCFG
        {
            /// <summary>
            /// 矩形左上角起始点X坐标
            /// </summary>
            public ushort wXCoordinate;
            /// <summary>
            /// 矩形左上角Y坐标
            /// </summary>
            public ushort wYCoordinate;
            /// <summary>
            /// 矩形宽度
            /// </summary>
            public ushort wWidth;
            /// <summary>
            /// 矩形高度
            /// </summary>
            public ushort wHeight;
        }

        /// <summary>
        /// 窗口信息
        /// </summary>
        /*窗口信息*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WINCFG
        {
            public uint dwSize;
            public byte byVaild;
            /// <summary>
            /// 输入源索引
            /// </summary>
            public byte byInputIdx;
            /// <summary>
            /// 图层，0为最底层
            /// </summary>
            public byte byLayerIdx;
            /// <summary>
            /// 透明度，0～100
            /// </summary>
            public byte byTransparency;
            /// <summary>
            /// 目的窗口(相对显示墙)
            /// </summary>
            public NET_DVR_RECTCFG struWin;
            /// <summary>
            /// 大屏高
            /// </summary>
            public ushort wScreenHeight;
            /// <summary>
            /// 大屏宽
            /// </summary>
            public ushort wScreenWidth;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALLWINCFG
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LAYERNUMS, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_WINCFG[] struWinCfg;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCREENZOOM
        {
            public uint dwSize;
            /// <summary>
            /// 大屏号
            /// </summary>
            public uint dwScreenNum;
            public NET_DVR_POINT_FRAME struPointFrame;
            /// <summary>
            /// 图层号
            /// </summary>
            public byte byLayer;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 2011-04-18
        /// 摄像机信息,最多9999个，从1开始
        /// </summary>
        //2011-04-18
        /*摄像机信息,最多9999个，从1开始 */
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_MATRIX_CAMERAINFO
        {
            /// <summary>
            /// cam的全局编号
            /// </summary>
            public uint dwGlobalCamId;
            /// <summary>
            /// cam的名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sCamName;
            /// <summary>
            /// cam对应矩阵的编号
            /// </summary>
            public uint dwMatrixId;
            /// <summary>
            /// cam对应矩阵的内部编号
            /// </summary>
            public uint dwLocCamId;
            /// <summary>
            /// 是否有效，0-否，1-是
            /// </summary>
            public byte byValid;
            /// <summary>
            /// 是否可控，0-否，1-是
            /// </summary>
            public byte byPtzCtrl;
            /// <summary>
            /// *使用类型，0-不作为干线使用，1-BNC，2-SP3,3-V6光纤，4-其他光纤*/
            /// </summary>
            public byte byUseType;
            /// <summary>
            /// 当前使用状态，0-没有被使用，1-被干线使用
            /// </summary>
            public byte byUsedByTrunk;
            /// <summary>
            /// 摄像机分辨率,以D1为单位：1 - 1个D1，2- 2个D1，作为干线使用时，指的是干线的带宽
            /// </summary>
            public byte byTrunkReq;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 安装时间
            /// </summary>
            public NET_DVR_TIME struInstallTime;
            /// <summary>
            /// 用途描述
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPurpose;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 显示器信息，最多2048个
        /// </summary>
        /*显示器信息，最多2048个*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_MATRIX_MONITORINFO
        {
            /// <summary>
            /// mon 的统一编号
            /// </summary>
            public uint dwGloalMonId;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sMonName;
            /// <summary>
            /// mon所在矩阵的编号
            /// </summary>
            public uint dwMatrixId;
            /// <summary>
            /// mon的内部编号
            /// </summary>
            public uint dwLocalMonId;
            /// <summary>
            /// 是否有效，0-否，1-是
            /// </summary>
            public byte byValid;
            /// <summary>
            /// 使用类型，0-不作为干线使用，1-BNC，2-SP3,3-V6光纤，4-其他光纤
            /// </summary>
            public byte byTrunkType;
            /// <summary>
            /// 当前使用状态，0-没有被使用，1-被干线使用
            /// </summary>
            public byte byUsedByTrunk;
            /// <summary>
            /// 分辨率, 以D1为单位：1- 1个D1，2- 2个D1，作为干线使用时，指的是干线的带宽
            /// </summary>
            public byte byTrunkReq;
            /// <summary>
            /// 安装时间
            /// </summary>
            public NET_DVR_TIME struInstallTime;
            /// <summary>
            /// 用途描述
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPurpose;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_MATRIX_DIGITALMATRIX
        {
            /// <summary>
            /// 设备为数字设备时的IP信息
            /// </summary>
            public NET_DVR_IPADDR struAddress;
            public ushort wPort;
            /// <summary>
            /// 0 - eth0, 1 - eth1, 考虑双网口如何通信加入绑定的网口
            /// </summary>
            public byte byNicNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 69, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_MATRIX_ANALOGMATRIX
        {
            /// <summary>
            /// 连接的串口号
            /// </summary>
            public byte bySerPortNum;
            /// <summary>
            /// 矩阵接入网关的串口与模拟矩阵的键盘口(键盘协议)连接还是与矩阵通信口（矩阵协议）连接 ，0 --- 矩阵协议通讯口 1 --- 键盘通讯口
            /// </summary>
            public byte byMatrixSerPortType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 232串口参数
            /// </summary>
            public NET_DVR_SINGLE_RS232 struRS232;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 200, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIXLIST
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 设备返回的矩阵数量
            /// </summary>
            public uint dwMatrixNum;
            /// <summary>
            /// 矩阵信息缓冲区
            /// </summary>
            public IntPtr pBuffer;
            /// <summary>
            /// 所分配指针长度，输入参数
            /// </summary>
            public uint dwBufLen;
        }

        /// <summary>
        /// 串口配置信息
        /// </summary>
        /*串口配置信息*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_MATRIX_UARTPARAM
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPortName;
            /// <summary>
            /// 用户编号，当连接设备为键盘时，绑定一个用户，用于权限管理
            /// </summary>
            public ushort wUserId;
            /// <summary>
            /// 串口类型，三种0-RS232/1-RS485/2-RS422
            /// </summary>
            public byte byPortType;
            /// <summary>
            /// 串口连接的设备的类型0-空闲，1-键盘，2-用作透明通道(485串口不可配置成透明通道),3-模拟矩阵
            /// </summary>
            public byte byFuncType;
            /// <summary>
            /// 串口支持的协议类型, 当连接键盘设备时需要该信息,获取键盘支持协议的编号及描述符
            /// </summary>
            public byte byProtocolType;
            public byte byBaudRate;
            public byte byDataBits;
            /// <summary>
            /// 停止位
            /// </summary>
            public byte byStopBits;
            /// <summary>
            /// 校验
            /// </summary>
            public byte byParity;
            /// <summary>
            /// 流控，软件流控，无流控
            /// </summary>
            public byte byFlowCtrl;
            /// <summary>
            /// 预留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 22, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 最多256个用户，1～256
        /// </summary>
        //最多256个用户，1～256
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_MATRIX_USERPARAM
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 用户角色:0-管理员,1-操作员；只有一个系统管理员，255个操作员
            /// </summary>
            public byte byRole;
            /// <summary>
            /// 统一级别，用于操作级别管理,1- 255
            /// </summary>
            public byte byLevel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 18, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 最多255个资源组
        /// </summary>
        //最多255个资源组
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_MATRIX_RESOURSEGROUPPARAM
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byGroupName;
            /// <summary>
            /// 0-摄像机CAM组，1-显示器MON组
            /// </summary>
            public byte byGroupType;
            public byte byRes1;
            public ushort wMemNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 512, ArraySubType = UnmanagedType.U4)]
            public uint[] dwGlobalId;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 最多255个用户组
        /// </summary>
        //最多255个用户组
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_MATRIX_USERGROUPPARAM
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sGroupName;
            /// <summary>
            /// 包含的用户成员
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 255, ArraySubType = UnmanagedType.U2)]
            public ushort[] wUserMember;
            /// <summary>
            /// 包含的资源组成员
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 255, ArraySubType = UnmanagedType.U2)]
            public ushort[] wResorceGroupMember;
            /// <summary>
            /// 权限，数组0-ptz权限、切换权限、查询权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byPermission;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_MATRIX_TRUNKPARAM
        {
            public uint dwSize;
            public uint dwTrunkId;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sTrunkName;
            public uint dwSrcMonId;
            public uint dwDstCamId;
            /// <summary>
            /// 使用类型  1-BNC，2-SP3光纤高清，3-SP3光纤D1， 4-V6光纤，5-其他光纤
            /// </summary>
            public byte byTrunkType;
            /// <summary>
            /// 表示光纤的带宽，可以传输几路
            /// </summary>
            public byte byAbility;
            /// <summary>
            /// 针对光纤干线而言，表示子通道号
            /// </summary>
            public byte bySubChan;
            /// <summary>
            /// 干线级别 1-255
            /// </summary>
            public byte byLevel;
            /// <summary>
            /// 预留的用户ID： 1~256 ，0表示释放预留
            /// </summary>
            public ushort wReserveUserID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 18, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_TRUNKLIST
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 设备返回的干线数量
            /// </summary>
            public uint dwTrunkNum;
            /// <summary>
            /// 干线信息缓冲区
            /// </summary>
            public IntPtr pBuffer;
            /// <summary>
            /// 所分配指针长度，输入参数
            /// </summary>
            public uint dwBufLen;
        }
        /// <summary>
        /// 支持的最大矩阵协议数
        /// </summary>
        public const int MATRIX_PROTOCOL_NUM = 20;
        /// <summary>
        /// 支持的最大键盘协议数
        /// </summary>
        public const int KEYBOARD_PROTOCOL_NUM = 20;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PROTO_TYPE_EX
        {
            /// <summary>
            /// ipc协议值
            /// </summary>
            public ushort wType;
            /// <summary>
            /// 0：模拟 1：数字 2：兼容模拟、数字
            /// </summary>
            public ushort wCommunitionType;
            /// <summary>
            /// 协议描述字段
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = DESC_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDescribe;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIXMANAGE_ABIILITY
        {
            public uint dwSize;
            /// <summary>
            /// 最大Camera数量
            /// </summary>
            public uint dwMaxCameraNum;
            /// <summary>
            /// 最大显示器数量
            /// </summary>
            public uint dwMaxMonitorNum;
            /// <summary>
            /// 最大矩阵数量
            /// </summary>
            public ushort wMaxMatrixNum;
            /// <summary>
            /// 串口数量
            /// </summary>
            public ushort wMaxSerialNum;
            /// <summary>
            /// 最大用户数
            /// </summary>
            public ushort wMaxUser;
            /// <summary>
            /// 最大资源组数
            /// </summary>
            public ushort wMaxResourceArrayNum;
            /// <summary>
            /// 最大用户组数
            /// </summary>
            public ushort wMaxUserArrayNum;
            /// <summary>
            /// 最大干线数
            /// </summary>
            public ushort wMaxTrunkNum;
            /// <summary>
            /// 起始用户号
            /// </summary>
            public byte nStartUserNum;
            /// <summary>
            /// 起始用户组号
            /// </summary>
            public byte nStartUserGroupNum;
            /// <summary>
            /// 起始资源组号
            /// </summary>
            public byte nStartResourceGroupNum;
            /// <summary>
            /// 起始串口号
            /// </summary>
            public byte nStartSerialNum;
            /// <summary>
            /// 有效的矩阵协议数目，从0开始
            /// </summary>
            public uint dwMatrixProtoNum;
            /// <summary>
            /// 最大协议列表长度
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MATRIX_PROTOCOL_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_PROTO_TYPE_EX[] struMatrixProto;
            /// <summary>
            /// 有效的键盘协议数目，从0开始
            /// </summary>
            public uint dwKeyBoardProtoNum;
            /// <summary>
            /// 最大协议列表长度
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MATRIX_PROTOCOL_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_PROTO_TYPE_EX[] struKeyBoardProto;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SINGLEWALLPARAM
        {
            public uint dwSize;
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 电视墙输出号
            /// </summary>
            public uint dwWallNum;
            /// <summary>
            /// 坐标须为基准坐标的整数倍（128×128），宽度和高度值不用设置，即为基准值
            /// </summary>
            public NET_DVR_RECTCFG struRectCfg;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 36, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 窗口信息
        /// </summary>
        /*窗口信息*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WALLWINCFG
        {
            public uint dwSize;
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 7, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 窗口号
            /// </summary>
            public uint dwWinNum;
            /// <summary>
            /// 窗口相对应的图层号
            /// </summary>
            public uint dwLayerIndex;
            /// <summary>
            /// 目的窗口(相对显示墙)
            /// </summary>
            public NET_DVR_RECTCFG struWinPosition;
            /// <summary>
            /// 分布式大屏控制器设备序号
            /// </summary>
            public uint dwDeviceIndex;
            /// <summary>
            /// 输入信号源
            /// </summary>
            public ushort wInputIndex;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 14, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 窗口相关参数
        /// </summary>
        //窗口相关参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WALLWINPARAM
        {
            public uint dwSize;
            /// <summary>
            /// 使能透明度，0-关，非0-开
            /// </summary>
            public byte byTransparency;
            /// <summary>
            /// 窗口分屏模式，能力集获取
            /// </summary>
            public byte byWinMode;
            /// <summary>
            /// 畅显使能，0-关，1-开
            /// </summary>
            public byte byEnableSpartan;
            /// <summary>
            /// 为窗口分配的解码资源，1-D1,2-720P,3-1080P
            /// </summary>
            public byte byDecResource;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RECTCFG_EX
        {
            public uint dwXCoordinate;
            public uint dwYCoordinate;
            public uint dwWidth;
            public uint dwHeight;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 电视墙输出位置配置
        /// </summary>
        //电视墙输出位置配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VIDEOWALLDISPLAYPOSITION
        {
            public uint dwSize;
            /// <summary>
            /// 使能：0- 禁用，1- 启用
            /// </summary>
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 电视墙号(组合)
            /// </summary>
            public uint dwVideoWallNo;
            /// <summary>
            /// 显示输出号(组合)，批量获取全部时有效
            /// </summary>
            public uint dwDisplayNo;
            /// <summary>
            /// 位置坐标，须为基准坐标（通过能力集获取）的整数倍，宽度和高度值不用设置，即为基准值
            /// </summary>
            public NET_DVR_RECTCFG_EX struRectCfg;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 显示输出参数
        /// </summary>
        //显示输出参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISPLAYPARAM
        {
            /// <summary>
            /// 显示输出号
            /// </summary>
            public uint dwDisplayNo;
            /// <summary>
            /// 输出连接模式,1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, \
            /// 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI自适应，10-3GSDI,11-VGA/DVI自适应，12-HDBaseT, 0xff-无效
            /// </summary>
            public byte byDispChanType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 显示输出参数配置
        /// </summary>
        public const int MAX_DISPLAY_NUM = 512;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISPLAYCFG
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DISPLAY_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_DISPLAYPARAM[] struDisplayParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 窗口信息
        /// </summary>
        //窗口信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VIDEOWALLWINDOWPOSITION
        {
            public uint dwSize;
            /// <summary>
            /// 窗口使能,0-不使能，1-使能
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 窗口操作模式，0-统一坐标，1-分辨率坐标
            /// </summary>
            public byte byWndOperateMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 窗口号
            /// </summary>
            public uint dwWindowNo;
            /// <summary>
            /// 窗口相对应的图层号，图层号到最大即置顶，置顶操作
            /// </summary>
            public uint dwLayerIndex;
            /// <summary>
            /// 目的窗口统一坐标(相对显示墙)，获取或按统一坐标设置时有效
            /// </summary>
            public NET_DVR_RECTCFG_EX struRect;
            /// <summary>
            /// 目的窗口分辨率坐标，获取或按分辨率坐标设置有效
            /// </summary>
            public NET_DVR_RECTCFG_EX struResolution;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 44, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CHAN_RELATION_RESOURCE
        {
            public uint dwSize;
            /// <summary>
            /// 显示通道号（1字节设备号+1字节保留+2字节显示通道号）
            /// </summary>
            public uint dwDisplayChan;
            /// <summary>
            /// 是否关联子窗口音频
            /// </summary>
            public byte byRelateAudio;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 关联音频的子窗口号（1字节电视墙号+1字节子窗口号+2字节窗口号）
            /// </summary>
            public uint dwSubWinNo;
            /// <summary>
            /// 编码通道号，获取全部时有效
            /// </summary>
            public uint dwChannel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PU_STREAM_CFG_V41
        {
            public uint dwSize;
            /// <summary>
            /// 取流模式：0- 无效，1- 通过IP或域名取流，2- 通过URL取流，3- 通过动态域名解析向设备取流
            /// </summary>
            public byte byStreamMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public NET_DVR_DEC_STREAM_MODE uDecStreamMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_VIDEO_WALL_INFO
        {
            public uint dwSize;
            public uint dwWindowNo;
            public uint dwSceneNo;
            /// <summary>
            /// 目的墙号
            /// </summary>
            public uint dwDestWallNo;
            /// <summary>
            /// 目的场景号
            /// </summary>
            public uint dwDestSceneNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_SCENE_CONTROL_INFO
        {
            public uint dwSize;
            public NET_DVR_VIDEO_WALL_INFO struVideoWallInfo;
            public uint dwCmd;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WALLSCENECFG
        {
            public uint dwSize;
            /// <summary>
            /// 场景名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sSceneName;
            /// <summary>
            /// 场景是否有效，0-无效，1-有效
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 场景号，只能获取。获取所有场景时使用该参数
            /// </summary>
            public byte bySceneIndex;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 78, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_BUF_INFO
        {
            public IntPtr pBuf;
            public uint nLen;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_IN_PARAM
        {
            public NET_DVR_BUF_INFO struCondBuf;
            public NET_DVR_BUF_INFO struInParamBuf;
            public uint dwRecvTimeOut;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_OUT_PARAM
        {
            public NET_DVR_BUF_INFO struOutBuf;
            public IntPtr lpStatusList;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INPUTSTREAMCFG_V40
        {
            public uint dwSize;
            public byte byValid;
            /// <summary>
            /// 见NET_DVR_CAM_MODE
            /// </summary>
            public byte byCamMode;
            /// <summary>
            /// 信号源序号
            /// </summary>
            public ushort wInputNo;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = NAME_LEN)]
            public string sCamName;
            /// <summary>
            /// 视频参数
            /// </summary>
            public NET_DVR_VIDEOEFFECT struVideoEffect;
            /// <summary>
            /// ip输入时使用
            /// </summary>
            public NET_DVR_PU_STREAM_CFG struPuStream;
            /// <summary>
            /// 信号源所在的板卡号，只能获取
            /// </summary>
            public ushort wBoardNum;
            /// <summary>
            /// 信号源在板卡上的位置，只能获取
            /// </summary>
            public ushort wInputIdxOnBoard;
            /// <summary>
            /// 分辨率
            /// </summary>
            public uint dwResolution;
            /// <summary>
            /// 视频制式，见VIDEO_STANDARD
            /// </summary>
            public byte byVideoFormat;
            /// <summary>
            /// 信号源状态，0-字段无效 1-有信号 2-无信号 3-异常
            /// </summary>
            public byte byStatus;
            /// <summary>
            /// 网络信号源分组 组名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = NAME_LEN)]
            public string sGroupName;
            /// <summary>
            /// 关联矩阵，0-不关联  1-关联，当输入信号源为NET_DVR_CAM_BNC，NET_DVR_CAM_VGA，NET_DVR_CAM_DVI，NET_DVR_CAM_HDMI,中的一种时，该参数有效。
            /// </summary>
            public byte byJointMatrix;
            /// <summary>
            /// 拼接信号源的拼接编号(只能获取)
            /// </summary>
            public byte byJointNo;
            /// <summary>
            /// 色彩模式， 0-自定义 1-锐利 2-普通 3-柔和，当为自定义时，使用struVideoEffect设置
            /// </summary>
            public byte byColorMode;
            /// <summary>
            /// 关联屏幕服务器，0-不联，1-关联
            /// </summary>
            public byte byScreenServer;
            /// <summary>
            /// 设备号
            /// </summary>
            public byte byDevNo;
            public byte byRes1;
            /// <summary>
            /// 输入信号源编号（新）
            /// </summary>
            public uint dwInputSignalNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 120, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 人脸抓拍规则(单条)
        /// </summary>
        //人脸抓拍规则(单条)
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_SINGLE_FACESNAPCFG
        {
            /// <summary>
            /// 是否激活规则：0-否，1-是
            /// </summary>
            public byte byActive;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 尺寸过滤器
            /// </summary>
            public NET_VCA_SIZE_FILTER struSizeFilter;
            /// <summary>
            /// 人脸识别区域
            /// </summary>
            public NET_VCA_POLYGON struVcaPolygon;
        }

        /// <summary>
        /// 人脸抓拍规则参数
        /// </summary>
        //人脸抓拍规则参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FACESNAPCFG
        {
            public uint dwSize;
            /// <summary>
            /// 单个目标人脸的抓拍次数0-10
            /// </summary>
            public byte bySnapTime;
            /// <summary>
            /// 抓拍间隔，单位：帧
            /// </summary>
            public byte bySnapInterval;
            /// <summary>
            /// 抓拍阈值，0-100
            /// </summary>
            public byte bySnapThreshold;
            /// <summary>
            /// 目标生成速度,范围[1, 5]
            /// </summary>
            public byte byGenerateRate;
            /// <summary>
            /// 目标检测灵敏度，范围[1, 5]
            /// </summary>
            public byte bySensitive;
            /// <summary>
            /// 2012-3-27参考亮度[0,100]
            /// </summary>
            public byte byReferenceBright;
            /// <summary>
            /// 2012-5-3比对报警模式，0-目标消失后报警，1-实时报警
            /// </summary>
            public byte byMatchType;
            /// <summary>
            /// 2012-5-3实时比对阈值，0~100
            /// </summary>
            public byte byMatchThreshold;
            /// <summary>
            /// 图片规格结构
            /// </summary>
            public NET_DVR_JPEGPARA struPictureParam;
            /// <summary>
            /// 人脸抓拍规则
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RULE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_SINGLE_FACESNAPCFG[] struRule;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 100, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 人体特征识别结果结构体
        /// </summary>
        //人体特征识别结果结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_HUMAN_FEATURE
        {
            public byte byRes3;
            /// <summary>
            /// 性别, 0-表示“未知”（算法不支持）,1 – 男 , 2 – 女, 0xff-算法支持，但是没有识别出来
            /// </summary>
            public byte bySex;
            /// <summary>
            /// 是否戴眼镜 0-表示“未知”（算法不支持）,1 – 不戴, 2 – 戴,0xff-算法支持，public byte byRes4;
            /// </summary>
            public byte byEyeGlass;
            /// <summary>
            /// 误差值
            /// </summary>
            public byte byDeviation;
            /// <summary>
            /// 字段预留,暂不开放
            /// </summary>
            public byte byEthnic;
            /// <summary>
            /// 是否戴口罩 0-表示“未知”（算法不支持）,1 – 不戴, 2 –戴普通眼镜, 3 –戴墨镜,0xff-算法支持，但是没有识别出来
            /// </summary>
            public byte byMask;
            /// <summary>
            /// 是否微笑 0-表示“未知”（算法不支持）,1 – 不微笑, 2 – 微笑, 0xff-算法支持，但是没有识别出来
            /// </summary>
            public byte bySmile;
            public byte byFaceExpression;
            public byte byBeard;
            public byte byRes2;
            /// <summary>
            /// 帽子, 0-不支持,1-不戴帽子,2-戴帽子,0xff-unknow表示未知,算法支持未检出
            /// </summary>
            public byte byHat;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 人脸抓拍附加信息结构体
        /// </summary>
        //人脸抓拍附加信息结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FACESNAP_ADDINFO
        {
            /// <summary>
            /// 人脸矩形框,该坐标为人脸小图(头肩照)中人脸的坐标
            /// </summary>
            public NET_VCA_RECT struFacePicRect;
            /// <summary>
            /// 旋转角, -90~90度
            /// </summary>
            public int iSwingAngle;
            /// <summary>
            /// 俯仰角, -90~90度
            /// </summary>
            public int iTiltAngle;
            /// <summary>
            /// 瞳距,范围为：最小值为10像素,最大值为当前分辨率宽度/1.6
            /// </summary>
            public uint dwPupilDistance;
            /// <summary>
            /// 目标遮挡状态， 0-表示“未知”（算法不支持）,1~无遮挡,2~瞬时轻度遮挡，3~持续轻度遮挡，4~严重遮挡
            /// </summary>
            public byte byBlockingState;
            /// <summary>
            /// 人脸抓拍测温使能 1-开启 0-关闭
            /// </summary>
            public byte byFaceSnapThermometryEnabled;
            /// <summary>
            /// 人脸抓拍测温是否温度异常 1-是 0-否
            /// </summary>
            public byte byIsAbnomalTemperature;
            /// <summary>
            /// 测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
            /// </summary>
            public byte byThermometryUnit;
            /// <summary>
            /// 最佳抓拍下进入时间
            /// </summary>
            public NET_DVR_TIME_EX struEnterTime;
            /// <summary>
            /// 最佳抓拍下离开时间
            /// </summary>
            public NET_DVR_TIME_EX struExitTime;
            /// <summary>
            /// 人脸温度（ - 20.0℃~150.0℃，精确到小数点后1位）
            /// </summary>
            public float fFaceTemperature;
            /// <summary>
            /// 测温报警警阈值（精确到小数点后1位）
            /// </summary>
            public float fAlarmTemperature;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 472, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 人脸抓拍结果报警上传
        /// </summary>
        //人脸抓拍结果报警上传
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FACESNAP_RESULT
        {
            public uint dwSize;
            public uint dwRelativeTime;
            public uint dwAbsTime;
            public uint dwFacePicID;
            public uint dwFaceScore;
            public NET_VCA_TARGET_INFO struTargetInfo;
            public NET_VCA_RECT struRect;
            public NET_VCA_DEV_INFO struDevInfo;
            public uint dwFacePicLen;
            public uint dwBackgroundPicLen;
            /// <summary>
            /// IDS设备返回0(默认值)，Smart Functiom Return 1
            /// </summary>
            public byte bySmart;
            /// <summary>
            /// 报警结束标记0-保留，1-结束标记（该字段结合人脸ID字段使用，表示该ID对应的下报警结束，主要提供给NVR使用，用于判断报警结束，提取识别图片数据中，清晰度最高的图片）
            /// </summary>
            public byte byAlarmEndMark;
            /// <summary>
            /// 重复报警次数，0-无意义
            /// </summary>
            public byte byRepeatTimes;
            /// <summary>
            /// 人脸图片数据长传方式：0-二进制数据，1-URL
            /// </summary>
            public byte byUploadEventDataType;
            /// <summary>
            /// 人体属性
            /// </summary>
            public NET_VCA_HUMAN_FEATURE struFeature;
            /// <summary>
            /// 停留画面中时间(单位: 秒)
            /// </summary>
            public float fStayDuration;
            /// <summary>
            /// 存储服务IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] sStorageIP;
            /// <summary>
            /// 存储服务端口号
            /// </summary>
            public ushort wStoragePort;
            /// <summary>
            /// 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
            /// </summary>
            public ushort wDevInfoIvmsChannelEx;
            public byte byFacePicQuality;
            /// <summary>
            /// 上传报警的标识长度
            /// </summary>
            public byte byUIDLen;
            /// <summary>
            /// 活体检测状态：0-保留，1-未知(检测失败)，2-非真人人脸，3-真人人脸，4-未开启活体检测
            /// </summary>
            public byte byLivenessDetectionStatus;
            /// <summary>
            /// 附加信息标识位（即是否有NET_VCA_FACESNAP_ADDINFO结构体）,0-无附加信息, 1-有附加信息。
            /// </summary>
            public byte byAddInfo;
            /// <summary>
            /// 标识指针
            /// </summary>
            public IntPtr pUIDBuffer;
            public IntPtr pAddInfoBuffer;
            /// <summary>
            /// 时差字段是否有效  0-时差无效， 1-时差有效
            /// </summary>
            public byte byTimeDiffFlag;
            /// <summary>
            /// 与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效
            /// </summary>
            public byte cTimeDifferenceH;
            /// <summary>
            /// 与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效
            /// </summary>
            public byte cTimeDifferenceM;
            /// <summary>
            /// 断网续传标志位，0-不是重传数据，1-重传数据
            /// </summary>
            public byte byBrokenNetHttp;
            /// <summary>
            /// 指向人脸子图的图片数据
            /// </summary>
            public IntPtr pBuffer1;
            /// <summary>
            /// 背景图的图片数据（保留，通过查找背景图接口可以获取背景图）
            /// </summary>
            public IntPtr pBuffer2;
        }

        /// <summary>
        /// 人脸侦测报警信息
        /// </summary>
        //人脸侦测报警信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FACE_DETECTION
        {
            public uint dwSize;
            public uint dwRelativeTime;
            public uint dwAbsTime;
            public uint dwBackgroundPicLen;
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 人脸子图区域，归一化值，相对于大图（背景图)的分辨率
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 30, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_RECT[] struFacePic;
            public byte byFacePicNum;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 255, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 背景图的图片数据
            /// </summary>
            public IntPtr pBackgroundPicpBuffer;
        }

        /// <summary>
        /// 虚焦侦测结果
        /// </summary>
        //虚焦侦测结果
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEFOCUS_ALARM
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AUDIOEXCEPTION_ALARM
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 报警类型，1-音频输入异常，2-音频输入突变
            /// </summary>
            public byte byAlarmType;
            public byte byRes1;
            /// <summary>
            /// 声音强度（音频输入突变时用到）
            /// </summary>
            public ushort wAudioDecibel;
            /// <summary>
            /// 设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_BUTTON_DOWN_EXCEPTION_ALARM
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FD_IMAGE_CFG
        {
            /// <summary>
            /// 灰度图像数据宽度
            /// </summary>
            public uint dwWidth;
            /// <summary>
            /// 灰度图像高度
            /// </summary>
            public uint dwHeight;
            /// <summary>
            /// 灰度图像数据长度
            /// </summary>
            public uint dwImageLen;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 灰度图像数据
            /// </summary>
            public IntPtr pImage;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FD_PROCIMG_CFG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 是否激活规则;
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 检测灵敏度，[0,5]
            /// </summary>
            public byte bySensitivity;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 22, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 尺寸过滤器
            /// </summary>
            public NET_VCA_SIZE_FILTER struSizeFilter;
            /// <summary>
            /// 多边形
            /// </summary>
            public NET_VCA_POLYGON struPolygon;
            /// <summary>
            /// 图片信息
            /// </summary>
            public NET_VCA_FD_IMAGE_CFG struFDImage;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_SUB_PROCIMG
        {
            /// <summary>
            /// 图片数据长度
            /// </summary>
            public uint dwImageLen;
            /// <summary>
            /// 人脸评分,0-100
            /// </summary>
            public uint dwFaceScore;
            /// <summary>
            /// 人脸子图区域
            /// </summary>
            public NET_VCA_RECT struVcaRect;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 图片数据
            /// </summary>
            public IntPtr pImage;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FD_PROCIMG_RESULT
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 大图ID
            /// </summary>
            public uint dwImageId;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 人脸子图张数
            /// </summary>
            public uint dwSubImageNum;
            /// <summary>
            /// 单张子图信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_TARGET_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_SUB_PROCIMG[] struProcImg;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_PICMODEL_RESULT
        {
            /// <summary>
            /// 图片数据长度
            /// </summary>
            public uint dwImageLen;
            /// <summary>
            /// 模型数据长度
            /// </summary>
            public uint dwModelLen;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 人脸图片数据指针
            /// </summary>
            public IntPtr pImage;
            /// <summary>
            /// 模型数据指针
            /// </summary>
            public IntPtr pModel;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_REGISTER_PIC
        {
            /// <summary>
            /// 大图ID
            /// </summary>
            public uint dwImageID;
            /// <summary>
            /// 人脸评分,0-100
            /// </summary>
            public uint dwFaceScore;
            /// <summary>
            /// 人脸子图区域
            /// </summary>
            public NET_VCA_RECT struVcaRect;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 籍贯参数结构体
        /// </summary>
        //籍贯参数结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AREAINFOCFG
        {
            /// <summary>
            /// 国籍
            /// </summary>
            public ushort wNationalityID;
            /// <summary>
            /// 省
            /// </summary>
            public ushort wProvinceID;
            /// <summary>
            /// 市
            /// </summary>
            public ushort wCityID;
            /// <summary>
            /// 县
            /// </summary>
            public ushort wCountyID;
            /// <summary>
            /// 保留
            /// </summary>
            public uint dwCode;
        }

        /// <summary>
        /// 人员信息结构体
        /// </summary>
        //人员信息结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_HUMAN_ATTRIBUTE
        {
            /// <summary>
            /// 性别：0-男，1-女
            /// </summary>
            public byte bySex;
            /// <summary>
            /// 证件类型：0-身份证，1-警官证
            /// </summary>
            public byte byCertificateType;
            /// <summary>
            /// 出生年月，如：201106
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_HUMAN_BIRTHDATE_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byBirthDate;
            /// <summary>
            /// 姓名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byName;
            /// <summary>
            /// 籍贯参数
            /// </summary>
            public NET_DVR_AREAINFOCFG struNativePlace;
            /// <summary>
            /// 证件号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCertificateNumber;
            /// <summary>
            /// 人员标签信息扩展长度
            /// </summary>
            public uint dwPersonInfoExtendLen;
            /// <summary>
            /// 人员标签信息扩展信息
            /// </summary>
            public IntPtr pPersonInfoExtend;
            public byte byGroup;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 11, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_HUMANATTRIBUTE_COND
        {
            /// <summary>
            /// 性别：0-不启用，1-男，2-女
            /// </summary>
            public byte bySex;
            /// <summary>
            /// 证件类型：0-不启用，1-身份证，2-警官证
            /// </summary>
            public byte byCertificateType;
            /// <summary>
            /// 起始出生年月，如：201106
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_HUMAN_BIRTHDATE_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byStartBirthDate;
            /// <summary>
            /// 截止出生年月，如201106
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_HUMAN_BIRTHDATE_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byEndBirthDate;
            /// <summary>
            /// 姓名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byName;
            /// <summary>
            /// 籍贯参数
            /// </summary>
            public NET_DVR_AREAINFOCFG struNativePlace;
            /// <summary>
            /// 证件号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCertificateNumber;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 禁止名单信息
        /// </summary>
        //禁止名单信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_BLOCKLIST_INFO
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 名单注册ID号（只读）
            /// </summary>
            public uint dwRegisterID;
            /// <summary>
            /// 分组号
            /// </summary>
            public uint dwGroupNo;
            /// <summary>
            /// 名单标志：0-全部，1-允许名单，2-禁止名单
            /// </summary>
            public byte byType;
            /// <summary>
            /// 禁止名单等级，0-全部，1-低，2-中，3-高
            /// </summary>
            public byte byLevel;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 人员信息
            /// </summary>
            public NET_VCA_HUMAN_ATTRIBUTE struAttribute;
            /// <summary>
            /// 备注信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRemark;
            /// <summary>
            /// 人脸库描述数据长度
            /// </summary>
            public uint dwFDDescriptionLen;
            /// <summary>
            /// 人脸库描述数据指针
            /// </summary>
            public IntPtr pFDDescriptionBuffer;
            /// <summary>
            /// 抓拍库附加信息长度
            /// </summary>
            public uint dwFCAdditionInfoLen;
            /// <summary>
            /// 抓拍库附加信息数据指针（FCAdditionInfo中包含相机PTZ坐标）
            /// </summary>
            public IntPtr pFCAdditionInfoBuffer;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_BLOCKLIST_PARA
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 禁止名单基本参数
            /// </summary>
            public NET_VCA_BLOCKLIST_INFO struBlockListInfo;
            /// <summary>
            /// 禁止名单图个数
            /// </summary>
            public uint dwRegisterPicNum;
            /// <summary>
            /// 禁止名单图片信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_HUMAN_PICTURE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_PICMODEL_RESULT[] struRegisterPic;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_BLOCKLIST_COND
        {
            /// <summary>
            /// 通道号
            /// </summary>
            public Int32 lChannel;
            /// <summary>
            /// 分组号
            /// </summary>
            public uint dwGroupNo;
            /// <summary>
            /// 名单标志：0-全部，1-允许名单，2-禁止名单
            /// </summary>
            public byte byType;
            /// <summary>
            /// 禁止名单等级，0-全部，1-低，2-中，3-高
            /// </summary>
            public byte byLevel;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 人员信息
            /// </summary>
            public NET_VCA_HUMAN_ATTRIBUTE struAttribute;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_BLOCKLIST_PIC
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 人脸图个数
            /// </summary>
            public uint dwFacePicNum;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 单张照片信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_HUMAN_PICTURE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_PICMODEL_RESULT[] struBlockListPic;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FIND_PICTURECOND
        {
            /// <summary>
            /// 通道号
            /// </summary>
            public Int32 lChannel;
            /// <summary>
            /// 开始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 结束时间
            /// </summary>
            public NET_DVR_TIME struStopTime;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 最大人脸图片数据长度
        /// </summary>
        public const int MAX_FACE_PIC_LEN = 6144;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_SUB_SNAPPIC_DATA
        {
            /// <summary>
            /// 人脸图ID
            /// </summary>
            public uint dwFacePicID;
            /// <summary>
            /// 人脸图数据长度
            /// </summary>
            public uint dwFacePicLen;
            /// <summary>
            /// 抓拍时间
            /// </summary>
            public NET_DVR_TIME struSnapTime;
            /// <summary>
            /// 相似度
            /// </summary>
            public uint dwSimilarity;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 图片数据
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = MAX_FACE_PIC_LEN)]
            public string sPicBuf;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_ADVANCE_FIND
        {
            /// <summary>
            /// 人脸图片ID
            /// </summary>
            public uint dwFacePicID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 36, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_NORMAL_FIND
        {
            /// <summary>
            /// 大图ID
            /// </summary>
            public uint dwImageID;
            /// <summary>
            /// 人脸评分
            /// </summary>
            public uint dwFaceScore;
            /// <summary>
            /// 人脸子图区域
            /// </summary>
            public NET_VCA_RECT struVcaRect;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_VCA_FIND_SNAPPIC_UNION
        {
            /// <summary>
            /// 联合体大小为44字节
            /// </summary>
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 44, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        public enum VCA_FIND_SNAPPIC_TYPE
        {
            /// <summary>
            /// 普通检索
            /// </summary>
            VCA_NORMAL_FIND = 0x00000000,
            /// <summary>
            /// 高级检索
            /// </summary>
            VCA_ADVANCE_FIND = 0x00000001
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FIND_PICTURECOND_ADVANCE
        {
            /// <summary>
            /// 通道号
            /// </summary>
            public Int32 lChannel;
            /// <summary>
            /// 开始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 结束时间
            /// </summary>
            public NET_DVR_TIME struStopTime;
            /// <summary>
            /// 阈值，0-100
            /// </summary>
            public byte byThreshold;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 23, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 检索类型，详见VCA_FIND_SNAPPIC_TYPE
            /// </summary>
            public VCA_FIND_SNAPPIC_TYPE dwFindType;
            /// <summary>
            /// 检索参数
            /// </summary>
            public NET_VCA_FIND_SNAPPIC_UNION uFindParam;
        }

        /// <summary>
        /// 人脸抓拍信息
        /// </summary>
        //人脸抓拍信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FACESNAP_INFO_ALARM
        {
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 抓拍人脸图ID
            /// </summary>
            public uint dwSnapFacePicID;
            /// <summary>
            /// 抓拍人脸子图的长度，为0表示没有图片，大于0表示有图片
            /// </summary>
            public uint dwSnapFacePicLen;
            /// <summary>
            /// 前端设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 人脸评分，指人脸子图的质量的评分,0-100
            /// </summary>
            public byte byFaceScore;
            /// <summary>
            /// 性别，0-未知，1-男，2-女
            /// </summary>
            public byte bySex;
            /// <summary>
            /// 是否带眼镜，0-未知，1-是，2-否
            /// </summary>
            public byte byGlasses;
            public byte byRes1;
            /// <summary>
            /// 误差值
            /// </summary>
            public byte byDeviation;
            public byte byGroup;
            /// <summary>
            /// 人脸子图图片质量评估等级，0-低等质量,1-中等质量,2-高等质量,
            /// 该质量评估算法仅针对人脸子图单张图片,具体是通过姿态、清晰度、遮挡情况、光照情况等可影响人脸识别性能的因素综合评估的结果
            /// </summary>
            public byte byFacePicQuality;
            /// <summary>
            /// 字段预留,暂不开放
            /// </summary>
            public byte byEthnic;
            /// <summary>
            /// 上传报警的标识长度
            /// </summary>
            public uint dwUIDLen;
            /// <summary>
            /// 标识指针
            /// </summary>
            public IntPtr pUIDBuffer;
            /// <summary>
            /// 停留画面中时间(单位: 秒)
            /// </summary>
            public float fStayDuration;
            /// <summary>
            /// 抓拍人脸子图的图片数据
            /// </summary>
            public IntPtr pBuffer1;
        }

        /// <summary>
        /// 禁止名单报警信息
        /// </summary>
        //禁止名单报警信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_BLOCKLIST_INFO_ALARM
        {
            public NET_VCA_BLOCKLIST_INFO struBlockListInfo;
            /// <summary>
            /// 禁止名单人脸子图的长度，为0表示没有图片，大于0表示有图片
            /// </summary>
            public uint dwBlockListPicLen;
            /// <summary>
            /// 人脸库ID长度
            /// </summary>
            public uint dwFDIDLen;
            /// <summary>
            /// 人脸库Id指针
            /// </summary>
            public IntPtr pFDID;
            /// <summary>
            /// 人脸库图片ID长度
            /// </summary>
            public uint dwPIDLen;
            /// <summary>
            /// 人脸库图片ID指针
            /// </summary>
            public IntPtr pPID;
            /// <summary>
            /// 人脸库阈值[0,100]
            /// </summary>
            public ushort wThresholdValue;
            /// <summary>
            /// 0-保存人脸库图片,1-不保存人脸库图片, 若开启了导入图片或者建模时不保存原图功能时,该字段返回1,此时人脸库图片将不再返回
            /// </summary>
            public byte byIsNoSaveFDPicture;
            /// <summary>
            /// 是否实时报警 0-实时 1-非实时
            /// </summary>
            public byte byRealTimeContrast;
            /// <summary>
            /// 指向图片的指针
            /// </summary>
            public IntPtr pBuffer1;
        }

        /// <summary>
        /// 禁止名单比对结果报警上传
        /// </summary>
        //禁止名单比对结果报警上传
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FACESNAP_MATCH_ALARM
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相似度，[0.001,1]
            /// </summary>
            public float fSimilarity;
            /// <summary>
            /// 抓拍信息
            /// </summary>
            public NET_VCA_FACESNAP_INFO_ALARM struSnapInfo;
            /// <summary>
            /// 禁止名单信息
            /// </summary>
            public NET_VCA_BLOCKLIST_INFO_ALARM struBlockListInfo;
            /// <summary>
            /// 存储服务IP地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] sStorageIP;
            /// <summary>
            /// 存储服务端口号
            /// </summary>
            public ushort wStoragePort;
            /// <summary>
            /// 匹配图片的数量，0-保留（老设备这个值默认0，新设备这个值为0时表示后续没有匹配的图片信息）
            /// </summary>
            public byte byMatchPicNum;
            /// <summary>
            /// 图片数据传输方式: 0-二进制；1-url
            /// </summary>
            public byte byPicTransType;
            /// <summary>
            /// 设备识别抓拍图片长度
            /// </summary>
            public uint dwSnapPicLen;
            /// <summary>
            /// 设备识别抓拍图片指针
            /// </summary>
            public IntPtr pSnapPicBuffer;
            /// <summary>
            /// 目标边界框，设备识别抓拍图片中，人脸子图坐标
            /// </summary>
            public NET_VCA_RECT struRegion;
            /// <summary>
            /// 建模数据长度
            /// </summary>
            public uint dwModelDataLen;
            /// <summary>
            /// 建模数据指针
            /// </summary>
            public IntPtr pModelDataBuffer;
            /// <summary>
            /// 建模状态
            /// </summary>
            public byte byModelingStatus;
            /// <summary>
            /// 活体检测状态：0-保留，1-未知（检测失败），2-非真人人脸，3-真人人脸，4-未开启活体检测
            /// </summary>
            public byte byLivenessDetectionStatus;
            /// <summary>
            /// 与UTC的时差（小时），-12 ... +14， +表示东区,0xff无效
            /// </summary>
            public byte cTimeDifferenceH;
            /// <summary>
            /// 与UTC的时差（分钟），-30, 30, 45， +表示东区，0xff无效
            /// </summary>
            public byte cTimeDifferenceM;
            /// <summary>
            /// 抓拍图是否戴口罩，0-保留，1-未知，2-不戴口罩，3-戴口罩
            /// </summary>
            public byte byMask;
            /// <summary>
            /// 抓拍图是否微笑，0-保留，1-未知，2-不微笑，3-微笑
            /// </summary>
            public byte bySmile;
            /// <summary>
            /// 比对结果，0-保留，1-比对成功，2-比对失败
            /// </summary>
            public byte byContrastStatus;
            /// <summary>
            /// 断网续传标志位，0-不是重传数据，1-重传数据
            /// </summary>
            public byte byBrokenNetHttp;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_BLOCKLIST_INFO_ALARM_LOG
        {
            /// <summary>
            /// 禁止名单基本信息
            /// </summary>
            public NET_VCA_BLOCKLIST_INFO struBlockListInfo;
            /// <summary>
            /// 禁止名单人脸子图ID，用于查找图片
            /// </summary>
            public uint dwBlockListPicID;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FACESNAP_INFO_ALARM_LOG
        {
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 抓拍人脸图ID
            /// </summary>
            public uint dwSnapFacePicID;
            /// <summary>
            /// 前端设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FACESNAP_MATCH_ALARM_LOG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相似度，[0.001,1]
            /// </summary>
            public float fSimilarity;
            /// <summary>
            /// 抓拍信息
            /// </summary>
            public NET_VCA_FACESNAP_INFO_ALARM_LOG struSnapInfoLog;
            /// <summary>
            /// 禁止名单信息
            /// </summary>
            public NET_VCA_BLOCKLIST_INFO_ALARM_LOG struBlockListInfoLog;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 60, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FACEMATCH_PICCOND
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 抓拍人脸子图ID
            /// </summary>
            public uint dwSnapFaceID;
            /// <summary>
            /// 匹配的禁止名单ID
            /// </summary>
            public uint dwBlockListID;
            /// <summary>
            /// 比对的禁止名单人脸子图ID
            /// </summary>
            public uint dwBlockListFaceID;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_FACEMATCH_PICTURE
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 抓拍人脸子图长度
            /// </summary>
            public uint dwSnapFaceLen;
            /// <summary>
            /// 比对的禁止名单人脸子图长度
            /// </summary>
            public uint dwBlockListFaceLen;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 抓拍人脸子图的图片数据
            /// </summary>
            public IntPtr pSnapFace;
            /// <summary>
            /// 比对的禁止名单人脸子图数据
            /// </summary>
            public IntPtr pBlockListFace;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_BLOCKLIST_FASTREGISTER_PARA
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 禁止名单基本参数
            /// </summary>
            public NET_VCA_BLOCKLIST_INFO struBlockListInfo;
            /// <summary>
            /// 图像数据长度
            /// </summary>
            public uint dwImageLen;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 124, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 图像数据
            /// </summary>
            public IntPtr pImage;
        }

        /// <summary>
        /// 单个分区配置
        /// </summary>
        //单个分区配置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_SINGLE_PATH
        {
            /// <summary>
            /// 是否可用,0-否,1-是
            /// </summary>
            public byte byActive;
            /// <summary>
            /// 0-存储抓拍，1-存储禁止名单比对报警，2-存储抓拍和禁止名单比对报警，0xff-无效
            /// </summary>
            public byte byType;
            /// <summary>
            /// 是否用于保存断网的报警图片，0-否，1-是
            /// </summary>
            public byte bySaveAlarmPic;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 盘符号，从0开始
            /// </summary>
            public uint dwDiskDriver;
            /// <summary>
            /// 预留容量（单位为G）
            /// </summary>
            public uint dwLeftSpace;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 存储路径设置
        /// </summary>
        //存储路径设置
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_SAVE_PATH_CFG
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 单个分区
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DISKNUM_V30, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_SINGLE_PATH[] struPathInfo;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 40, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEV_ACCESS_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 接入设备的IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDevicePort;
            /// <summary>
            /// 是否启用，0-否，1-是
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// 接入设备的登录帐号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 接入设备的登录密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 60, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        /// <summary>
        /// ******************************智能人脸识别 end***************************
        /// 分辨率
        /// </summary>
        public const int NOT_AVALIABLE = 0;
        public const int SVGA_60HZ = 52505660;
        public const int SVGA_75HZ = 52505675;
        public const int XGA_60HZ = 67207228;
        public const int XGA_75HZ = 67207243;
        public const int SXGA_60HZ = 84017212;
        public const int SXGA2_60HZ = 84009020;
        public const int _720P_60HZ = 83978300;
        public const int _720P_50HZ = 83978290;
        public const int _1080I_60HZ = 394402876;
        public const int _1080I_50HZ = 394402866;
        public const int _1080P_60HZ = 125967420;
        public const int _1080P_50HZ = 125967410;
        public const int _1080P_30HZ = 125967390;
        public const int _1080P_25HZ = 125967385;
        public const int _1080P_24HZ = 125967384;
        public const int UXGA_60HZ = 105011260;
        public const int UXGA_30HZ = 105011230;
        public const int WSXGA_60HZ = 110234940;
        public const int WUXGA_60HZ = 125982780;
        public const int WUXGA_30HZ = 125982750;
        public const int WXGA_60HZ = 89227324;
        public const int SXGA_PLUS_60HZ = 91884860;

        /// <summary>
        /// 显示通道画面分割模式
        /// </summary>
        //显示通道画面分割模式
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISPWINDOWMODE
        {
            /// <summary>
            /// 显示通道类型：0-VGA, 1-BNC, 2-HDMI, 3-DVI
            /// </summary>
            public byte byDispChanType;
            /// <summary>
            /// 显示通道序号,从1开始，如果类型是VGA，则表示第几个VGA
            /// </summary>
            public byte byDispChanSeq;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byDispMode;
        }

        /// <summary>
        /// 显示通道信息
        /// </summary>
        //显示通道信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISPINFO
        {
            /// <summary>
            /// 通道个数
            /// </summary>
            public byte byChanNums;
            /// <summary>
            /// 起始通道
            /// </summary>
            public byte byStartChan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 支持的分辨率
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SUPPORT_RES, ArraySubType = UnmanagedType.U1)]
            public uint[] dwSupportResolution;
        }

        /// <summary>
        /// 大屏拼接信息
        /// </summary>
        //大屏拼接信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCREENINFO
        {
            /// <summary>
            /// 最多大屏拼接数量
            /// </summary>
            public byte bySupportBigScreenNums;
            /// <summary>
            /// 大屏拼接起始号
            /// </summary>
            public byte byStartBigScreenNum;
            /// <summary>
            /// 大屏拼接模式
            /// </summary>
            public byte byMaxScreenX;
            public byte byMaxScreenY;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_ABILITY_V41
        {
            public uint dwSize;
            /// <summary>
            /// DSP个数
            /// </summary>
            public byte byDspNums;
            /// <summary>
            /// 解码通道数
            /// </summary>
            public byte byDecChanNums;
            /// <summary>
            /// 起始解码通道
            /// </summary>
            public byte byStartChan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// VGA显示通道信息
            /// </summary>
            public NET_DVR_DISPINFO struVgaInfo;
            /// <summary>
            /// BNC显示通道信息
            /// </summary>
            public NET_DVR_DISPINFO struBncInfo;
            /// <summary>
            /// HDMI显示通道信息
            /// </summary>
            public NET_DVR_DISPINFO struHdmiInfo;
            /// <summary>
            /// DVI显示通道信息
            /// </summary>
            public NET_DVR_DISPINFO struDviInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DISPNUM_V41, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_DISPWINDOWMODE[] struDispMode;
            public NET_DVR_SCREENINFO struBigScreenInfo;
            /// <summary>
            /// 是否支持自动重启，0-不支持，1-支持
            /// </summary>
            public byte bySupportAutoReboot;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 119, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        /// <summary>
        /// 最大窗口数
        /// </summary>
        public const int MAX_WINDOWS = 16;
        public const int MAX_WINDOWS_V41 = 36;
        public const int STARTDISPCHAN_VGA = 1;
        public const int STARTDISPCHAN_BNC = 9;
        public const int STARTDISPCHAN_HDMI = 25;
        public const int STARTDISPCHAN_DVI = 29;

        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_DVR_VIDEO_PLATFORM
        {
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 160, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct VideoPlatform
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS_V41, ArraySubType = UnmanagedType.I1)]
            public byte[] byJoinDecoderId;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS_V41, ArraySubType = UnmanagedType.I1)]
            public byte[] byDecResolution;
            /// <summary>
            /// 显示通道在电视墙中位置
            /// </summary>
            public NET_DVR_RECTCFG struPosition;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 80, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NotVideoPlatform
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 160, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 显示通道配置结构体
        /// </summary>
        /*显示通道配置结构体*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_VOUTCFG
        {
            public uint dwSize;
            /// <summary>
            /// 音频是否开启
            /// </summary>
            public byte byAudio;
            /// <summary>
            /// 音频开启子窗口
            /// </summary>
            public byte byAudioWindowIdx;
            /// <summary>
            /// 显示通道类型：0-BNC，1-VGA，2-HDMI，3-DVI，4-YPbPr(解码卡服务器DECODER_SERVER专用)
            /// </summary>
            public byte byDispChanType;
            /// <summary>
            /// 1:NTSC,2:PAL，0-NULL
            /// </summary>
            public byte byVedioFormat;
            /// <summary>
            /// 分辨率
            /// </summary>
            public uint dwResolution;
            /// <summary>
            /// 画面模式，能力集获取
            /// </summary>
            public uint dwWindowMode;
            /// <summary>
            /// 各个子窗口关联的解码通道,设备支持解码资源自动分配时此参数不用填充
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS_V41, ArraySubType = UnmanagedType.I1)]
            public byte[] byJoinDecChan;
            /// <summary>
            /// 是否处于放大状态，0：不放大，1：放大
            /// </summary>
            public byte byEnlargeStatus;
            /// <summary>
            /// 放大的子窗口号
            /// </summary>
            public byte byEnlargeSubWindowIndex;
            /// <summary>
            /// 显示模式，0---真实显示，1---缩放显示( 针对BNC )
            /// </summary>
            public byte byScale;
            /// <summary>
            /// 区分共用体,0-视频综合平台内部解码器显示通道配置，1-其他解码器显示通道配置
            /// </summary>
            public byte byUnionType;
            public NET_DVR_VIDEO_PLATFORM struDiff;
            /// <summary>
            /// 显示输出号，此参数在全部获取时有效
            /// </summary>
            public uint dwDispChanNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 76, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 解码器设备状态
        /// </summary>
        /*解码器设备状态*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISP_CHAN_STATUS_V41
        {
            /// <summary>
            /// 显示状态：0：未显示，1：启动显示
            /// </summary>
            public byte byDispStatus;
            /// <summary>
            /// 0-BNC，1-VGA， 2-HDMI，3-DVI，0xff-无效
            /// </summary>
            public byte byBVGA;
            /// <summary>
            /// 视频制式，1:NTSC,2:PAL,0-NON
            /// </summary>
            public byte byVideoFormat;
            /// <summary>
            /// 画面模式
            /// </summary>
            public byte byWindowMode;
            /// <summary>
            /// 各个子画面关联的解码通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS_V41, ArraySubType = UnmanagedType.I1)]
            public byte[] byJoinDecChan;
            /// <summary>
            /// 每个子画面的显示帧率
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS_V41, ArraySubType = UnmanagedType.I1)]
            public byte[] byFpsDisp;
            /// <summary>
            /// 屏幕模式0-普通 1-大屏
            /// </summary>
            public byte byScreenMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 获取全部显示通道状态时有效，设置时可填0
            /// </summary>
            public uint dwDispChan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 解码器设备状态
        /// </summary>
        /*解码器设备状态*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DECODER_WORK_STATUS_V41
        {
            public uint dwSize;
            /// <summary>
            /// 解码通道状态
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_MATRIX_CHAN_STATUS[] struDecChanStatus;
            /// <summary>
            /// 显示通道状态
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DISPNUM_V41, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_DISP_CHAN_STATUS_V41[] struDispChanStatus;
            /// <summary>
            /// 报警输入状态
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmInStatus;
            /// <summary>
            /// 报警输出状态
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byAlarmOutStatus;
            /// <summary>
            /// 语音对讲状态
            /// </summary>
            public byte byAudioInChanStatus;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 127, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// *****************************文件回放-远程回放设置******************************
        /// </summary>
        /*******************************文件回放-远程回放设置*******************************/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_DEC_REMOTE_PLAY_V41
        {
            public uint dwSize;
            /// <summary>
            /// DVR IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDVRPort;
            /// <summary>
            /// 通道号
            /// </summary>
            public byte byChannel;
            public byte byReserve;
            /// <summary>
            /// 用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 0－按文件 1－按时间
            /// </summary>
            public uint dwPlayMode;
            public NET_DVR_TIME StartTime;
            public NET_DVR_TIME StopTime;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 128)]
            public string sFileName;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        public const int MAX_BIGSCREENNUM_SCENE = 100;

        /// <summary>
        /// 显示通道配置结构
        /// </summary>
        //显示通道配置结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RECTCFG_SCENE
        {
            /// <summary>
            /// 矩形左上角起始点X坐标
            /// </summary>
            public ushort wXCoordinate;
            /// <summary>
            /// 矩形左上角Y坐标
            /// </summary>
            public ushort wYCoordinate;
            /// <summary>
            /// 矩形宽度
            /// </summary>
            public ushort wWidth;
            /// <summary>
            /// 矩形高度
            /// </summary>
            public ushort wHeight;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCENEDISPCFG
        {
            /// <summary>
            /// 是否启用，0-不启用，1-启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 槽位号
            /// </summary>
            public byte bySoltNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public byte byDispChanNum;
            /// <summary>
            /// 音频是否开启,0-否，1-是
            /// </summary>
            public byte byAudio;
            /// <summary>
            /// 音频开启子窗口
            /// </summary>
            public byte byAudioWindowIdx;
            /// <summary>
            /// 1:NTSC,2:PAL，0-NULL
            /// </summary>
            public byte byVedioFormat;
            /// <summary>
            /// 画面模式，从能力集获取
            /// </summary>
            public byte byWindowMode;
            /// <summary>
            /// 是否处于放大状态，0：不放大，1：放大
            /// </summary>
            public byte byEnlargeStatus;
            /// <summary>
            /// 放大的子窗口号
            /// </summary>
            public byte byEnlargeSubWindowIndex;
            /// <summary>
            /// 显示模式，0-真实显示，1-缩放显示( 针对BNC )
            /// </summary>
            public byte byScale;
            /// <summary>
            /// 分辨率
            /// </summary>
            public uint dwResolution;
            /// <summary>
            /// 各个子窗口关联的解码通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS_V41, ArraySubType = UnmanagedType.I1)]
            public byte[] byJoinDecChan;
            /// <summary>
            /// 槽位号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS_V41, ArraySubType = UnmanagedType.I1)]
            public byte[] byJoinDecoderId;
            /// <summary>
            /// 显示窗口所解视频分辨率，1-D1,2-720P,3-1080P，设备端需要根据此//分辨率进行解码通道的分配，如1分屏配置成1080P，则设备会把4个解码通道都分配给此解码通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WINDOWS_V41, ArraySubType = UnmanagedType.I1)]
            public byte[] byDecResolution;
            /// <summary>
            /// 大屏所在的行的序号
            /// </summary>
            public byte byRow;
            /// <summary>
            /// 大屏所在的列的序号
            /// </summary>
            public byte byColumn;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 电视墙显示位置
            /// </summary>
            public NET_DVR_RECTCFG struDisp;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEV_CHAN_INFO_SCENE
        {
            /// <summary>
            /// DVR IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// 端口号
            /// </summary>
            public ushort wDVRPort;
            /// <summary>
            /// 通道号，对于9000等设备的IPC接入，通道号从33开始
            /// </summary>
            public byte byChannel;
            /// <summary>
            /// 传输协议类型0-TCP，1-UDP ，2-MCAST，3-RTP
            /// </summary>
            public byte byTransProtocol;
            /// <summary>
            /// 传输码流模式 0－主码流 1－子码流
            /// </summary>
            public byte byTransMode;
            /// <summary>
            /// 前端设备厂家类型
            /// </summary>
            public byte byFactoryType;
            /// <summary>
            /// 设备类型，1-IPC，2- ENCODER
            /// </summary>
            public byte byDeviceType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 布防主机登陆帐号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 布防主机密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
        }

        /// <summary>
        /// 流媒体服务器基本配置
        /// </summary>
        /*流媒体服务器基本配置*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE
        {
            /// <summary>
            /// 是否启用流媒体服务器取流,0表示无效
            /// </summary>
            public byte byValid;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 流媒体服务器地址
            /// </summary>
            public NET_DVR_IPADDR struDevIP;
            /// <summary>
            /// 流媒体服务器端口
            /// </summary>
            public ushort wDevPort;
            /// <summary>
            /// 传输协议类型0-TCP，1-UDP
            /// </summary>
            public byte byTransmitType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PU_STREAM_CFG_SCENE
        {
            public NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE streamMediaServerCfg;
            public NET_DVR_DEV_CHAN_INFO_SCENE struDevChanInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CYC_SUR_CHAN_ELE_SCENE
        {
            /// <summary>
            /// 是否启用 0－否 1－启用
            /// </summary>
            public byte byEnable;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE struStreamMediaSvrCfg;
            /// <summary>
            /// 轮巡解码通道信息
            /// </summary>
            public NET_DVR_DEV_CHAN_INFO_SCENE struDecChanInfo;
        }

        /// <summary>
        /// 轮巡解码结构
        /// </summary>
        //轮巡解码结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_LOOP_DECINFO_SCENE
        {
            /// <summary>
            /// 轮询间隔
            /// </summary>
            public ushort wPoolTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CYCLE_CHAN, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CYC_SUR_CHAN_ELE_SCENE[] struChanArray;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_BIGSCREENCFG_SCENE
        {
            /// <summary>
            /// 漫游使能标志
            /// </summary>
            public byte byAllValid;
            /// <summary>
            /// 关联的底图序号，0代表不关联
            /// </summary>
            public byte byAssociateBaseMap;
            /// <summary>
            /// 大屏畅显使能，1-开，0-关
            /// </summary>
            public byte byEnableSpartan;
            public byte byRes;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LAYERNUMS, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_WINCFG[] struWinCfg;
            public NET_DVR_BIGSCREENCFG struBigScreen;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_SCENECFG
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sSceneName;
            /// <summary>
            /// 大屏的个数，最大值通过能力集获取
            /// </summary>
            public byte byBigScreenNums;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 场景中解码通道的个数
            /// </summary>
            public ushort wDecChanNums;
            /// <summary>
            /// 场景中显示通道的个数
            /// </summary>
            public ushort wDispChanNums;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 大屏配置缓冲区, byBigScreenNums×sizeof(NET_DVR_BIGSCREENCFG_SCENE)
            /// </summary>
            public IntPtr pBigScreenBuffer;
            /// <summary>
            /// 解码通道配置缓冲区, wDecChanNums×sizeof(NET_DVR_DECODECHANCFG_SCENE)
            /// </summary>
            public IntPtr pDecChanBuffer;
            /// <summary>
            /// 显示通道配置缓冲区, wDispChanNums×sizeof(NET_DVR_SCENEDISPCFG)
            /// </summary>
            public IntPtr pDispChanBuffer;
        }
        /// <summary>
        /// 窗口参数获取
        /// </summary>
        public const int NET_DVR_GET_ALLWINCFG = 1503;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_BIGSCREENASSOCIATECFG
        {
            public uint dwSize;
            /// <summary>
            /// 使能底图显示
            /// </summary>
            public byte byEnableBaseMap;
            /// <summary>
            /// 关联的底图序号，0代表不关联
            /// </summary>
            public byte byAssociateBaseMap;
            /// <summary>
            /// 大屏畅显使能，1-开，0-关
            /// </summary>
            public byte byEnableSpartan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 21, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// *****************************窗口设置******************************
        /// </summary>
        public const int MAX_WIN_COUNT = 224;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCREEN_WINCFG
        {
            public uint dwSize;
            public byte byVaild;
            /// <summary>
            /// 见CAM_MDOE
            /// </summary>
            public byte byInputType;
            /// <summary>
            /// 输入源索引
            /// </summary>
            public ushort wInputIdx;
            /// <summary>
            /// 图层，0为最底层
            /// </summary>
            public uint dwLayerIdx;
            /// <summary>
            /// 目的窗口(相对显示墙)
            /// </summary>
            public NET_DVR_RECTCFG struWin;
            /// <summary>
            /// 窗口号
            /// </summary>
            public byte byWndIndex;
            /// <summary>
            /// 0-无，1-带背景，2-不带背景
            /// </summary>
            public byte byCBD;
            /// <summary>
            /// 0不是，1是
            /// </summary>
            public byte bySubWnd;
            public byte byRes1;
            /// <summary>
            /// 设备序号
            /// </summary>
            public uint dwDeviceIndex;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_WINLIST
        {
            public uint dwSize;
            /// <summary>
            /// 设备序号
            /// </summary>
            public ushort wScreenSeq;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 10, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 设备返回的窗口数量
            /// </summary>
            public uint dwWinNum;
            /// <summary>
            /// 窗口信息缓冲区，最大为224*sizeof(NET_DVR_WINCFG)
            /// </summary>
            public IntPtr pBuffer;
            /// <summary>
            /// 所分配指针长度
            /// </summary>
            public uint dwBufLen;
        }
        /// <summary>
        /// 最大布局数
        /// </summary>
        public const int MAX_LAYOUT_COUNT = 16;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LAYOUTCFG
        {
            public uint dwSize;
            /// <summary>
            /// 布局是否有效
            /// </summary>
            public byte byValid;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 布局名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byLayoutName;
            /// <summary>
            /// 布局内窗口参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_WIN_COUNT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCREEN_WINCFG[] struWinCfg;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LAYOUT_LIST
        {
            public uint dwSize;
            /// <summary>
            /// 所有布局
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LAYOUT_COUNT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_LAYOUTCFG[] struLayoutInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        public const int MAX_CAM_COUNT = 224;

        public enum NET_DVR_CAM_MODE
        {
            /// <summary>
            /// 无效
            /// </summary>
            NET_DVR_UNKNOW = 0,
            NET_DVR_CAM_BNC,
            NET_DVR_CAM_VGA,
            NET_DVR_CAM_DVI,
            NET_DVR_CAM_HDMI,
            NET_DVR_CAM_IP,
            NET_DVR_CAM_RGB,
            NET_DVR_CAM_DECODER,
            NET_DVR_CAM_MATRIX,
            NET_DVR_CAM_YPBPR,
            NET_DVR_CAM_USB
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INPUTSTREAMCFG
        {
            public uint dwSize;
            public byte byValid;
            /// <summary>
            /// 信号输入源类型，见NET_DVR_CAM_MODE
            /// </summary>
            public byte byCamMode;
            /// <summary>
            /// 信号源序号0-224
            /// </summary>
            public ushort wInputNo;
            /// <summary>
            /// 信号输入源名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sCamName;
            /// <summary>
            /// 视频参数
            /// </summary>
            public NET_DVR_VIDEOEFFECT struVideoEffect;
            /// <summary>
            /// ip输入时使用
            /// </summary>
            public NET_DVR_PU_STREAM_CFG struPuStream;
            /// <summary>
            /// 信号源所在的板卡号
            /// </summary>
            public ushort wBoardNum;
            /// <summary>
            /// 信号源在板卡上的位置
            /// </summary>
            public ushort wInputIdxOnBoard;
            /// <summary>
            /// 分辨率
            /// </summary>
            public ushort wResolutionX;
            public ushort wResolutionY;
            /// <summary>
            /// 视频制式，0-无，1-NTSC，2-PAL
            /// </summary>
            public byte byVideoFormat;
            /// <summary>
            /// ; 1-CIF 2-4CIF 3-720P 4-1080P 5-500wp 。网络信号源的分辨率，在添加网络信号源时传给设备，设备根据这个分辨率来分配解码资源。
            /// </summary>
            public byte byNetSignalResolution;
            /// <summary>
            /// 网络信号源分组 组名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sGroupName;
            /// <summary>
            /// 关联矩阵 ，0-不关联  1-关联
            /// </summary>
            public byte byJointMatrix;
            public byte byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INPUTSTREAM_LIST
        {
            public uint dwSize;
            /// <summary>
            /// 所有信号源
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CAM_COUNT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_INPUTSTREAMCFG[] struInputStreamInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// *****************************输出参数配置******************************
        /// 输出通道管理
        /// </summary>
        /*******************************输出参数配置*******************************/
        /*输出通道管理*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_OUTPUTPARAM
        {
            public uint dwSize;
            /// <summary>
            /// 输出连接模式,1-BNC,2-VGA,3-DVI,4-HDMI
            /// </summary>
            public byte byMonMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 分辨率，根据能力集获取所支持的进行设置
            /// </summary>
            public uint dwResolution;
            /// <summary>
            /// 输出通道视频参数配置
            /// </summary>
            public NET_DVR_VIDEOEFFECT struVideoEffect;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_OUTPUTCFG
        {
            public uint dwSize;
            /// <summary>
            /// 大屏布局-横坐标
            /// </summary>
            public byte byScreenLayX;
            /// <summary>
            /// 大屏布局-纵坐标
            /// </summary>
            public byte byScreenLayY;
            /// <summary>
            /// 输出通道个数，0表示设备支持的最大输出通道个数，最大个数从能力集获取，其他值表示实际输出通道个数
            /// </summary>
            public ushort wOutputChanNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 输出通道视频参数配置
            /// </summary>
            public NET_DVR_OUTPUTPARAM struOutputParam;
            /// <summary>
            /// 电视墙名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] sWallName;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        /// <summary>
        /// *****************************能力集******************************
        /// </summary>
        public const int SCREEN_PROTOCOL_NUM = 20;

        /// <summary>
        /// 多屏服务器能力集
        /// </summary>
        //多屏服务器能力集
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCREENSERVER_ABILITY
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 所支持大屏控制器的数目
            /// </summary>
            public byte byIsSupportScreenNum;
            /// <summary>
            /// 串口个数
            /// </summary>
            public byte bySerialNums;
            public byte byMaxInputNums;
            public byte byMaxLayoutNums;
            public byte byMaxWinNums;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 19, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 大屏布局-最大横坐标大屏数
            /// </summary>
            public byte byMaxScreenLayX;
            /// <summary>
            /// 大屏布局-最大纵坐标大屏数
            /// </summary>
            public byte byMaxScreenLayY;
            /// <summary>
            /// 有效的大屏协议数目
            /// </summary>
            public ushort wMatrixProtoNum;
            /// <summary>
            /// 最大协议列表
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SCREEN_PROTOCOL_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_PROTO_TYPE[] struScreenProto;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 多屏控制器能力集
        /// </summary>
        //多屏控制器能力集
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCREENCONTROL_ABILITY
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 布局个数
            /// </summary>
            public byte byLayoutNum;
            /// <summary>
            /// 屏幕窗口个数
            /// </summary>
            public byte byWinNum;
            /// <summary>
            /// OSD个数
            /// </summary>
            public byte byOsdNum;
            /// <summary>
            /// Logo个数
            /// </summary>
            public byte byLogoNum;
            /// <summary>
            /// 输入源个数 ---设备支持最大输入通道个数（包括本地输入源和网络输入源）
            /// </summary>
            public byte byInputStreamNum;
            /// <summary>
            /// 输出通道个数---设备支持最大输出通道个数
            /// </summary>
            public byte byOutputChanNum;
            /// <summary>
            /// 分组个数
            /// </summary>
            public byte byCamGroupNum;
            /// <summary>
            /// 预案个数
            /// </summary>
            public byte byPlanNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 是否支持回放
            /// </summary>
            public byte byIsSupportPlayBack;
            /// <summary>
            /// 支持输入矩阵最大个数
            /// </summary>
            public byte byMatrixInputNum;
            /// <summary>
            /// 支持输出矩阵最大个数
            /// </summary>
            public byte byMatrixOutputNum;
            /// <summary>
            /// VGA输出信息
            /// </summary>
            public NET_DVR_DISPINFO struVgaInfo;
            /// <summary>
            /// BNC输出信息
            /// </summary>
            public NET_DVR_DISPINFO struBncInfo;
            /// <summary>
            /// HDMI输出信息
            /// </summary>
            public NET_DVR_DISPINFO struHdmiInfo;
            /// <summary>
            /// DVI输出信息
            /// </summary>
            public NET_DVR_DISPINFO struDviInfo;
            /// <summary>
            /// 支持用户数
            /// </summary>
            public byte byMaxUserNums;
            /// <summary>
            /// 底图跨度，一张底图最多可覆盖的屏幕数
            /// </summary>
            public byte byPicSpan;
            /// <summary>
            /// 分布式大屏控制器最大设备数
            /// </summary>
            public ushort wDVCSDevNum;
            /// <summary>
            /// 最大网络输入源个数
            /// </summary>
            public ushort wNetSignalNum;
            /// <summary>
            /// 基准坐标
            /// </summary>
            public ushort wBaseCoordinateX;
            public ushort wBaseCoordinateY;
            /// <summary>
            /// 最大外接矩阵个数
            /// </summary>
            public byte byExternalMatrixNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 49, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// *****************************输入信号状态******************************
        /// </summary>
        /*******************************输入信号状态*******************************/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ANALOGINPUTSTATUS
        {
            /// <summary>
            /// 视频输入丢帧数
            /// </summary>
            public uint dwLostFrame;
            /// <summary>
            /// 是否有视频信号输入
            /// </summary>
            public byte byHaveSignal;
            /// <summary>
            /// 视频制式，1：NTSC,2：PAL,0：无
            /// </summary>
            public byte byVideoFormat;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 46, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_DVR_INPUTSTATUS_UNION
        {
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 52, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INPUTSTATUS
        {
            /// <summary>
            /// 信号源序号
            /// </summary>
            public ushort wInputNo;
            /// <summary>
            /// 见NET_DVR_CAM_MODE
            /// </summary>
            public byte byInputType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 9, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public NET_DVR_INPUTSTATUS_UNION struStatusUnion;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCREENINPUTSTATUS
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 设备返回的输入源状态的数量
            /// </summary>
            public uint dwNums;
            /// <summary>
            /// 缓冲区
            /// </summary>
            public IntPtr pBuffer;
            /// <summary>
            /// 所分配指针长度，输入参数
            /// </summary>
            public uint dwBufLen;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCREENALARMCFG
        {
            public uint dwSize;
            /// <summary>
            /// 报警类型，1-子板拔出，2-子板插入，3-子系统状态异常，4-子系统恢复恢复 5-输入源异常   6-温度报警 7-FPGA版本不匹配 8-预案开始 9-预案结束 10-解码板断网 11-解码板IP地址冲突，12-风扇异常
            /// </summary>
            public byte byAlarmType;
            /// <summary>
            /// 1-输入板 2-输出板 ，3-主板，4-背板，报警类型为1，2，3，6的时候使用
            /// </summary>
            public byte byBoardType;
            /// <summary>
            /// 输入异常时具体子异常 1- 分辨率正常改变 2-输入端口类型改变3-分辨率错误4-分辨率改变导致解码资源不足，关闭该输入源对应窗口。5-分辨率改变，导致已开窗的缩放比例不在1/8到8倍范围。6-分辨率恢复正常,7-分辨率改变导致输出板数据量超限,设备关闭窗口
            /// </summary>
            public byte bySubException;
            public byte byRes1;
            /// <summary>
            /// 异常输入源（异常起点）
            /// </summary>
            public ushort wStartInputNum;
            /// <summary>
            /// 异常输入源（异常终点）
            /// </summary>
            public ushort wEndInputNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MATRIX_CFG
        {
            /// <summary>
            /// 判断是否是模拟矩阵（是否有效）
            /// </summary>
            public byte byValid;
            /// <summary>
            /// 模拟矩阵的指令（4种）
            /// </summary>
            public byte byCommandProtocol;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byScreenType;
            public byte byRes1;
            /// <summary>
            /// 模拟矩阵的输出与屏幕的对应关系
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byScreenToMatrix;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DIGITALSCREEN
        {
            /// <summary>
            /// 设备为数字设备时的IP信息
            /// </summary>
            public NET_DVR_IPADDR struAddress;
            /// <summary>
            /// 通道号
            /// </summary>
            public ushort wPort;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 26, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ANALOGSCREEN
        {
            /// <summary>
            /// 连接设备的串口号
            /// </summary>
            public byte byDevSerPortNum;
            /// <summary>
            /// 连接大屏的串口号
            /// </summary>
            public byte byScreenSerPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 130, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public NET_DVR_MATRIX_CFG struMatrixCfg;
        }

        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_DVR_SCREEN_UNION
        {
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 172, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCREEN_SCREENINFO
        {
            public uint dwSize;
            /// <summary>
            /// 是否有效
            /// </summary>
            public byte byValid;
            /// <summary>
            /// 连接方式，0-串口，1-网口
            /// </summary>
            public byte nLinkMode;
            /// <summary>
            /// 设备型号，能力集获取
            /// </summary>
            public byte byDeviceType;
            /// <summary>
            /// 大屏布局-横坐标
            /// </summary>
            public byte byScreenLayX;
            /// <summary>
            /// 大屏布局-纵坐标
            /// </summary>
            public byte byScreenLayY;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 登录用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 登录密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PASSWD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPassword;
            /// <summary>
            /// 设备名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sDevName;
            public NET_DVR_SCREEN_UNION struScreenUnion;
            /// <summary>
            /// 输入源个数
            /// </summary>
            public byte byInputNum;
            /// <summary>
            /// 输出源个数
            /// </summary>
            public byte byOutputNum;
            /// <summary>
            /// CBD个数
            /// </summary>
            public byte byCBDNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 29, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// *****************************底图上传******************************
        /// </summary>
        /*******************************底图上传*******************************/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_BASEMAP_CFG
        {
            /// <summary>
            /// 屏幕的序号
            /// </summary>
            public byte byScreenIndex;
            /// <summary>
            /// 被分割成了多少块
            /// </summary>
            public byte byMapNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] res;
            /// <summary>
            /// 原图片的宽度
            /// </summary>
            public ushort wSourWidth;
            /// <summary>
            /// 原图片的高度
            /// </summary>
            public ushort wSourHeight;
        }
        /// <summary>
        /// *****************************OSD******************************
        /// </summary>
        public const int MAX_OSDCHAR_NUM = 256;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_OSDCFG
        {
            public uint dwSize;
            /// <summary>
            /// 是否有效 0无效 1有效
            /// </summary>
            public byte byValid;
            /// <summary>
            /// 显示模式，1-透明，2-半透明，3-覆盖三种模式
            /// </summary>
            public byte byDispMode;
            /// <summary>
            /// 字体颜色Y,0-255
            /// </summary>
            public byte byFontColorY;
            /// <summary>
            /// 字体颜色U,0-255
            /// </summary>
            public byte byFontColorU;
            /// <summary>
            /// 字体颜色V,0-255
            /// </summary>
            public byte byFontColorV;
            /// <summary>
            /// 背景颜色Y,0-255
            /// </summary>
            public byte byBackColorY;
            /// <summary>
            /// 背景颜色U,0-255
            /// </summary>
            public byte byBackColorU;
            /// <summary>
            /// 背景颜色V,0-255
            /// </summary>
            public byte byBackColorV;
            /// <summary>
            /// OSD在屏幕左上角位置x
            /// </summary>
            public ushort wXCoordinate;
            /// <summary>
            /// OSD在屏幕左上角位置y
            /// </summary>
            public ushort wYCoordinate;
            /// <summary>
            /// OSD宽度
            /// </summary>
            public ushort wWidth;
            /// <summary>
            /// OSD高度
            /// </summary>
            public ushort wHeight;
            /// <summary>
            /// 字符的个数
            /// </summary>
            public uint dwCharCnt;
            /// <summary>
            /// OSD字符内容
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_OSDCHAR_NUM, ArraySubType = UnmanagedType.U2)]
            public ushort[] wOSDChar;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// *****************************获取串口信息******************************
        /// </summary>
        /*******************************获取串口信息*******************************/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SERIAL_CONTROL
        {
            public uint dwSize;
            /// <summary>
            /// 串口个数
            /// </summary>
            public byte bySerialNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] bySerial;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// *****************************屏幕控制******************************
        /// 屏幕输入源控制
        /// </summary>
        public enum INPUT_INTERFACE_TYPE
        {
            INTERFACE_VGA = 0,
            /// <summary>
            /// 2046NL不支持，2046NH支持
            /// </summary>
            INTERFACE_SVIDEO,
            INTERFACE_YPBPR,
            INTERFACE_DVI,
            INTERFACE_BNC,
            /// <summary>
            /// (环通) 2046NH不支持，2046NL支持
            /// </summary>
            INTERFACE_DVI_LOOP,
            /// <summary>
            /// (环通) 2046NH不支持，2046NL.支持
            /// </summary>
            INTERFACE_BNC_LOOP,
            INTERFACE_HDMI
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INPUT_INTERFACE_CTRL
        {
            /// <summary>
            /// 见INPUT_INTERFACE_TYPE
            /// </summary>
            public byte byInputSourceType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 15, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 显示单元颜色控制
        /// </summary>
        //显示单元颜色控制
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISPLAY_COLOR_CTRL
        {
            /// <summary>
            /// 1-亮度 2-对比度 3-饱和度 4-清晰度
            /// </summary>
            public byte byColorType;
            /// <summary>
            /// -1 、0、+1三个值
            /// </summary>
            public char byScale;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 14, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 显示单元位置控制
        /// </summary>
        //显示单元位置控制
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DISPLAY_POSITION_CTRL
        {
            /// <summary>
            /// 1-水平位置 2-垂直位置，
            /// </summary>
            public byte byPositionType;
            /// <summary>
            /// -1 、0、+1三个值
            /// </summary>
            public char byScale;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 14, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_DVR_SCREEN_CONTROL_PARAM
        {
            /// <summary>
            /// [FieldOffsetAttribute(0)]
            /// public NET_DVR_INPUT_INTERFACE_CTRL struInputCtrl;
            /// public NET_DVR_DISPLAY_COLOR_CTRL struDisplayCtrl;
            /// public NET_DVR_DISPLAY_POSITION_CTRL struPositionCtrl;
            /// </summary>
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCREEN_CONTROL
        {
            public uint dwSize;
            /// <summary>
            /// 控制方法 1-开 2-关 3-屏幕输入源选择 4-显示单元颜色控制 5-显示单元位置控制
            /// </summary>
            public uint dwCommand;
            /// <summary>
            /// 串口协议类型,1:LCD-S1,2:LCD-S2
            /// </summary>
            public byte byProtocol;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public NET_DVR_SCREEN_CONTROL_PARAM struControlParam;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 52, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// *****************************屏幕控制V41******************************
        /// </summary>
        /*******************************屏幕控制V41*******************************/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SCREEN_CONTROL_V41
        {
            public uint dwSize;
            /// <summary>
            /// 串口号
            /// </summary>
            public byte bySerialNo;
            /// <summary>
            /// 左上角屏幕号，从1开始
            /// </summary>
            public byte byBeginAddress;
            /// <summary>
            /// 右下角屏幕号，从1开始
            /// </summary>
            public byte byEndAddress;
            /// <summary>
            /// 串口协议类型  1-LCD-S1 , 2-LCD-S2 , 3-LCD-L1 ， 4-LCD-DLP， 5-LCD-S3 , 6-LCD-H1
            /// </summary>
            public byte byProtocol;
            /// <summary>
            /// 控制方法 1-开 2-关 3-屏幕输入源选择 4-显示单元颜色控制 5-显示单元位置控制
            /// </summary>
            public uint dwCommand;
            public NET_DVR_SCREEN_CONTROL_PARAM struControlParam;
            /// <summary>
            /// 电视墙号
            /// </summary>
            public byte byWallNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 51, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// *****************************预案管理******************************
        /// </summary>
        public const int MAX_PLAN_ACTION_NUM = 32;
        /// <summary>
        /// 一周7天
        /// </summary>
        public const int DAYS_A_WEEK = 7;
        /// <summary>
        /// 预案个数
        /// </summary>
        public const int MAX_PLAN_COUNT = 16;

        public enum NET_DVR_PLAN_OPERATE_TYPE
        {
            /// <summary>
            /// 布局切换 默认
            /// </summary>
            NET_DVR_SWITCH_LAYOUT = 1,
            /// <summary>
            /// 关闭大屏幕显示
            /// </summary>
            NET_DVR_SCREEN_POWER_OFF,
            /// <summary>
            /// 打开大屏幕显示
            /// </summary>
            NET_DVR_SCREEN_POWER_ON
        }

        /// <summary>
        /// 预案项信息
        /// </summary>
        /*预案项信息*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLAN_INFO
        {
            /// <summary>
            /// 该项是否有效
            /// </summary>
            public byte byValid;
            /// <summary>
            /// 见定义NET_DVR_PLAN_OPERATE_TYPE
            /// </summary>
            public byte byType;
            /// <summary>
            /// 布局号
            /// </summary>
            public ushort wLayoutNo;
            /// <summary>
            /// 屏幕型号，开关机所用，1是低亮，2是高亮
            /// </summary>
            public byte byScreenStyle;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 一个项的运行时间, 单位秒
            /// </summary>
            public uint dwDelayTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CYCLE_TIME
        {
            public byte byValid;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public NET_DVR_TIME_EX struTime;
        }

        /// <summary>
        /// 预案管理
        /// </summary>
        /*预案管理*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLAN_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 该预案是否有效
            /// </summary>
            public byte byValid;
            /// <summary>
            /// 预案工作模式 1表示手动，2自动，3预案循环
            /// </summary>
            public byte byWorkMode;
            /// <summary>
            /// 电视墙号，从1开始
            /// </summary>
            public byte byWallNo;
            public byte byRes1;
            /// <summary>
            /// 预案名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPlanName;
            /// <summary>
            /// 工作模式为自动时使用
            /// </summary>
            public NET_DVR_TIME_EX struTime;
            /// <summary>
            /// 循环时间，周期为一个星期，年、月、日三个参数不使用。如：struTimeCycle[0]中的byValid的值是1，表示星期天执行该预案。星期取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = DAYS_A_WEEK, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CYCLE_TIME[] struTimeCycle;
            /// <summary>
            /// 预案内容执行次数，0为一直循环播放，其他值表示次数
            /// </summary>
            public uint dwWorkCount;
            /// <summary>
            /// 预案执行的内容
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_PLAN_ACTION_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_PLAN_INFO[] strPlanEntry;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// *****************************获取设备状态******************************
        /// 预案列表
        /// </summary>
        /*******************************获取设备状态*******************************/
        /*预案列表*/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLAN_LIST
        {
            public uint dwSize;
            /// <summary>
            /// 设备输入信号源数量
            /// </summary>
            public uint dwPlanNums;
            /// <summary>
            /// 指向dwInputSignalNums个NET_DVR_PLAN_CFG结构大小的缓冲区
            /// </summary>
            public IntPtr pBuffer;
            /// <summary>
            /// 墙号，从1开始
            /// </summary>
            public byte byWallNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 所分配缓冲区长度，输入参数（大于等于dwInputSignalNums个NET_DVR_PLAN_CFG结构大小）
            /// </summary>
            public uint dwBufLen;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// *****************************预案控制******************************
        /// 该结构体可作为通用控制结构体
        /// </summary>
        /*******************************预案控制*******************************/
        //该结构体可作为通用控制结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CONTROL_PARAM
        {
            public uint dwSize;
            /// <summary>
            /// 被控设备的设备ID
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sDeviceID;
            /// <summary>
            /// 被控通道
            /// </summary>
            public ushort wChan;
            /// <summary>
            /// 控制索引，根据命令确定具体表示什么索引
            /// </summary>
            public byte byIndex;
            public byte byRes1;
            public uint dwControlParam;
            /// <summary>
            /// 1-使能  0-不使能
            /// </summary>
            public byte byMandatoryAlarm;
            public byte byRes2;
            /// <summary>
            /// 防区号
            /// </summary>
            public ushort wZoneIndex;
            /// <summary>
            /// 回控码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byOperatorCode;
            /// <summary>
            /// 4字节预案号，客户端统一使用4字节的预案号，单字节的预案号不再使用
            /// </summary>
            public uint dwPlanNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LOG_V50
        {
            /// <summary>
            /// 日志时间
            /// </summary>
            public NET_DVR_TIME_V50 strLogTime;
            /// <summary>
            /// 主类型
            /// </summary>
            public uint dwMajorType;
            /// <summary>
            /// 子类型
            /// </summary>
            public uint dwMinorType;
            /// <summary>
            /// 面板用户
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_NAMELEN)]
            public byte[] sPanelUser;
            /// <summary>
            /// 网络用户
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_NAMELEN)]
            public byte[] sNetUser;
            /// <summary>
            /// 远程主机地址
            /// </summary>
            public NET_DVR_IPADDR struRemoteHostAddr;
            /// <summary>
            /// 参数类型
            /// </summary>
            public uint dwParaType;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 磁盘号
            /// </summary>
            public uint dwDiskNumber;
            /// <summary>
            /// 报警输入端口
            /// </summary>
            public uint dwAlarmInPort;
            /// <summary>
            /// 报警输出端口
            /// </summary>
            public uint dwAlarmOutPort;
            /// <summary>
            /// 信息长度
            /// </summary>
            public uint dwInfoLen;
            /// <summary>
            /// 日志信息
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = LOG_INFO_LEN)]
            public byte[] sInfo;
            /// <summary>
            /// 保留字段
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
            public byte[] byRes;
        }

        /// <summary>
        /// *****************************获取设备状态******************************
        /// </summary>
        /*******************************获取设备状态*******************************/
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DEVICE_RUN_STATUS
        {
            public uint dwSize;
            /// <summary>
            /// 内存总量	单位Kbyte
            /// </summary>
            public uint dwMemoryTotal;
            /// <summary>
            /// 内存使用量 单位Kbyte
            /// </summary>
            public uint dwMemoryUsage;
            /// <summary>
            /// CPU使用率 0-100
            /// </summary>
            public byte byCPUUsage;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 127, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 91系列HD-SDI高清DVR 相机信息
        /// </summary>
        //91系列HD-SDI高清DVR 相机信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ACCESS_CAMERA_INFO
        {
            public uint dwSize;
            /// <summary>
            /// 前端相机信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string sCameraInfo;
            /// <summary>
            /// 前端接入接口类型，1:VGA, 2:HDMI, 3:YPbPr 4:SDI 5:FC
            /// </summary>
            public byte byInterfaceType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public uint dwChannel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AUDIO_INPUT_PARAM
        {
            /// <summary>
            /// 音频输入类型，0-mic in，1-line in
            /// </summary>
            public byte byAudioInputType;
            /// <summary>
            /// volume,[0-100]
            /// </summary>
            public byte byVolume;
            /// <summary>
            /// 是否开启声音过滤-关，-开
            /// </summary>
            public byte byEnableNoiseFilter;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.I1)]
            public byte[] byres;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CAMERA_DEHAZE_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 0-不启用，1-自动模式，2-开
            /// </summary>
            public byte byDehazeMode;
            /// <summary>
            /// 等级，0-100
            /// </summary>
            public byte byLevel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_INPUT_SIGNAL_LIST
        {
            public uint dwSize;
            /// <summary>
            /// 设备输入信号源数量
            /// </summary>
            public uint dwInputSignalNums;
            /// <summary>
            /// 指向dwInputSignalNums个NET_DVR_INPUTSTREAMCFG结构大小的缓冲区
            /// </summary>
            public IntPtr pBuffer;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 所分配缓冲区长度，输入参数（大于等于dwInputSignalNums个NET_DVR_INPUTSTREAMCFG结构大小）
            /// </summary>
            public uint dwBufLen;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        /// <summary>
        /// 安全拔盘状态
        /// </summary>
        public const int PULL_DISK_SUCCESS = 1;
        /// <summary>
        /// 安全拔盘失败
        /// </summary>
        public const int PULL_DISK_FAIL = 2;
        /// <summary>
        /// 正在停止阵列
        /// </summary>
        public const int PULL_DISK_PROCESSING = 3;
        /// <summary>
        /// 阵列不存在
        /// </summary>
        public const int PULL_DISK_NO_ARRAY = 4;
        /// <summary>
        /// 不支持安全拔盘
        /// </summary>
        public const int PULL_DISK_NOT_SUPPORT = 5;
        /// <summary>
        /// 扫描阵列状态
        /// </summary>
        public const int SCAN_RAID_SUC = 1;
        /// <summary>
        /// 扫描阵列失败
        /// </summary>
        public const int SCAN_RAID_FAIL = 2;
        /// <summary>
        /// 正在扫描阵列
        /// </summary>
        public const int SCAN_RAID_PROCESSING = 3;
        /// <summary>
        /// 不支持阵列扫描
        /// </summary>
        public const int SCAN_RAID_NOT_SUPPORT = 4;
        /// <summary>
        /// 设置前端相机类型状态
        /// </summary>
        public const int SET_CAMERA_TYPE_SUCCESS = 1;
        /// <summary>
        /// 失败
        /// </summary>
        public const int SET_CAMERA_TYPE_FAIL = 2;
        /// <summary>
        /// 正在处理
        /// </summary>
        public const int SET_CAMERA_TYPE_PROCESSING = 3;

        /// <summary>
        /// 9000 2.2
        /// </summary>
        //9000 2.2
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RECORD_TIME_SPAN_INQUIRY
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 0 正常音视频录像, 1图片通道录像, 2ANR通道录像, 3抽帧通道录像
            /// </summary>
            public byte byType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 63, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_RECORD_TIME_SPAN
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 开始时间
            /// </summary>
            public NET_DVR_TIME strBeginTime;
            /// <summary>
            /// 结束时间
            /// </summary>
            public NET_DVR_TIME strEndTime;
            /// <summary>
            /// 0 正常音视频录像, 1图片通道录像, 2ANR通道录像, 3抽帧通道录像
            /// </summary>
            public byte byType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 35, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DRAWFRAME_DISK_QUOTA_CFG
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 图片百分比	 [0%,  30%]
            /// </summary>
            public byte byPicQuota;
            /// <summary>
            /// 普通录像百分比 [20%, 40%]
            /// </summary>
            public byte byRecordQuota;
            /// <summary>
            /// 抽帧录像百分比 [30%, 80%]
            /// </summary>
            public byte byDrawFrameRecordQuota;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 61, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MANUAL_RECORD_PARA
        {
            public NET_DVR_STREAM_INFO struStreamInfo;
            public uint lRecordType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 端口映射配置结构体
        /// </summary>
        //端口映射配置结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_NAT_PORT
        {
            public ushort wEnable;
            public ushort wExtPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 端口映射配置结构体
        /// </summary>
        //端口映射配置结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_NAT_CFG
        {
            public uint dwSize;
            public ushort wEnableUpnp;
            public ushort wEnableNat;
            /// <summary>
            /// 夏时制停止时间
            /// </summary>
            public NET_DVR_IPADDR struIpAddr;
            /// <summary>
            /// 夏时制停止时间
            /// </summary>
            public NET_DVR_NAT_PORT struHttpPort;
            /// <summary>
            /// 夏时制停止时间
            /// </summary>
            public NET_DVR_NAT_PORT struCmdPort;
            /// <summary>
            /// 夏时制停止时间
            /// </summary>
            public NET_DVR_NAT_PORT struRtspPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byFriendName;
            public byte byNatType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 夏时制停止时间
            /// </summary>
            public NET_DVR_NAT_PORT struHttpsPort;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 76, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// Upnp端口映射状态结构体
        /// </summary>
        //Upnp端口映射状态结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_UPNP_PORT_STATE
        {
            /// <summary>
            /// 该端口是否被使能映射
            /// </summary>
            public uint dwEnabled;
            /// <summary>
            /// 映射前的端口
            /// </summary>
            public ushort wInternalPort;
            /// <summary>
            /// 映射后的端口
            /// </summary>
            public ushort wExternalPort;
            /// <summary>
            /// 端口映射状态：0- 未生效；1- 未生效：映射源端口与目的端口需一致；2- 未生效：映射端口号已被使用；3- 生效
            /// </summary>
            public uint dwStatus;
            /// <summary>
            /// 映射后的外部地址
            /// </summary>
            public NET_DVR_IPADDR struNatExternalIp;
            public NET_DVR_IPADDR struNatInternalIp;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// Upnp端口映射状态结构体
        /// </summary>
        //Upnp端口映射状态结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_UPNP_NAT_STATE
        {
            /// <summary>
            /// 端口映射状态:：数组0- web server端口，数组1- 管理端口，数组2- rtsp端
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_UPNP_PORT_STATE[] strUpnpPort;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 200, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLAYCOND
        {
            public uint dwChannel;
            public NET_DVR_TIME struStartTime;
            public NET_DVR_TIME struStopTime;
            /// <summary>
            /// 0:不抽帧，1：抽帧
            /// </summary>
            public byte byDrawFrame;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 63, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 录像回放结构体
        /// </summary>
        //录像回放结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VOD_PARA
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 流ID信息
            /// </summary>
            public NET_DVR_STREAM_INFO struIDInfo;
            /// <summary>
            /// 回放开始时间
            /// </summary>
            public NET_DVR_TIME struBeginTime;
            /// <summary>
            /// 回放结束时间
            /// </summary>
            public NET_DVR_TIME struEndTime;
            /// <summary>
            /// 回放窗口
            /// </summary>
            public IntPtr hWnd;
            /// <summary>
            /// 是否抽帧：0- 不抽帧，1- 抽帧
            /// </summary>
            public byte byDrawFrame;
            /// <summary>
            /// 0-普通录像卷，1-存档卷，适用于CVR设备，普通卷用于通道录像，存档卷用于备份录像
            /// </summary>
            public byte byVolumeType;
            /// <summary>
            /// 存档卷号
            /// </summary>
            public byte byVolumeNum;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// 存档卷上的录像文件索引，搜索存档卷录像时返回的值
            /// </summary>
            public uint dwFileIndex;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ATMFINDINFO
        {
            /// <summary>
            /// 交易类型 0-全部，1-查询， 2-取款， 3-存款， 4-修改密码，5-转账， 6-无卡查询 7-无卡存款， 8-吞钞 9-吞卡 10-自定义
            /// </summary>
            public byte byTransactionType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 交易金额 ;
            /// </summary>
            public uint dwTransationAmount;
        }

        [StructLayoutAttribute(LayoutKind.Explicit)]
        public struct NET_DVR_SPECIAL_FINDINFO_UNION
        {
            [FieldOffsetAttribute(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byLenth;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FILECOND_V40
        {
            public Int32 lChannel;
            public uint dwFileType;
            public uint dwIsLocked;
            public uint dwUseCardNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = CARDNUM_LEN_OUT, ArraySubType = UnmanagedType.I1)]
            public byte[] sCardNumber;
            public NET_DVR_TIME struStartTime;
            public NET_DVR_TIME struStopTime;
            /// <summary>
            /// 0:不抽帧，1：抽帧
            /// </summary>
            public byte byDrawFrame;
            /// <summary>
            /// 0:查询普通卷，1：查询存档卷
            /// </summary>
            public byte byFindType;
            /// <summary>
            /// 0:普通查询，1：快速（日历）查询
            /// </summary>
            public byte byQuickSearch;
            /// <summary>
            /// 专有查询条件类型 0-无效， 1-带ATM查询条件
            /// </summary>
            public byte bySpecialFindInfoType;
            /// <summary>
            /// 存档卷号
            /// </summary>
            public uint dwVolumeNum;
            /// <summary>
            /// 工作机GUID，通过获取N+1得到
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = GUID_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byWorkingDeviceGUID;
            /// <summary>
            /// 专有查询条件
            /// </summary>
            public NET_DVR_SPECIAL_FINDINFO_UNION uSpecialFindInfo;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 事件搜索条件
        /// </summary>
        //事件搜索条件
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SEARCH_EVENT_PARAM_V40
        {
            /// <summary>
            /// 0-移动侦测，1-报警输入, 2-智能事件 5-pos录像 7-门禁事件
            /// </summary>
            public ushort wMajorType;
            /// <summary>
            /// 搜索次类型- 根据主类型变化，0xffff表示全部
            /// </summary>
            public ushort wMinorType;
            /// <summary>
            /// 搜索的开始时间，停止时间: 同时为(0, 0) 表示从最早的时间开始，到最后，最前面的4000个事件
            /// </summary>
            public NET_DVR_TIME struStartTime;
            public NET_DVR_TIME struEndTime;
            /// <summary>
            /// 0xff-全部，0-未锁，1-锁定
            /// </summary>
            public byte byLockType;
            /// <summary>
            /// 是否启用快速查询，0-不启用，1-启用（快速查询不会返回文件大小，仅对设备数据库进行查询，避免频繁唤醒硬盘）
            /// </summary>
            public byte byQuickSearch;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 130, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public UNION_EVENT_PARAM uSeniorParam;
        }
        public const int SEARCH_EVENT_INFO_LEN_V40 = 800;

        [StructLayout(LayoutKind.Explicit)]
        public struct UNION_EVENT_PARAM
        {
            [FieldOffset(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SEARCH_EVENT_INFO_LEN_V40, ArraySubType = UnmanagedType.I1)]
            public byte[] byLen;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct struMotionParam
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.U2)]
            public ushort[] wMotDetChanNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 672, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct struStreamIDParam
        {
            public NET_DVR_STREAM_INFO struIDInfo;
            public uint dwCmdType;
            public byte byBackupVolumeNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byArchiveLabel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 656, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 查找返回结果
        /// </summary>
        //查找返回结果
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SEARCH_EVENT_RET_V40
        {
            /// <summary>
            /// 主类型
            /// </summary>
            public ushort wMajorType;
            /// <summary>
            /// 次类型
            /// </summary>
            public ushort wMinorType;
            /// <summary>
            /// 事件开始的时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 事件停止的时间，脉冲事件时和开始时间一样
            /// </summary>
            public NET_DVR_TIME struEndTime;
            /// <summary>
            /// 触发的通道号，0xffff表示后续无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V40, ArraySubType = UnmanagedType.U2)]
            public ushort[] wChan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 36, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            public UNION_EVENT_RET uSeniorRet;
        }

        [StructLayout(LayoutKind.Explicit)]
        public struct UNION_EVENT_RET
        {
            [FieldOffset(0)]
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 800, ArraySubType = UnmanagedType.I1)]
            public byte[] byLen;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct struMotionRet
        {
            public uint dwMotDetNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 796, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 磁带编号最大长度
        /// </summary>
        public const int NET_SDK_MAX_TAPE_INDEX_LEN = 32;
        /// <summary>
        /// 文件名最大长度
        /// </summary>
        public const int NET_SDK_MAX_FILE_LEN = 256;

        /// <summary>
        /// 流id录像查询结果
        /// </summary>
        //流id录像查询结果
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct struStreamIDRet
        {
            /// <summary>
            /// 录像类型 0-定时录像 1-移动侦测 2-报警录像 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像 7-震动报警 8-环境触发 9-智能报警 10-回传录像
            /// </summary>
            public uint dwRecordType;
            /// <summary>
            /// 录像大小
            /// </summary>
            public uint dwRecordLength;
            /// <summary>
            /// 锁定标志 0：没锁定 1：锁定
            /// </summary>
            public byte byLockFlag;
            /// <summary>
            /// 0：非抽帧录像 1：抽帧录像
            /// </summary>
            public byte byDrawFrameType;
            /// <summary>
            /// 文件所在存储位置：0-阵列上，1-带库机位上，可以直接下载，2-磁带库内，需要把磁盘切换到机位上，3-不在磁带库中，需要把磁盘插到磁带库中
            /// </summary>
            public byte byPosition;
            public byte byRes1;
            /// <summary>
            /// 文件名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byFileName;
            /// <summary>
            /// 存档卷上的文件索引
            /// </summary>
            public uint dwFileIndex;
            /// <summary>
            /// 文件所在磁带编号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_SDK_MAX_TAPE_INDEX_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byTapeIndex;
            /// <summary>
            /// 文件名扩展
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_SDK_MAX_FILE_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byFileNameEx;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 464, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_AES_KEY_INFO
        {
            /// <summary>
            /// 码流加密密钥
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] sAESKey;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_POE_CFG
        {
            /// <summary>
            /// IP地址
            /// </summary>
            public NET_DVR_IPADDR struIP;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 最大协议路径长度
        /// </summary>
        public const int MAX_PRO_PATH = 256;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CUSTOM_PROTOCAL
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 是否启用该协议0 不启用 1 启用
            /// </summary>
            public uint dwEnabled;
            /// <summary>
            /// 自定义协议名称, 16位
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = DESC_LEN)]
            public string sProtocalName;
            /// <summary>
            /// 保留,用于协议名称扩展
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 子码流是否启用0 不启用 1 启用
            /// </summary>
            public uint dwEnableSubStream;
            /// <summary>
            /// 主码流协议类型 1 RTSP
            /// </summary>
            public byte byMainProType;
            /// <summary>
            /// 主码流传输类型 0：Auto 1：udp 2：rtp over rtsp
            /// </summary>
            public byte byMainTransType;
            /// <summary>
            /// 主码流端口
            /// </summary>
            public ushort wMainPort;
            /// <summary>
            /// 主码流路径
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = MAX_PRO_PATH)]
            public string sMainPath;
            /// <summary>
            /// 子码流协议类型 1 RTSP
            /// </summary>
            public byte bySubProType;
            /// <summary>
            /// 子码流传输类型 0：Auto 1：udp 2：rtp over rtsp
            /// </summary>
            public byte bySubTransType;
            /// <summary>
            /// 子码流端口
            /// </summary>
            public ushort wSubPort;
            /// <summary>
            /// 子码流路径
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = MAX_PRO_PATH)]
            public string sSubPath;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 200, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 预览V40接口
        /// </summary>
        //预览V40接口
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PREVIEWINFO
        {
            /// <summary>
            /// 通道号
            /// </summary>
            public Int32 lChannel;
            /// <summary>
            /// 码流类型，0-主码流，1-子码流，2-码流3，3-码流4 等以此类推
            /// </summary>
            public uint dwStreamType;
            /// <summary>
            /// 0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-RTP/RTSP,5-RSTP/HTTP
            /// </summary>
            public uint dwLinkMode;
            /// <summary>
            /// 播放窗口的句柄,为NULL表示不播放图象
            /// </summary>
            public IntPtr hPlayWnd;
            /// <summary>
            /// 0-非阻塞取流, 1-阻塞取流, 如果阻塞SDK内部connect失败将会有5s的超时才能够返回,不适合于轮询取流操作.
            /// </summary>
            public bool bBlocked;
            /// <summary>
            /// 0-不启用录像回传,1启用录像回传
            /// </summary>
            public bool bPassbackRecord;
            /// <summary>
            /// 预览模式，0-正常预览，1-延迟预览
            /// </summary>
            public byte byPreviewMode;
            /// <summary>
            /// 流ID，lChannel为0xffffffff时启用此参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = STREAM_ID_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byStreamID;
            /// <summary>
            /// 应用层取流协议，0-私有协议，1-RTSP协议
            /// </summary>
            public byte byProtoType;
            public byte byRes1;
            /// <summary>
            /// 码流数据编解码类型 0-通用编码数据 1-热成像探测器产生的原始数据（温度数据的加密信息，通过去加密运算，将原始数据算出真实的温度值）
            /// </summary>
            public byte byVideoCodingType;
            /// <summary>
            /// 播放库播放缓冲区最大缓冲帧数，范围1-50，置0时默认为1
            /// </summary>
            public uint dwDisplayBufNum;
            /// <summary>
            /// NPQ是直连模式，还是过流媒体 0-直连 1-过流媒体
            /// </summary>
            public byte byNPQMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 215, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// 抓拍机
        /// ///
        /// </summary>
        public const int MAX_OVERLAP_ITEM_NUM = 50;
        /// <summary>
        /// 获取字符叠加参数配置（相机或ITS终端）
        /// </summary>
        public const int NET_ITS_GET_OVERLAP_CFG = 5072;
        /// <summary>
        /// 设置字符叠加参数配置（相机或ITS终端）
        /// </summary>
        public const int NET_ITS_SET_OVERLAP_CFG = 5073;
        /// <summary>
        /// 设置外控配置参数
        /// </summary>
        public const int NET_ITS_SET_LAMP_EXTERNAL_CFG = 5095;

        /// <summary>
        /// 字符叠加配置条件参数结构体
        /// </summary>
        //字符叠加配置条件参数结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITS_OVERLAPCFG_COND
        {
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 配置模式：0- 终端，1- 前端(直连前端或终端接前端)
            /// </summary>
            public uint dwConfigMode;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 单条字符叠加信息结构体
        /// </summary>
        //单条字符叠加信息结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITS_OVERLAP_SINGLE_ITEM_PARAM
        {
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 类型
            /// </summary>
            public byte byItemType;
            /// <summary>
            /// 叠加项后的换行数，取值范围：[0,10]，默认：0
            /// </summary>
            public byte byChangeLineNum;
            /// <summary>
            /// 叠加项后的空格数，取值范围：[0-255]，默认：0
            /// </summary>
            public byte bySpaceNum;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 15, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 字符串参数配置结构体
        /// </summary>
        //字符串参数配置结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITS_OVERLAP_ITEM_PARAM
        {
            /// <summary>
            /// 字符串内容信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_OVERLAP_ITEM_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_ITS_OVERLAP_SINGLE_ITEM_PARAM[] struSingleItem;
            public uint dwLinePercent;
            public uint dwItemsStlye;
            public ushort wStartPosTop;
            public ushort wStartPosLeft;
            public ushort wCharStyle;
            public ushort wCharSize;
            public ushort wCharInterval;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 前景色的RGB值，bit0~bit7: B，bit8~bit15: G，bit16~bit23: R，默认：x00FFFFFF-白
            /// </summary>
            public uint dwForeClorRGB;
            /// <summary>
            /// 背景色的RGB值，只对图片外叠加有效，bit0~bit7: B，bit8~bit15: G，bit16~bit23: R，默认：x00000000-黑
            /// </summary>
            public uint dwBackClorRGB;
            /// <summary>
            /// 颜色是否自适应：0-否，1-是
            /// </summary>
            public byte byColorAdapt;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 31, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 字符叠加内容信息结构体
        /// </summary>
        //字符叠加内容信息结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITS_OVERLAP_INFO_PARAM
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128, ArraySubType = UnmanagedType.I1)]
            public byte[] bySite;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRoadNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byInstrumentNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byDirection;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byDirectionDesc;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byLaneDes;
            /// <summary>
            /// 这里保留音频的压缩参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 44, ArraySubType = UnmanagedType.I1)]
            public byte[] byMonitoringSite1;
            /// <summary>
            /// 这里保留音频的压缩参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byMonitoringSite2;
            /// <summary>
            /// 这里保留音频的压缩参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 字符叠加配置条件参数结构体
        /// </summary>
        //字符叠加配置条件参数结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITS_OVERLAP_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 是否启用：0- 不启用，1- 启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 这里保留音频的压缩参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 字符串参数
            /// </summary>
            public NET_ITS_OVERLAP_ITEM_PARAM struOverLapItem;
            /// <summary>
            /// 字符串内容信息
            /// </summary>
            public NET_ITS_OVERLAP_INFO_PARAM struOverLapInfo;
            /// <summary>
            /// 这里保留音频的压缩参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 报警布防参数结构体
        /// </summary>
        //报警布防参数结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SETUPALARM_PARAM
        {
            public uint dwSize;
            /// <summary>
            /// 布防优先级：0- 一等级（高），1- 二等级（中），2- 三等级（低，保留）
            /// </summary>
            public byte byLevel;
            /// <summary>
            /// 上传报警信息类型（智能交通摄像机支持）：0- 老报警信息（NET_DVR_PLATE_RESULT），1- 新报警信息(NET_ITS_PLATE_RESULT)
            /// </summary>
            public byte byAlarmInfoType;
            public byte byRetAlarmTypeV40;
            public byte byRetDevInfoVersion;
            public byte byRetVQDAlarmType;
            public byte byFaceAlarmDetection;
            public byte bySupport;
            public byte byBrokenNetHttp;
            public ushort wTaskNo;
            /// <summary>
            /// 布防类型：0-客户端布防，1-实时布防
            /// </summary>
            public byte byDeployType;
            /// <summary>
            /// 订阅，按位表示，未开启订阅不上报  //占位 //Bit7-移动侦测人车分类是否传图；0-不传图(V30上报)，1-传图(V40上报)
            /// </summary>
            public byte bySubScription;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public byte byAlarmTypeURL;
            /// <summary>
            /// bit0-表示人脸抓拍报警上传（INTER_FACESNAP_RESULT）；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断,同时设备需要支持URL的相关服务，当前是”云存储“）
            /// bit1-表示EVENT_JSON中图片数据长传类型；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断）
            /// bit2 - 人脸比对(报警类型为COMM_SNAP_MATCH_ALARM)中图片数据上传类型：0 - 二进制传输，1 - URL传输
            /// bit3 - 异常行为识别(报警类型为COMM_ALARM_RULE)中图片数据上传类型：0 - 二进制传输，1 - URL传输，本字段设备是否支持，对应软硬件能力集中<isSupportBehaviorUploadByCloudStorageURL>节点是否返回且为true
            /// </summary>
            public byte byCustomCtrl;
        }

        /// <summary>
        /// 道闸控制参数
        /// </summary>
        //道闸控制参数
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_BARRIERGATE_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 通道号
            /// </summary>
            public uint dwChannel;
            /// <summary>
            /// 道闸号（0-表示无效值(设备需要做有效值判断),1-道闸1）
            /// </summary>
            public byte byLaneNo;
            /// <summary>
            /// 0-关闭道闸,1-开启道闸,2-停止道闸 3-锁定道闸,4~解锁道闸
            /// </summary>
            public byte byBarrierGateCtrl;
            /// <summary>
            /// 出入口编号 [1,8]
            /// </summary>
            public byte byEntranceNo;
            /// <summary>
            /// 启用解锁使能，0~为不启用，1~启用
            /// </summary>
            public byte byUnlock;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 12, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        public const int MAX_RELAY_NUM = 12;
        public const int MAX_IOIN_NUM = 8;
        public const int MAX_VEHICLE_TYPE_NUM = 8;
        /// <summary>
        /// 获取出入口控制参数
        /// </summary>
        public const int NET_DVR_GET_ENTRANCE_PARAMCFG = 3126;
        /// <summary>
        /// 设置出入口控制参数
        /// </summary>
        public const int NET_DVR_SET_ENTRANCE_PARAMCFG = 3127;

        /// <summary>
        /// 出入口控制条件
        /// </summary>
        //出入口控制条件
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_BARRIERGATE_COND
        {
            /// <summary>
            /// 车道号：0- 表示无效值(设备需要做有效值判断)，1- 车道1
            /// </summary>
            public byte byLaneNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 继电器关联配置
        /// </summary>
        //继电器关联配置
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_RELAY_PARAM
        {
            /// <summary>
            /// 0-不接入设备，1-开道闸、2-关道闸、3-停道闸、4-报警信号、5-常亮灯
            /// </summary>
            public byte byAccessDevInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 车辆信息管控参数
        /// </summary>
        //车辆信息管控参数
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_DVR_VEHICLE_CONTROL
        {
            /// <summary>
            /// 操作类型：0- 无操作，1- 开道闸
            /// </summary>
            public byte byGateOperateType;
            public byte byRes1;
            /// <summary>
            /// 报警处理类型：0- 无操作，bit0- 继电器输出报警，bit1- 布防上传报警，bit3- 告警主机上传，值：0-表示关，1-表示开，可复选
            /// </summary>
            public ushort wAlarmOperateType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        /// <summary>
        /// 出入口控制参数
        /// </summary>
        //出入口控制参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ENTRANCE_CFG
        {
            public uint dwSize;
            public byte byEnable;
            public byte byBarrierGateCtrlMode;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public uint dwRelateTriggerMode;
            public uint dwMatchContent;
            /// <summary>
            /// 继电器关联配置信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_RELAY_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_RELAY_PARAM[] struRelayRelateInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_IOIN_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byGateSingleIO;
            /// <summary>
            /// 车辆信息管控
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_VEHICLE_TYPE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_VEHICLE_CONTROL[] struVehicleCtrl;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITS_GATE_VEHICLE
        {
            public uint dwSize;
            public uint dwMatchNo;
            public byte byGroupNum;
            public byte byPicNo;
            public byte bySecondCam;
            public byte byRes;
            public ushort wLaneid;
            public byte byCamLaneId;
            public byte byRes1;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
            public byte[] byAlarmReason;
            public ushort wBackList;
            public ushort wSpeedLimit;
            public uint dwChanIndex;
            public NET_DVR_PLATE_INFO struPlateInfo;
            public NET_DVR_VEHICLE_INFO struVehicleInfo;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 48)]
            public byte[] byMonitoringSiteID;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 48)]
            public byte[] byDeviceID;
            public byte byDir;
            public byte byDetectType;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
            public byte[] byRes2;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 48)]
            public byte[] byCardNo;
            public uint dwPicNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.Struct)]
            public NET_ITS_PICTURE_INFO[] struPicInfo;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
            public byte[] bySwipeTime;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 224)]
            public byte[] byRes3;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITS_PICTURE_INFO
        {
            public uint dwDataLen;
            public byte byType;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]
            public byte[] byRes1;
            public uint dwRedLightTime;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
            public byte[] byAbsTime;
            public NET_VCA_RECT struPlateRect;
            public NET_VCA_RECT struPlateRecgRect;
            public IntPtr pBuffer;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 12)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITS_PLATE_RESULT
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 匹配序号,由(车辆序号,数据类型,车道号)组成匹配码
            /// </summary>
            public uint dwMatchNo;
            /// <summary>
            /// 图片组数量（一辆过车相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）
            /// </summary>
            public byte byGroupNum;
            /// <summary>
            /// 连拍的图片序号（接收到图片组数量后，表示接收完成;接收超时不足图片组数量时，根据需要保留或删除）
            /// </summary>
            public byte byPicNo;
            /// <summary>
            /// 是否第二相机抓拍（如远近景抓拍的远景相机，或前后抓拍的后相机，特殊项目中会用到）
            /// </summary>
            public byte bySecondCam;
            /// <summary>
            /// 闯红灯电警，取第几张图作为特写图,0xff-表示不取
            /// </summary>
            public byte byFeaturePicNo;
            /// <summary>
            /// 触发车道号
            /// </summary>
            public byte byDriveChan;
            /// <summary>
            /// 车辆类型，参考VTR_RESULT
            /// </summary>
            public byte byVehicleType;
            /// <summary>
            /// 检测场景号[1,4], IPC默认是0
            /// </summary>
            public byte byDetSceneID;
            /// <summary>
            /// 车辆属性，按位表示，0- 无附加属性(普通车)，bit1- 黄标车(类似年检的标志)，bit2- 危险品车辆，值：0- 否，1- 是
            /// 该节点已不再使用,使用下面的byYellowLabelCar和byDangerousVehicles判断是否黄标车和危险品车
            /// </summary>
            public byte byVehicleAttribute;
            /// <summary>
            /// 违章类型采用国标定义
            /// </summary>
            public ushort wIllegalType;
            /// <summary>
            /// 违章子类型
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byIllegalSubType;
            /// <summary>
            /// 违章时取第几张图片作为卡口图,0xff-表示不取
            /// </summary>
            public byte byPostPicNo;
            /// <summary>
            /// 通道号(有效，报警通道号和所在设备上传报警通道号一致，在后端和所接入的 通道号一致)
            /// </summary>
            public byte byChanIndex;
            /// <summary>
            /// 限速上限（超速时有效）
            /// </summary>
            public ushort wSpeedLimit;
            /// <summary>
            /// byChanIndexEx*256+byChanIndex表示真实通道号。
            /// </summary>
            public byte byChanIndexEx;
            public byte byRes2;
            /// <summary>
            /// 车牌信息结构
            /// </summary>
            public NET_DVR_PLATE_INFO struPlateInfo;
            /// <summary>
            /// 车辆信息
            /// </summary>
            public NET_DVR_VEHICLE_INFO struVehicleInfo;
            /// <summary>
            /// 显示点编号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 48, ArraySubType = UnmanagedType.I1)]
            public byte[] byMonitoringSiteID;
            /// <summary>
            /// 设备编号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 48, ArraySubType = UnmanagedType.I1)]
            public byte[] byDeviceID;
            /// <summary>
            /// 显示方向，1-上行（反向），2-下行(正向)，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南，8-其它
            /// </summary>
            public byte byDir;
            /// <summary>
            /// 检测方式,1-地感触发，2-视频触发，3-多帧识别，4-雷达触发
            /// </summary>
            public byte byDetectType;
            /// <summary>
            /// 关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
            /// 该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
            /// </summary>
            public byte byRelaLaneDirectionType;
            /// <summary>
            /// 车辆具体行驶的方向，0表示从上往下，1表示从下往上（根据实际车辆的行驶方向来的区分）
            /// </summary>
            public byte byCarDirectionType;
            /// <summary>
            /// 当wIllegalType参数为空时，使用该参数。若wIllegalType参数为有值时，以wIllegalType参数为准，该参数无效。
            /// </summary>
            public uint dwCustomIllegalType;
            /// <summary>
            /// 为0~数字格式时，为老的违章类型，wIllegalType、dwCustomIllegalType参数生效，赋值国标违法代码。
            /// 为1~字符格式时，pIllegalInfoBuf参数生效。老的违章类型，wIllegalType、dwCustomIllegalType参数依然赋值国标违法代码
            /// </summary>
            public IntPtr pIllegalInfoBuf;
            /// <summary>
            /// 违章信息格式类型； 0~数字格式， 1~字符格式
            /// </summary>
            public byte byIllegalFromatType;
            /// <summary>
            /// 0-表示未知,1-车窗有悬挂物，2-车窗无悬挂物
            /// </summary>
            public byte byPendant;
            /// <summary>
            /// 0-数据未分析, 1-数据已分析
            /// </summary>
            public byte byDataAnalysis;
            /// <summary>
            /// 0-表示未知, 1-非黄标车,2-黄标车
            /// </summary>
            public byte byYellowLabelCar;
            /// <summary>
            /// 0-表示未知, 1-非危险品车,2-危险品车
            /// </summary>
            public byte byDangerousVehicles;
            /// <summary>
            /// 以下字段包含Pilot字符均为主驾驶，含Copilot字符均为副驾驶
            /// </summary>
            public byte byPilotSafebelt;
            /// <summary>
            /// 0-表示未知,1-系安全带,2-不系安全带
            /// </summary>
            public byte byCopilotSafebelt;
            /// <summary>
            /// 0-表示未知,1-不打开遮阳板,2-打开遮阳板
            /// </summary>
            public byte byPilotSunVisor;
            /// <summary>
            /// 0-表示未知, 1-不打开遮阳板,2-打开遮阳板
            /// </summary>
            public byte byCopilotSunVisor;
            /// <summary>
            /// 0-表示未知, 1-不打电话,2-打电话
            /// </summary>
            public byte byPilotCall;
            /// <summary>
            /// 0-开闸，1-未开闸 (专用于历史数据中相机根据名单匹配后，是否开闸成功的标志)；当byAlarmDataType为0-实时数据时 0-未开闸 1-开闸
            /// </summary>
            public byte byBarrierGateCtrlType;
            /// <summary>
            /// 0-实时数据，1-历史数据
            /// </summary>
            public byte byAlarmDataType;
            /// <summary>
            /// 端点时间(ms)（抓拍第一张图片的时间）
            /// </summary>
            public NET_DVR_TIME_V30 struSnapFirstPicTime;
            /// <summary>
            /// 违法持续时间（ms） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
            /// </summary>
            public uint dwIllegalTime;
            /// <summary>
            /// 图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义
            /// </summary>
            public uint dwPicNum;
            /// <summary>
            /// 图片信息,单张回调，最多6张图，由序号区分
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 6, ArraySubType = UnmanagedType.Struct)]
            public NET_ITS_PICTURE_INFO[] struPicInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_ITS_PARK_VEHICLE
        {
            public uint dwSize;
            public byte byGroupNum;
            public byte byPicNo;
            public byte byLocationNum;
            public byte byParkError;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = MAX_PARKNO_LEN)]
            public string byParkingNo;
            public byte byLocationStatus;
            public byte bylogicalLaneNum;
            public ushort wUpLoadType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public uint dwChanIndex;
            public NET_DVR_PLATE_INFO struPlateInfo;
            public NET_DVR_VEHICLE_INFO struVehicleInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ID_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMonitoringSiteID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ID_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDeviceID;
            public uint dwPicNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.Struct)]
            public NET_ITS_PICTURE_INFO[] struPicInfo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct UNION_GATE_INFO
        {
            /// <summary>
            /// 当struAlarmType为(0x1车辆非法侵入报警)
            /// </summary>
            public UNION_GATE_VEHICLE struVehicleInfo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct UNION_GATE_VEHICLE
        {
            /// <summary>
            /// 车牌号码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LICENSE_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sLicense;
            /// <summary>
            /// 车辆类型0-保留 1-固定车，2-临时车，3-预订车，4-联检车，5-授权车
            /// </summary>
            public byte byVehicleType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 111, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_GATE_ALARMINFO
        {
            public uint dwSize;
            /// <summary>
            /// 0x1车辆非法侵入报警
            /// 0x2道闸超时未关报警
            /// 0x3车辆压线圈超时报警
            /// 0x4发卡报警（无卡）
            /// 0x5发卡报警（少卡）
            /// 0x6发卡报警（发卡异常）
            /// </summary>
            public byte byAlarmType;
            /// <summary>
            /// 外接设备类型(EXTERNAL_DEVICES_TYPE)
            /// </summary>
            public byte byExternalDevType;
            /// <summary>
            /// 外接设备类型(EXTERNAL_DEVICES_STATUS)
            /// </summary>
            public byte byExternalDevStatus;
            public byte byRes;
            /// <summary>
            /// 报警时间
            /// </summary>
            public NET_DVR_TIME_V30 struAlarmTime;
            public UNION_GATE_INFO uAlarmInfo;
            /// <summary>
            /// 预留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DIAGNOSIS_UPLOAD
        {
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = STREAM_ID_LEN)]
            public string sStreamID;
            /// <summary>
            /// < 流ID，长度小于32个字节
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 64)]
            public string sMonitorIP;
            /// <summary>
            /// < 布防点ip
            /// </summary>
            public uint dwChanIndex;
            /// <summary>
            /// < 布防点通道号
            /// </summary>
            public uint dwWidth;
            /// <summary>
            /// < 图像宽度
            /// </summary>
            public uint dwHeight;
            /// <summary>
            /// < 图像高度
            /// </summary>
            public NET_DVR_TIME struCheckTime;
            /// <summary>
            /// < 检测时间(合并日期和时间字段)，格式：2012-08-06 13:00:00
            /// </summary>
            public byte byResult;
            /// <summary>
            /// 0-未检测 1-正常 2-异常 3-登录失败 4-取流异常
            /// </summary>
            public byte bySignalResult;
            /// <summary>
            /// < 视频丢失检测结果 0-未检测 1-正常 2-异常
            /// </summary>
            public byte byBlurResult;
            /// <summary>
            /// < 图像模糊检测结果，0-未检测 1-正常 2-异常
            /// </summary>
            public byte byLumaResult;
            /// <summary>
            /// < 图像过亮检测结果，0-未检测 1-正常 2-异常
            /// </summary>
            public byte byChromaResult;
            /// <summary>
            /// < 偏色检测结果，0-未检测 1-正常 2-异常
            /// </summary>
            public byte bySnowResult;
            /// <summary>
            /// < 噪声干扰检测结果，0-未检测 1-正常 2-异常
            /// </summary>
            public byte byStreakResult;
            /// <summary>
            /// < 条纹干扰检测结果，0-未检测 1-正常 2-异常
            /// </summary>
            public byte byFreezeResult;
            /// <summary>
            /// < 画面冻结检测结果，0-未检测 1-正常 2-异常
            /// </summary>
            public byte byPTZResult;
            /// <summary>
            /// < 云台检测结果，0-未检测 1-正常 2-异常
            /// </summary>
            public byte byContrastResult;
            /// <summary>
            /// 黑白图像检测结果，0-未检测，1-正常，2-异常
            /// </summary>
            public byte byMonoResult;
            /// <summary>
            /// 视频抖动检测结果，0-未检测，1-正常，2-异常
            /// </summary>
            public byte byShakeResult;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string sSNapShotURL;
            /// <summary>
            /// <图片URL地址
            /// </summary>
            public byte byFlashResult;
            /// <summary>
            /// 视频遮挡检测结果，0-未检测，1-正常，2-异常
            /// </summary>
            public byte byCoverResult;
            /// <summary>
            /// 场景变更检测结果，0-未检测，1-正常，2-异常
            /// </summary>
            public byte bySceneResult;
            /// <summary>
            /// 图像过暗检测结果，0-未检测，1-正常，2-异常
            /// </summary>
            public byte byDarkResult;
            /// <summary>
            /// 码流类型，0-无效，1-未知，2-国标类型，3-非国标类型
            /// </summary>
            public byte byStreamType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 59, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        public const int CID_CODE_LEN = 4;
        public const int ACCOUNTNUM_LEN = 6;
        public const int ACCOUNTNUM_LEN_32 = 32;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CID_ALARM
        {
            public uint dwSize;
            /// <summary>
            /// CID事件号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = CID_CODE_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sCIDCode;
            /// <summary>
            /// CID事件名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sCIDDescribe;
            /// <summary>
            /// 触发报警的时间点
            /// </summary>
            public NET_DVR_TIME_EX struTriggerTime;
            /// <summary>
            /// 上传报警的时间点
            /// </summary>
            public NET_DVR_TIME_EX struUploadTime;
            /// <summary>
            /// 中心帐号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACCOUNTNUM_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sCenterAccount;
            /// <summary>
            /// 见定义NET_DVR_ALARMHOST_REPORT_TYPE
            /// </summary>
            public byte byReportType;
            /// <summary>
            /// 用户类型，0-网络用户 1-键盘用户,2-手机用户,3-系统用户
            /// </summary>
            public byte byUserType;
            /// <summary>
            /// 网络用户用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUserName;
            /// <summary>
            /// 键盘用户号    0xFFFF表示无效
            /// </summary>
            public ushort wKeyUserNo;
            /// <summary>
            /// 键盘号        0xFF表示无效
            /// </summary>
            public byte byKeypadNo;
            /// <summary>
            /// 子系统号        0xFF表示无效
            /// </summary>
            public byte bySubSysNo;
            /// <summary>
            /// 防区号        0xFFFF表示无效
            /// </summary>
            public ushort wDefenceNo;
            /// <summary>
            /// 视频通道号    0xFF表示无效
            /// </summary>
            public byte byVideoChanNo;
            /// <summary>
            /// 硬盘号        0xFF表示无效
            /// </summary>
            public byte byDiskNo;
            /// <summary>
            /// 模块地址        0xFFFF表示无效
            /// </summary>
            public ushort wModuleAddr;
            /// <summary>
            /// 0-无效, 1-中心账号(长度6),2-扩展的中心账号(长度9)
            /// </summary>
            public byte byCenterType;
            public byte byRes1;
            /// <summary>
            /// 中心账号V40,使用此字段时sCenterAccount无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACCOUNTNUM_LEN_32, ArraySubType = UnmanagedType.I1)]
            public byte[] sCenterAccountV40;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 28, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_PTZ_INFO
        {
            public float fPan;
            public float fTilt;
            public float fZoom;
            /// <summary>
            /// 聚焦参数，聚焦范围：归一化0-100000
            /// </summary>
            public uint dwFocus;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 火点检测报警
        /// </summary>
        //火点检测报警
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FIREDETECTION_ALARM
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 前端设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            public ushort wPanPos;
            public ushort wTiltPos;
            public ushort wZoomPos;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 报警抓拍图片长度
            /// </summary>
            public uint dwPicDataLen;
            /// <summary>
            /// 数据指针
            /// </summary>
            public IntPtr pBuffer;
            /// <summary>
            /// 火点框
            /// </summary>
            public NET_VCA_RECT struRect;
            /// <summary>
            /// 火点框内最高温度点坐标
            /// </summary>
            public NET_VCA_POINT struPoint;
            /// <summary>
            /// 火点最高温度[300℃~4000℃]
            /// </summary>
            public ushort wFireMaxTemperature;
            /// <summary>
            /// 目标距离[100m ~ 10000m]
            /// </summary>
            public ushort wTargetDistance;
            /// <summary>
            /// 策略类型；0~任意报警，1~协同报警，2~多系统报警，3~指定火点报警，4~指定烟雾报警
            /// </summary>
            public byte byStrategyType;
            /// <summary>
            /// 报警子类型。0~火点检测报警，1~烟雾检测报警，2~烟火报警
            /// </summary>
            public byte byAlarmSubType;
            /// <summary>
            /// 是否启用PTZ坐标扩展，
            /// 0~不启用，PTZ坐标值以wPanPos、wTiltPos、wZoomPos为准。
            /// 1~启用，PTZ坐标值以struPtzPosEx为准。但是新老PTZ都需返回。struPtzPosEx的值需转化为wPanPos、wTiltPos、wZoomPos值。
            /// </summary>
            public byte byPTZPosExEnable;
            public byte byRes2;
            /// <summary>
            /// ptz坐标扩展(支持高精度PTZ值，精确到小数点后三位)
            /// </summary>
            public NET_PTZ_INFO struPtzPosEx;
            /// <summary>
            /// 可见光图片长度
            /// </summary>
            public uint dwVisiblePicLen;
            /// <summary>
            /// 可见光图片数据指针
            /// </summary>
            public IntPtr pVisiblePicBuf;
            /// <summary>
            /// pSmokeBuf参数当byAlarmSubType报警子类型为1（烟雾检测报警）、2（烟火报警）时生效。
            /// </summary>
            public IntPtr pSmokeBuf;
            /// <summary>
            /// 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
            /// </summary>
            public ushort wDevInfoIvmsChannelEx;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 58, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ACS_EVENT_INFO
        {
            public uint dwSize;
            /// <summary>
            /// 卡号，为0无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCardNo;
            /// <summary>
            /// 卡类型，1-普通卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，为0无效
            /// </summary>
            public byte byCardType;
            /// <summary>
            /// 允许名单单号,1-8，为0无效
            /// </summary>
            public byte byAllowListNo;
            /// <summary>
            /// 报告上传通道，1-布防上传，2-中心组1上传，3-中心组2上传，为0无效
            /// </summary>
            public byte byReportChannel;
            /// <summary>
            /// 读卡器属于哪一类，0-无效，1-IC读卡器，2-身份证读卡器，3-二维码读卡器,4-指纹头
            /// </summary>
            public byte byCardReaderKind;
            /// <summary>
            /// 读卡器编号，为0无效
            /// </summary>
            public uint dwCardReaderNo;
            /// <summary>
            /// 门编号(楼层编号)，为0无效
            /// </summary>
            public uint dwDoorNo;
            /// <summary>
            /// 多重卡认证序号，为0无效
            /// </summary>
            public uint dwVerifyNo;
            /// <summary>
            /// 报警输入号，为0无效
            /// </summary>
            public uint dwAlarmInNo;
            /// <summary>
            /// 报警输出号，为0无效
            /// </summary>
            public uint dwAlarmOutNo;
            /// <summary>
            /// 事件触发器编号
            /// </summary>
            public uint dwCaseSensorNo;
            /// <summary>
            /// RS485通道号，为0无效
            /// </summary>
            public uint dwRs485No;
            /// <summary>
            /// 群组编号
            /// </summary>
            public uint dwMultiCardGroupNo;
            /// <summary>
            /// 人员通道号
            /// </summary>
            public ushort wAccessChannel;
            /// <summary>
            /// 设备编号，为0无效
            /// </summary>
            public byte byDeviceNo;
            /// <summary>
            /// 分控器编号，为0无效
            /// </summary>
            public byte byDistractControlNo;
            /// <summary>
            /// 工号，为0无效
            /// </summary>
            public uint dwEmployeeNo;
            /// <summary>
            /// 就地控制器编号，0-门禁主机，1-64代表就地控制器
            /// </summary>
            public ushort wLocalControllerID;
            /// <summary>
            /// 网口ID：（1-上行网口1,2-上行网口2,3-下行网口1）
            /// </summary>
            public byte byInternetAccess;
            /// <summary>
            /// 防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区 0xff-无
            /// </summary>
            public byte byType;
            /// <summary>
            /// 物理地址，为0无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMACAddr;
            /// <summary>
            /// 刷卡类型，0-无效，1-二维码
            /// </summary>
            public byte bySwipeCardType;
            /// <summary>
            /// 是否带口罩：0-保留，1-未知，2-不戴口罩，3-戴口罩
            /// </summary>
            public byte byMask;
            /// <summary>
            /// 事件流水号，为0无效
            /// </summary>
            public uint dwSerialNo;
            /// <summary>
            /// 通道控制器ID，为0无效，1-主通道控制器，2-从通道控制器
            /// </summary>
            public byte byChannelControllerID;
            /// <summary>
            /// 通道控制器灯板ID，为0无效（有效范围1-255）
            /// </summary>
            public byte byChannelControllerLampID;
            /// <summary>
            /// 通道控制器红外转接板ID，为0无效（有效范围1-255）
            /// </summary>
            public byte byChannelControllerIRAdaptorID;
            /// <summary>
            /// 通道控制器红外对射ID，为0无效（有效范围1-255）
            /// </summary>
            public byte byChannelControllerIREmitterID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ACS_EVENT_INFO_EXTEND
        {
            /// <summary>
            /// 事件流水号，为0无效（若该字段为0，平台根据dwSerialNo判断是否丢失事件；若该字段不为0，平台根据该字段和dwSerialNo字段共同判断是否丢失事件）（主要用于解决报警订阅后导致dwSerialNo不连续的情况）
            /// </summary>
            public int dwFrontSerialNo;
            /// <summary>
            /// 人员类型：0-无效，1-普通人（主人），2-来宾（访客），3-禁止名单人，4-管理员
            /// </summary>
            public byte byUserType;
            /// <summary>
            /// 读卡器当前验证方式：0-无效，1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码，5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码，10-人脸或指纹或刷卡或密码，11-人脸+指纹，12-人脸+密码，13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡，23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸，26-刷卡或人脸或指纹，27-刷卡或指纹或密码
            /// </summary>
            public byte byCurrentVerifyMode;
            /// <summary>
            /// 是否为实时事件：0-无效，1-是（实时事件），2-否（离线事件）
            /// </summary>
            public byte byCurrentEvent;
            /// <summary>
            /// 设备是否支持纯密码认证， 0-不支持，1-支持
            /// </summary>
            public byte byPurePwdVerifyEnable;
            /// <summary>
            /// 工号（人员ID）（对于设备来说，如果使用了工号（人员ID）字段，byEmployeeNo一定要传递，如果byEmployeeNo可转换为dwEmployeeNo，那么该字段也要传递；对于上层平台或客户端来说，优先解析byEmployeeNo字段，如该字段为空，再考虑解析dwEmployeeNo字段）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_SDK_EMPLOYEE_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byEmployeeNo;
            /// <summary>
            /// 考勤状态：0-未定义,1-上班，2-下班，3-开始休息，4-结束休息，5-开始加班，6-结束加班
            /// </summary>
            public byte byAttendanceStatus;
            /// <summary>
            /// 考勤状态值
            /// </summary>
            public byte byStatusValue;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// UUID（该字段仅在对接萤石平台过程中才会使用）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_SDK_UUID_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byUUID;
            /// <summary>
            /// 设备序列号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_DEV_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDeviceName;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 24, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 扩展结构体信息V20
        /// </summary>
        //扩展结构体信息V20
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ACS_EVENT_INFO_EXTEND_V20
        {
            /// <summary>
            /// 是否需要远程核验（0-无效，1-不需要（默认），2-需要）
            /// </summary>
            public byte byRemoteCheck;
            /// <summary>
            /// 测温单位（0-摄氏度（默认），1-华氏度，2-开尔文）
            /// </summary>
            public byte byThermometryUnit;
            /// <summary>
            /// 人脸抓拍测温是否温度异常：1-是，0-否
            /// </summary>
            public byte byIsAbnomalTemperature;
            public byte byRes2;
            /// <summary>
            /// 人脸温度（精确到小数点后一位）
            /// </summary>
            public float fCurrTemperature;
            /// <summary>
            /// 人脸温度坐标
            /// </summary>
            public NET_VCA_POINT struRegionCoordinates;
            /// <summary>
            /// 二维码信息长度，不为0是表示后面带数据
            /// </summary>
            public ushort dwQRCodeInfoLen;
            /// <summary>
            /// 热成像相机可见光图片长度，不为0是表示后面带数据
            /// </summary>
            public ushort dwVisibleLightDataLen;
            /// <summary>
            /// 热成像图片长度，不为0是表示后面带数据
            /// </summary>
            public ushort dwThermalDataLen;
            /// <summary>
            /// 二维码信息指针
            /// </summary>
            public IntPtr pQRCodeInfo;
            /// <summary>
            /// 热成像相机可见光图片指针
            /// </summary>
            public IntPtr pVisibleLightData;
            /// <summary>
            /// 热成像图片指针
            /// </summary>
            public IntPtr pThermalData;
            /// <summary>
            /// 考勤自定义名称
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byAttendanceLabel;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 960, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ACS_ALARM_INFO
        {
            public uint dwSize;
            /// <summary>
            /// 报警主类型，参考宏定义
            /// </summary>
            public uint dwMajor;
            /// <summary>
            /// 报警次类型，参考宏定义
            /// </summary>
            public uint dwMinor;
            /// <summary>
            /// 时间
            /// </summary>
            public NET_DVR_TIME struTime;
            /// <summary>
            /// 网络操作的用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NAMELEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sNetUser;
            /// <summary>
            /// 远程主机地址
            /// </summary>
            public NET_DVR_IPADDR struRemoteHostAddr;
            /// <summary>
            /// 详细参数
            /// </summary>
            public NET_DVR_ACS_EVENT_INFO struAcsEventInfo;
            /// <summary>
            /// 图片数据大小，不为0是表示后面带数据
            /// </summary>
            public uint dwPicDataLen;
            public IntPtr pPicData;
            /// <summary>
            /// 归纳事件类型，0-无效，客户端判断该值为非0值后，报警类型通过归纳事件类型区分，否则通过原有报警主次类型（dwMajor、dwMinor）区分
            /// </summary>
            public ushort wInductiveEventType;
            /// <summary>
            /// 图片数据传输方式: 0-二进制；1-url
            /// </summary>
            public byte byPicTransType;
            /// <summary>
            /// 保留字节
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// IOT通道号
            /// </summary>
            public uint dwIOTChannelNo;
            /// <summary>
            /// byAcsEventInfoExtend为1时，表示指向一个NET_DVR_ACS_EVENT_INFO_EXTEND结构体
            /// </summary>
            public IntPtr pAcsEventInfoExtend;
            /// <summary>
            /// pAcsEventInfoExtend是否有效：0-无效，1-有效
            /// </summary>
            public byte byAcsEventInfoExtend;
            /// <summary>
            /// 时间类型：0-设备本地时间，1-UTC时间（struTime的时间）
            /// </summary>
            public byte byTimeType;
            /// <summary>
            /// 保留字节
            /// </summary>
            public byte byRes2;
            /// <summary>
            /// pAcsEventInfoExtendV20是否有效：0-无效，1-有效
            /// </summary>
            public byte byAcsEventInfoExtendV20;
            /// <summary>
            /// byAcsEventInfoExtendV20为1时，表示指向一个NET_DVR_ACS_EVENT_INFO_EXTEND_V20结构体
            /// </summary>
            public IntPtr pAcsEventInfoExtendV20;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ACS_EVENT_DETAIL
        {
            public uint dwSize;
            /// <summary>
            /// 卡号（mac地址），为0无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCardNo;
            /// <summary>
            /// 卡类型，1-普通卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
            /// </summary>
            public byte byCardType;
            /// <summary>
            /// 允许名单单号,1-8，为0无效
            /// </summary>
            public byte byAllowListNo;
            /// <summary>
            /// 报告上传通道，1-布防上传，2-中心组1上传，3-中心组2上传，为0无效
            /// </summary>
            public byte byReportChannel;
            /// <summary>
            /// 读卡器属于哪一类，0-无效，1-IC读卡器，2-身份证读卡器，3-二维码读卡器,4-指纹头
            /// </summary>
            public byte byCardReaderKind;
            /// <summary>
            /// 读卡器编号，为0无效
            /// </summary>
            public uint dwCardReaderNo;
            /// <summary>
            /// 门编号（楼层编号），为0无效
            /// </summary>
            public uint dwDoorNo;
            /// <summary>
            /// 多重卡认证序号，为0无效
            /// </summary>
            public uint dwVerifyNo;
            /// <summary>
            /// 报警输入号，为0无效
            /// </summary>
            public uint dwAlarmInNo;
            /// <summary>
            /// 报警输出号，为0无效
            /// </summary>
            public uint dwAlarmOutNo;
            /// <summary>
            /// 事件触发器编号
            /// </summary>
            public uint dwCaseSensorNo;
            /// <summary>
            /// RS485通道号，为0无效
            /// </summary>
            public uint dwRs485No;
            /// <summary>
            /// 群组编号
            /// </summary>
            public uint dwMultiCardGroupNo;
            /// <summary>
            /// 人员通道号
            /// </summary>
            public ushort wAccessChannel;
            /// <summary>
            /// 设备编号，为0无效（有效范围1-255）
            /// </summary>
            public byte byDeviceNo;
            /// <summary>
            /// 分控器编号，为0无效
            /// </summary>
            public byte byDistractControlNo;
            /// <summary>
            /// 工号，为0无效
            /// </summary>
            public uint dwEmployeeNo;
            /// <summary>
            /// 就地控制器编号，0-门禁主机，1-64代表就地控制器
            /// </summary>
            public ushort wLocalControllerID;
            /// <summary>
            /// 网口ID：（1-上行网口1,2-上行网口2,3-下行网口1）
            /// </summary>
            public byte byInternetAccess;
            /// <summary>
            /// 防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区 0xff-无
            /// </summary>
            public byte byType;
            /// <summary>
            /// 物理地址，为0无效
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMACAddr;
            /// <summary>
            /// 刷卡类型，0-无效，1-二维码
            /// </summary>
            public byte bySwipeCardType;
            /// <summary>
            /// 事件属性：0-未定义，1-合法认证，2-其它
            /// </summary>
            public byte byEventAttribute;
            /// <summary>
            /// 事件流水号，为0无效
            /// </summary>
            public uint dwSerialNo;
            /// <summary>
            /// 通道控制器ID，为0无效，1-主通道控制器，2-从通道控制器
            /// </summary>
            public byte byChannelControllerID;
            /// <summary>
            /// 通道控制器灯板ID，为0无效（有效范围1-255）
            /// </summary>
            public byte byChannelControllerLampID;
            /// <summary>
            /// 通道控制器红外转接板ID，为0无效（有效范围1-255）
            /// </summary>
            public byte byChannelControllerIRAdaptorID;
            /// <summary>
            /// 通道控制器红外对射ID，为0无效（有效范围1-255）
            /// </summary>
            public byte byChannelControllerIREmitterID;
            /// <summary>
            /// 录像通道数目
            /// </summary>
            public uint dwRecordChannelNum;
            /// <summary>
            /// 录像通道，大小为sizeof(DWORD)* dwRecordChannelNum
            /// </summary>
            public IntPtr pRecordChannelData;
            /// <summary>
            /// 人员类型：0-无效，1-普通人（主人），2-来宾（访客），3-禁止名单人，4-管理员
            /// </summary>
            public byte byUserType;
            /// <summary>
            /// 读卡器当前验证方式：0-无效，1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码，5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码，10-人脸或指纹或刷卡或密码，11-人脸+指纹，12-人脸+密码，
            /// </summary>
            public byte byCurrentVerifyMode;
            /// <summary>
            /// 13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡，23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸，26-刷卡或人脸或指纹，27-刷卡或指纹或密码
            /// </summary>
            public byte byAttendanceStatus;
            /// <summary>
            /// 考勤状态值
            /// </summary>
            public byte byStatusValue;
            /// <summary>
            /// 工号（人员ID）（对于设备来说，如果使用了工号（人员ID）字段，byEmployeeNo一定要传递，如果byEmployeeNo可转换为dwEmployeeNo，那么该字段也要传递；对于上层平台或客户端来说，优先解析byEmployeeNo字段，如该字段为空，再考虑解析dwEmployeeNo字段）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_SDK_EMPLOYEE_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byEmployeeNo;
            /// <summary>
            /// 保留
            /// </summary>
            public byte byRes1;
            /// <summary>
            /// 是否带口罩：0-保留，1-未知，2-不戴口罩，3-戴口罩
            /// </summary>
            public byte byMask;
            /// <summary>
            /// 测温单位（0-摄氏度（默认），1-华氏度，2-开尔文）
            /// </summary>
            public byte byThermometryUnit;
            /// <summary>
            /// 人脸抓拍测温是否温度异常：1-是，0-否
            /// </summary>
            public byte byIsAbnomalTemperature;
            /// <summary>
            /// 人脸温度（精确到小数点后一位）
            /// </summary>
            public float fCurrTemperature;
            /// <summary>
            /// 人脸温度坐标
            /// </summary>
            public NET_VCA_POINT struRegionCoordinates;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 48, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ACS_EVENT_CFG
        {
            public uint dwSize;
            /// <summary>
            /// 报警主类型，参考宏定义
            /// </summary>
            public uint dwMajor;
            /// <summary>
            /// 报警次类型，参考宏定义
            /// </summary>
            public uint dwMinor;
            /// <summary>
            /// 时间
            /// </summary>
            public NET_DVR_TIME struTime;
            /// <summary>
            /// 网络操作的用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NAMELEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sNetUser;
            /// <summary>
            /// 远程主机地址
            /// </summary>
            public NET_DVR_IPADDR struRemoteHostAddr;
            /// <summary>
            /// 详细参数
            /// </summary>
            public NET_DVR_ACS_EVENT_DETAIL struAcsEventInfo;
            /// <summary>
            /// 图片数据大小，不为0是表示后面带数据
            /// </summary>
            public uint dwPicDataLen;
            public IntPtr pPicData;
            /// <summary>
            /// 归纳事件类型，0-无效，其他值参见2.2章节，客户端判断该值为非0值后，报警类型通过归纳事件类型区分，否则通过原有报警主次类型（dwMajor、dwMinor）区分
            /// </summary>
            public ushort wInductiveEventType;
            /// <summary>
            /// 时间类型：0-设备本地时间（默认），1-UTC时间（struTime的时间）
            /// </summary>
            public byte byTimeType;
            public byte byRes1;
            /// <summary>
            /// 二维码信息长度，不为0是表示后面带数据
            /// </summary>
            public uint dwQRCodeInfoLen;
            /// <summary>
            /// 热成像相机可见光图片长度，不为0是表示后面带数据
            /// </summary>
            public uint dwVisibleLightDataLen;
            /// <summary>
            /// 热成像图片长度，不为0是表示后面带数据
            /// </summary>
            public uint dwThermalDataLen;
            /// <summary>
            /// 二维码信息指针
            /// </summary>
            public IntPtr pQRCodeInfo;
            /// <summary>
            /// 热成像相机可见光图片指针
            /// </summary>
            public IntPtr pVisibleLightData;
            /// <summary>
            /// 热成像图片指针
            /// </summary>
            public IntPtr pThermalData;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 36, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_DATE
        {
            /// <summary>
            /// 年
            /// </summary>
            public ushort wYear;
            /// <summary>
            /// 月
            /// </summary>
            public byte byMonth;
            /// <summary>
            /// 日
            /// </summary>
            public byte byDay;
        }

        /// <summary>
        /// 身份证信息
        /// </summary>
        //身份证信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ID_CARD_INFO
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 姓名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ID_NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byName;
            /// <summary>
            /// 出生日期
            /// </summary>
            public NET_DVR_DATE struBirth;
            /// <summary>
            /// 住址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ID_ADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byAddr;
            /// <summary>
            /// 身份证号码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ID_NUM_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byIDNum;
            /// <summary>
            /// 签发机关
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_ID_ISSUING_AUTHORITY_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byIssuingAuthority;
            /// <summary>
            /// 有效开始日期
            /// </summary>
            public NET_DVR_DATE struStartDate;
            /// <summary>
            /// 有效截止日期
            /// </summary>
            public NET_DVR_DATE struEndDate;
            /// <summary>
            /// 是否长期有效， 0-否，1-是（有效截止日期无效）
            /// </summary>
            public byte byTermOfValidity;
            /// <summary>
            /// 性别，1-男，2-女
            /// </summary>
            public byte bySex;
            public byte byNation;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 101, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 扩展结构体信息
        /// </summary>
        //扩展结构体信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ID_CARD_INFO_EXTEND
        {
            /// <summary>
            /// 是否需要远程核验（0-无效，1-不需要（默认），2-需要）
            /// </summary>
            public byte byRemoteCheck;
            /// <summary>
            /// 测温单位（0-摄氏度（默认），1-华氏度，2-开尔文）
            /// </summary>
            public byte byThermometryUnit;
            /// <summary>
            /// 人脸抓拍测温是否温度异常：1-是，0-否
            /// </summary>
            public byte byIsAbnomalTemperature;
            public byte byRes2;
            /// <summary>
            /// 人脸温度（精确到小数点后一位）
            /// </summary>
            public float fCurrTemperature;
            /// <summary>
            /// 人脸温度坐标
            /// </summary>
            public NET_VCA_POINT struRegionCoordinates;
            /// <summary>
            /// 二维码信息长度，不为0是表示后面带数据
            /// </summary>
            public uint dwQRCodeInfoLen;
            /// <summary>
            /// 热成像相机可见光图片长度，不为0是表示后面带数据
            /// </summary>
            public uint dwVisibleLightDataLen;
            /// <summary>
            /// 热成像图片长度，不为0是表示后面带数据
            /// </summary>
            public uint dwThermalDataLen;
            /// <summary>
            /// 二维码信息指针
            /// </summary>
            public IntPtr pQRCodeInfo;
            /// <summary>
            /// 热成像相机可见光图片指针
            /// </summary>
            public IntPtr pVisibleLightData;
            /// <summary>
            /// 热成像图片指针
            /// </summary>
            public IntPtr pThermalData;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 1024, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 身份证信息报警
        /// </summary>
        //身份证信息报警
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ID_CARD_INFO_ALARM
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 身份证信息
            /// </summary>
            public NET_DVR_ID_CARD_INFO struIDCardCfg;
            /// <summary>
            /// 报警主类型，参考宏定义
            /// </summary>
            public uint dwMajor;
            /// <summary>
            /// 报警次类型，参考宏定义
            /// </summary>
            public uint dwMinor;
            /// <summary>
            /// 时间
            /// </summary>
            public NET_DVR_TIME_V30 struSwipeTime;
            /// <summary>
            /// 网络操作的用户名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NAMELEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byNetUser;
            /// <summary>
            /// 远程主机地址
            /// </summary>
            public NET_DVR_IPADDR struRemoteHostAddr;
            /// <summary>
            /// 读卡器编号，为0无效
            /// </summary>
            public uint dwCardReaderNo;
            /// <summary>
            /// 门编号，为0无效
            /// </summary>
            public uint dwDoorNo;
            /// <summary>
            /// 图片数据大小，不为0是表示后面带数据
            /// </summary>
            public uint dwPicDataLen;
            public IntPtr pPicData;
            /// <summary>
            /// 卡类型，1-普通卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
            /// </summary>
            public byte byCardType;
            /// <summary>
            /// 设备编号，为0时无效（有效范围1-255）
            /// </summary>
            public byte byDeviceNo;
            /// <summary>
            /// 是否带口罩：0-保留，1-未知，2-不戴口罩，3-戴口罩
            /// </summary>
            public byte byMask;
            /// <summary>
            /// 是否为实时事件：0-无效，1-是（实时事件），2-否（离线事件）
            /// </summary>
            public byte byCurrentEvent;
            /// <summary>
            /// 指纹数据大小，不为0是表示后面带数据
            /// </summary>
            public uint dwFingerPrintDataLen;
            public IntPtr pFingerPrintData;
            /// <summary>
            /// 抓拍图片数据大小，不为0是表示后面带数据
            /// </summary>
            public uint dwCapturePicDataLen;
            public IntPtr pCapturePicData;
            /// <summary>
            /// 证件抓拍图片数据大小，不为0是表示后面带数据
            /// </summary>
            public uint dwCertificatePicDataLen;
            public IntPtr pCertificatePicData;
            /// <summary>
            /// 读卡器属于哪一类，0-无效，1-IC读卡器，2-身份证读卡器，3-二维码读卡器,4-指纹头
            /// </summary>
            public byte byCardReaderKind;
            /// <summary>
            /// 可选，是否戴安全帽：0-保留，1-未知，2-不戴安全, 3-戴安全帽
            /// </summary>
            public byte byHelmet;
            public byte byRes3;
            /// <summary>
            /// pIDCardInfoExtend是否有效：0-无效，1-有效
            /// </summary>
            public byte byIDCardInfoExtend;
            /// <summary>
            /// byIDCardInfoExtend为1时，表示指向一个NET_DVR_ID_CARD_INFO_EXTEND结构体
            /// </summary>
            public IntPtr pIDCardInfoExtend;
            /// <summary>
            /// 事件流水号，为0无效
            /// </summary>
            public uint dwSerialNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 168, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_VALID_PERIOD_CFG
        {
            /// <summary>
            /// 使能有效期，0-不使能，1使能
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 是否限制起始时间的标志，0-不限制，1-限制
            /// </summary>
            public byte byBeginTimeFlag;
            /// <summary>
            /// 是否限制终止时间的标志，0-不限制，1-限制
            /// </summary>
            public byte byEnableTimeFlag;
            /// <summary>
            /// 有效期索引,从0开始（时间段通过SDK设置给锁，后续在制卡时，只需要传递有效期索引即可，以减少数据量）
            /// </summary>
            public byte byTimeDurationNo;
            /// <summary>
            /// 有效期起始时间
            /// </summary>
            public NET_DVR_TIME_EX struBeginTime;
            /// <summary>
            /// 有效期结束时间
            /// </summary>
            public NET_DVR_TIME_EX struEndTime;
            /// <summary>
            /// 时间类型：0-设备本地时间（默认），1-UTC时间（对于struBeginTime，struEndTime字段有效）
            /// </summary>
            public byte byTimeType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 31, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CARD_COND
        {
            public uint dwSize;
            /// <summary>
            /// card number, 0xffffffff means to get all card information when getting
            /// </summary>
            public uint dwCardNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CARD_RECORD
        {
            public uint dwSize;
            /// <summary>
            /// card No
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCardNo;
            public byte byCardType;
            public byte byLeaderCard;
            public byte byUserType;
            public byte byRes1;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOOR_NUM_256, ArraySubType = UnmanagedType.I1)]
            public byte[] byDoorRight;
            public NET_DVR_VALID_PERIOD_CFG struValid;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_GROUP_NUM_128, ArraySubType = UnmanagedType.I1)]
            public byte[] byBelongGroup;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = CARD_PASSWORD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCardPassword;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOOR_NUM_256, ArraySubType = UnmanagedType.I1)]
            public ushort[] wCardRightPlan;
            public uint dwMaxSwipeTimes;
            public uint dwSwipeTimes;
            public uint dwEmployeeNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byName;
            /// <summary>
            /// 按位表示，0-无权限，1-有权限
            /// 第0位表示：弱电报警
            /// 第1位表示：开门提示音
            /// 第2位表示：限制客卡
            /// 第3位表示：通道
            /// 第4位表示：反锁开门
            /// 第5位表示：巡更功能
            /// </summary>
            public uint dwCardRight;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CARD_STATUS
        {
            public uint dwSize;
            /// <summary>
            /// card No
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCardNo;
            public uint dwErrorCode;
            /// <summary>
            /// 0-fail, 1-success
            /// </summary>
            public byte byStatus;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 23, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CARD_SEND_DATA
        {
            public uint dwSize;
            /// <summary>
            /// card No
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCardNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FACE_PARAM_CTRL_ByCard
        {
            public int dwSize;
            /// <summary>
            /// 0 del by card,1 del by card reader
            /// </summary>
            public byte byMode;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public NET_DVR_FACE_PARAM_BYCARD struProcessMode;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }
        /// <summary>
        /// max face number
        /// </summary>
        public const int MAX_FACE_NUM = 2;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FACE_PARAM_BYCARD
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCardNo;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_CARD_READER_NUM_512, ArraySubType = UnmanagedType.I1)]
            public byte[] byEnableCardReader;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_FACE_NUM, ArraySubType = UnmanagedType.I1)]
            public byte[] byFaceID;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 42, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FACE_PARAM_CTRL_ByReader
        {
            public int dwSize;
            public byte byMode;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public NET_DVR_FACE_PARAM_BYREADER struProcessMode;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FACE_PARAM_BYREADER
        {
            public int dwCardReaderNo;
            public byte byClearAllCard;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCardNo;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 548, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FACE_STATUS
        {
            public int dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCardNo;
            /// <summary>
            /// 下发错误信息，当byCardReaderRecvStatus为4时，表示已存在人脸对应的卡号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ERROR_MSG_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byErrorMsg;
            /// <summary>
            /// 人脸读卡器编号，可用于下发错误返回
            /// </summary>
            public int dwReaderNo;
            /// <summary>
            /// 人脸读卡器状态，按字节表示，0-失败，1-成功，2-重试或人脸质量差，3-内存已满(人脸数据满)，4-已存在该人脸，5-非法人脸ID
            /// </summary>
            public byte byRecvStatus;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 131, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct NET_DVR_FACE_RECORD
        {
            public int dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN)]
            public byte[] byCardNo;
            public int dwFaceLen;
            public IntPtr pFaceBuffer;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 128)]
            public byte[] byRes;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct NET_DVR_FACE_COND
        {
            public int dwSize;
            /// <summary>
            /// 人脸关联的卡号（设置时该参数可不设置）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN)]
            public byte[] byCardNo;
            /// <summary>
            /// 设置或获取人脸数量，获取时置为0xffffffff表示获取所有人脸信息
            /// </summary>
            public int dwFaceNum;
            /// <summary>
            /// 人脸读卡器编号
            /// </summary>
            public int dwEnableReaderNo;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 124)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FACE_PARAM_CTRL_CARDNO
        {
            public int dwSize;
            /// <summary>
            /// 删除方式，0-按卡号方式删除，1-按读卡器删除
            /// </summary>
            public byte byMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 按卡号的方式删除,读卡器暂时不写
            /// </summary>
            public NET_DVR_FACE_PARAM_BYCARD struByCard;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FINGERPRINT_COND
        {
            public int dwSize;
            public int dwFingerprintNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN)]
            public byte[] byCardNo;
            public int dwEnableReaderNo;
            public byte byFingerPrintID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 131)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CARD_CFG_V50
        {
            public uint dwSize;
            public uint dwModifyParamType;
            /// <summary>
            /// 需要修改的卡参数，设置卡参数时有效，按位表示，每位代表一种参数，1为需要修改，0为不修改
            /// #define CARD_PARAM_CARD_VALID       0x00000001 //卡是否有效参数
            /// #define CARD_PARAM_VALID            0x00000002  //有效期参数
            /// #define CARD_PARAM_CARD_TYPE        0x00000004  //卡类型参数
            /// #define CARD_PARAM_DOOR_RIGHT       0x00000008  //门权限参数
            /// #define CARD_PARAM_LEADER_CARD      0x00000010  //首卡参数
            /// #define CARD_PARAM_SWIPE_NUM        0x00000020  //最大刷卡次数参数
            /// #define CARD_PARAM_GROUP            0x00000040  //所属群组参数
            /// #define CARD_PARAM_PASSWORD         0x00000080  //卡密码参数
            /// #define CARD_PARAM_RIGHT_PLAN       0x00000100  //卡权限计划参数
            /// #define CARD_PARAM_SWIPED_NUM       0x00000200  //已刷卡次数
            /// #define CARD_PARAM_EMPLOYEE_NO      0x00000400  //工号
            /// #define CARD_PARAM_NAME             0x00000800  //姓名
            /// #define CARD_PARAM_DEPARTMENT_NO    0x00001000  //部门编号
            /// #define CARD_SCHEDULE_PLAN_NO       0x00002000  //排班计划编号
            /// #define CARD_SCHEDULE_PLAN_TYPE     0x00004000  //排班计划类型
            /// #define CARD_ROOM_NUMBER            0x00008000  //房间号
            /// #define CARD_SIM_NO                 0x00010000  //SIM卡号（手机号）
            /// #define CARD_FLOOR_NUMBER           0x00020000  //楼层号
            /// #define CARD_USER_TYPE              0x00040000  //用户类型
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCardNo;
            /// <summary>
            /// 卡是否有效，0-无效，1-有效（用于删除卡，设置时置为0进行删除，获取时此字段始终为1）
            /// </summary>
            public byte byCardValid;
            /// <summary>
            /// 卡类型，1-普通卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，9-员工卡，10-应急卡，11-应急管理卡（用于授权临时卡权限，本身不能开门），默认普通卡
            /// </summary>
            public byte byCardType;
            /// <summary>
            /// 是否为首卡，1-是，0-否
            /// </summary>
            public byte byLeaderCard;
            /// <summary>
            /// 0 – 普通用户1 - 管理员用户;
            /// </summary>
            public byte byUserType;
            /// <summary>
            /// 门权限(楼层权限、锁权限)，按位表示，1为有权限，0为无权限，从低位到高位表示对门（锁）1-N是否有权限
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOOR_NUM_256, ArraySubType = UnmanagedType.I1)]
            public byte[] byDoorRight;
            /// <summary>
            /// 有效期参数
            /// </summary>
            public NET_DVR_VALID_PERIOD_CFG struValid;
            /// <summary>
            /// 所属群组，按字节表示，1-属于，0-不属于
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_GROUP_NUM_128, ArraySubType = UnmanagedType.I1)]
            public byte[] byBelongGroup;
            /// <summary>
            /// 卡密码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = CARD_PASSWORD_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCardPassword;
            /// <summary>
            /// 卡权限计划，取值为计划模板编号，同个门（锁）不同计划模板采用权限或的方式处理
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOOR_NUM_256 * MAX_CARD_RIGHT_PLAN_NUM, ArraySubType = UnmanagedType.U2)]
            public ushort[] wCardRightPlan;
            /// <summary>
            /// 最大刷卡次数，0为无次数限制（开锁次数）
            /// </summary>
            public uint dwMaxSwipeTime;
            /// <summary>
            /// 已刷卡次数
            /// </summary>
            public uint dwSwipeTime;
            /// <summary>
            /// 房间号
            /// </summary>
            public ushort wRoomNumber;
            /// <summary>
            /// 层号
            /// </summary>
            public ushort wFloorNumber;
            /// <summary>
            /// 工号（用户ID）
            /// </summary>
            public uint dwEmployeeNo;
            /// <summary>
            /// 姓名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byName;
            /// <summary>
            /// 部门编号
            /// </summary>
            public ushort wDepartmentNo;
            /// <summary>
            /// 排班计划编号
            /// </summary>
            public ushort wSchedulePlanNo;
            /// <summary>
            /// 排班计划类型：0-无意义、1-个人、2-部门
            /// </summary>
            public byte bySchedulePlanType;
            /// <summary>
            /// 下发权限类型：0-普通发卡权限、1-二维码权限、2-蓝牙权限（可视对讲设备二维码权限配置项：房间号、卡号（虚拟卡号）、最大刷卡次数（开锁次数）、有效期参数；蓝牙权限：卡号（萤石APP账号）、其他参数配置与普通发卡权限一致）
            /// </summary>
            public byte byRightType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 锁ID
            /// </summary>
            public uint dwLockID;
            /// <summary>
            /// 锁代码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_LOCK_CODE_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byLockCode;
            /// <summary>
            /// 房间代码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DOOR_CODE_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byRoomCode;
            /// <summary>
            /// 按位表示，0-无权限，1-有权限
            /// 第0位表示：弱电报警
            /// 第1位表示：开门提示音
            /// 第2位表示：限制客卡
            /// 第3位表示：通道
            /// 第4位表示：反锁开门
            /// 第5位表示：巡更功能
            /// </summary>
            public uint dwCardRight;
            /// <summary>
            /// 计划模板(每天)各时间段是否启用，按位表示，0--不启用，1-启用
            /// </summary>
            public uint dwPlanTemplate;
            /// <summary>
            /// 持卡人ID
            /// </summary>
            public uint dwCardUserId;
            /// <summary>
            /// 0-空，1- M1 CARD S50，2- M1 CARD S70，3- FM1208 CPU卡，4- FM1216 CPU卡，5-国密CPU卡，6-身份证，7- NFC
            /// </summary>
            public byte byCardModelType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 51, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes3;
            /// <summary>
            /// SIM卡号（手机号）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] bySIMNum;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CHECK_FACE_PICTURE_COND
        {
            public uint dwSize;
            /// <summary>
            /// 图片数量
            /// </summary>
            public uint dwPictureNum;
            /// <summary>
            /// 0-校验图片是否合法（默认），1-校验图片和建模数据是否匹配
            /// </summary>
            public byte byCheckTemplate;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 127, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_GROUP_COMBINATION_INFO_V50
        {
            /// <summary>
            /// 是否启用该群组组合
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 刷卡成员数量
            /// </summary>
            public byte byMemberNum;
            /// <summary>
            /// 群组刷卡次序号
            /// </summary>
            public byte bySequenceNo;
            public byte byRes;
            /// <summary>
            /// 群组编号,0xffffffff表示远程开门，0xfffffffe表示超级密码
            /// </summary>
            public uint dwGroupNo;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MULTI_CARD_GROUP_CFG_V50
        {
            /// <summary>
            /// 是否启用该多重卡组参数，0-不启用，1-启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 是否启用主机离线时验证方式（超级密码代替远程开门），1-启用，0-不启用
            /// </summary>
            public byte byEnableOfflineVerifyMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 启用多重卡功能的计划模板编号
            /// </summary>
            public uint dwTemplateNo;
            /// <summary>
            /// 群组组合参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = GROUP_COMBINATION_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_GROUP_COMBINATION_INFO_V50[] struGroupCombination;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_MULTI_CARD_CFG_V50
        {
            public uint dwSize;
            /// <summary>
            /// 是否启用多重卡功能，0-不启用，1-启用
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 刷卡间隔超时时间，1-255s，默认10s
            /// </summary>
            public byte bySwipeIntervalTimeout;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 群组刷卡参数
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_SDK_MULTI_CARD_GROUP_NUM_20, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_MULTI_CARD_GROUP_CFG_V50[] struGroupCfg;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        /// <summary>
        /// 布防点ID长度
        /// </summary>
        public const int NET_SDK_MONITOR_ID_LEN = 64;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ACS_EVENT_COND
        {
            public uint dwSize;
            /// <summary>
            /// 报警主类型，参考事件上传宏定义，0-全部
            /// </summary>
            public uint dwMajor;
            /// <summary>
            /// 报警次类型，参考事件上传宏定义，0-全部
            /// </summary>
            public uint dwMinor;
            /// <summary>
            /// 开始时间
            /// </summary>
            public NET_DVR_TIME struStartTime;
            /// <summary>
            /// 结束时间
            /// </summary>
            public NET_DVR_TIME struEndTime;
            /// <summary>
            /// 卡号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = ACS_CARD_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byCardNo;
            /// <summary>
            /// 持卡人姓名
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byName;
            /// <summary>
            /// 是否带图片，0-不带图片，1-带图片
            /// </summary>
            public byte byPicEnable;
            /// <summary>
            /// 时间类型：0-设备本地时间（默认），1-UTC时间（struStartTime和struEndTime的时间）
            /// </summary>
            public byte byTimeType;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
            /// <summary>
            /// 起始流水号（为0时默认全部）
            /// </summary>
            public uint dwBeginSerialNo;
            /// <summary>
            /// 结束流水号（为0时默认全部）
            /// </summary>
            public uint dwEndSerialNo;
            /// <summary>
            /// IOT通道号，0-无效
            /// </summary>
            public uint dwIOTChannelNo;
            /// <summary>
            /// 归纳事件类型，0-无效，其他值参见2.2章节，客户端判断该值为非0值后，报警类型通过归纳事件类型区分，否则通过原有报警主次类型（dwMajor、dwMinor）区分
            /// </summary>
            public ushort wInductiveEventType;
            /// <summary>
            /// 搜索方式：0-保留，1-按事件源搜索（此时通道号为非视频通道号），2-按布防点ID搜索
            /// </summary>
            public byte bySearchType;
            /// <summary>
            /// 事件属性：0-未定义，1-合法事件，2-其它
            /// </summary>
            public byte byEventAttribute;
            /// <summary>
            /// 布防点ID（由设备序列号、通道类型、编号组成，例如门禁点：设备序列号+“DOOR”+门编号）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_SDK_MONITOR_ID_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] szMonitorID;
            /// <summary>
            /// 工号（人员ID）
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_SDK_EMPLOYEE_NO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byEmployeeNo;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 140, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LOCAL_GENERAL_CFG
        {
            /// <summary>
            /// 0-通过线程池异常回调，1-直接异常回调给上层
            /// </summary>
            public byte byExceptionCbDirectly;
            /// <summary>
            /// 回放和预览中保存到本地录像文件不切片 0-默认切片，1-不切片
            /// </summary>
            public byte byNotSplitRecordFile;
            /// <summary>
            /// 断网续传升级使能，0-关闭（默认），1-开启
            /// </summary>
            public byte byResumeUpgradeEnable;
            /// <summary>
            /// 控制JSON透传报警数据和图片是否分离，0-不分离，1-分离（分离后走COMM_ISAPI_ALARM回调返回）
            /// </summary>
            public byte byAlarmJsonPictureSeparate;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 单位：Byte
            /// </summary>
            public Int64 i64FileSize;
            /// <summary>
            /// 断网续传重连超时时间，单位毫秒
            /// </summary>
            public uint dwResumeUpgradeTimeout;
            /// <summary>
            /// 预留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 236, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LOCAL_CHECK_DEV
        {
            /// <summary>
            /// 巡检时间间隔，单位ms  最小值为30s，最大值120s。为0时，表示用默认值(120s)
            /// </summary>
            public uint dwCheckOnlineTimeout;
            /// <summary>
            /// 由于网络原因失败的最大累加次数；超过该值SDK才回调用户异常，为0时，表示使用默认值1
            /// </summary>
            public uint dwCheckOnlineNetFailMax;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARM_ISAPI_INFO
        {
            /// <summary>
            /// 报警数据
            /// </summary>
            public IntPtr pAlarmData;
            /// <summary>
            /// 报警数据长度
            /// </summary>
            public uint dwAlarmDataLen;
            /// <summary>
            /// 0-invalid,1-xml,2-json
            /// </summary>
            public byte byDataType;
            /// <summary>
            /// 图片数量
            /// </summary>
            public byte byPicturesNumber;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 图片变长部分
            /// </summary>
            public IntPtr pPicPackData;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
        }
        /// <summary>
        /// 文件路径长度
        /// </summary>
        public const int MAX_FILE_PATH_LEN = 256;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARM_ISAPI_PICDATA
        {
            public uint dwPicLen;
            /// <summary>
            /// 图片格式: 1- jpg
            /// </summary>
            public byte byPicType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_FILE_PATH_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] szFilename;
            public IntPtr pPicData;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_EXTERNAL_DEVICE_STATE_UNION
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 512, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE
        {
            public uint dwSize;
            /// <summary>
            /// 1-UPS，2-开关电源，3-气体检测系统，4-温湿度传感器，5-空调，6-电量表，7-变电器状态, 8-水位传感器、9-扬尘噪声传感器、10-环境采集仪、11-风速传感器状态、12-通用扩展输出模块状态、13-浸水传感器状态、14-太阳能控制器状态、15-SF6报警主机状态、16-称重仪状态、17-气象采集系统状态、18-水质检测仪状态、19-燃气显示系统状态、20-消防主机状态
            /// </summary>
            public byte byDevType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            public NET_DVR_EXTERNAL_DEVICE_STATE_UNION struDevState;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes2;
        }
        /// <summary>
        /// 设备区域设置
        /// </summary>
        public const int REGIONTYPE = 0;
        /// <summary>
        /// 矩阵节点
        /// </summary>
        public const int MATRIXTYPE = 11;
        /// <summary>
        /// 代表设备
        /// </summary>
        public const int DEVICETYPE = 2;
        /// <summary>
        /// 代表通道
        /// </summary>
        public const int CHANNELTYPE = 3;
        /// <summary>
        /// 代表用户
        /// </summary>
        public const int USERTYPE = 5;

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LOG_MATRIX
        {
            public NET_DVR_TIME strLogTime;
            public uint dwMajorType;
            public uint dwMinorType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NAMELEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sPanelUser;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_NAMELEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sNetUser;
            public NET_DVR_IPADDR struRemoteHostAddr;
            public uint dwParaType;
            public uint dwChannel;
            public uint dwDiskNumber;
            public uint dwAlarmInPort;
            public uint dwAlarmOutPort;
            public uint dwInfoLen;
            /// <summary>
            /// 槽位号
            /// </summary>
            public byte byDevSequence;
            /// <summary>
            /// MAC地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMacAddr;
            /// <summary>
            /// 序列号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SERIALNO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sSerialNumber;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = LOG_INFO_LEN - SERIALNO_LEN - MACADDR_LEN - 1)]
            public string sInfo;
        }

        /// <summary>
        /// 视频综合平台软件
        /// </summary>
        //视频综合平台软件
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct tagVEDIOPLATLOG
        {
            /// <summary>
            /// 搜索条件，0-按槽位号搜索，1-按序列号搜索 2-按MAC地址进行搜索
            /// </summary>
            public byte bySearchCondition;
            /// <summary>
            /// 槽位号，0-79：对应子系统的槽位号；
            /// </summary>
            public byte byDevSequence;
            /// <summary>
            /// 序列号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = SERIALNO_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sSerialNumber;
            /// <summary>
            /// MAC地址
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MACADDR_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byMacAddr;
        }

        /// <summary>
        /// 参数关键字
        /// </summary>
        public enum IVS_PARAM_KEY
        {
            /// <summary>
            /// 目标检测灵敏度
            /// </summary>
            OBJECT_DETECT_SENSITIVE = 1,
            /// <summary>
            /// 背景更新速度
            /// </summary>
            BACKGROUND_UPDATE_RATE = 2,
            /// <summary>
            /// 场景变化检测最小值
            /// </summary>
            SCENE_CHANGE_RATIO = 3,
            /// <summary>
            /// 是否抑制车头灯
            /// </summary>
            SUPPRESS_LAMP = 4,
            /// <summary>
            /// 能检测出的最小目标大小
            /// </summary>
            MIN_OBJECT_SIZE = 5,
            /// <summary>
            /// 目标生成速度
            /// </summary>
            OBJECT_GENERATE_RATE = 6,
            /// <summary>
            /// 目标消失后继续时间
            /// </summary>
            MISSING_OBJECT_HOLD = 7,
            /// <summary>
            /// 目标消失后继续距离
            /// </summary>
            MAX_MISSING_DISTANCE = 8,
            /// <summary>
            /// 多个目标交错时，目标的融合速度
            /// </summary>
            OBJECT_MERGE_SPEED = 9,
            /// <summary>
            /// 重复运动抑制
            /// </summary>
            REPEATED_MOTION_SUPPRESS = 10,
            /// <summary>
            /// 光影变化抑制开关
            /// </summary>
            ILLUMINATION_CHANGE = 11,
            /// <summary>
            /// 输出模式：0-输出目标的中心，1-输出目标的底部中心
            /// </summary>
            TRACK_OUTPUT_MODE = 12,
            /// <summary>
            /// 检测区域变化阈值
            /// </summary>
            ENTER_CHANGE_HOLD = 13,
            /// <summary>
            /// 恢复默认关键字参数
            /// </summary>
            RESUME_DEFAULT_PARAM = 255
        }

        /// <summary>
        /// 标定参数配置结构
        /// </summary>
        //标定参数配置结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LF_CALIBRATION_PARAM
        {
            /// <summary>
            /// 有效标定点个数
            /// </summary>
            public byte byPointNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 标定点组
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CALIB_PT, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_CB_POINT[] struCBPoint;
        }

        /// <summary>
        /// LF双摄像机配置结构
        /// </summary>
        //LF双摄像机配置结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LF_CFG
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 标定使能
            /// </summary>
            public byte byEnable;
            /// <summary>
            /// 被控制的从通道
            /// </summary>
            public byte byFollowChan;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 标定点组
            /// </summary>
            public NET_DVR_LF_CALIBRATION_PARAM struCalParam;
        }

        /// <summary>
        /// L/F手动控制结构
        /// </summary>
        //L/F手动控制结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LF_MANUAL_CTRL_INFO
        {
            public NET_VCA_POINT struCtrlPoint;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// L/F目标结构
        /// </summary>
        //L/F目标结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LF_TRACK_TARGET_INFO
        {
            public uint dwTargetID;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_LF_TRACK_MODE
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 模式
            /// </summary>
            public byte byTrackMode;
            /// <summary>
            /// 保留，置0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// Long config callback type
        /// </summary>
        public enum NET_SDK_CALLBACK_TYPE
        {
            /// <summary>
            /// 回调状态值
            /// </summary>
            NET_SDK_CALLBACK_TYPE_STATUS = 0,
            /// <summary>
            /// 回调进度值
            /// </summary>
            NET_SDK_CALLBACK_TYPE_PROGRESS,
            /// <summary>
            /// 回调数据内容
            /// </summary>
            NET_SDK_CALLBACK_TYPE_DATA
        }

        /// <summary>
        /// Long config status value
        /// </summary>
        public enum NET_SDK_CALLBACK_STATUS_NORMAL
        {
            /// <summary>
            /// 成功
            /// </summary>
            NET_SDK_CALLBACK_STATUS_SUCCESS = 1000,
            /// <summary>
            /// 处理中
            /// </summary>
            NET_SDK_CALLBACK_STATUS_PROCESSING,
            /// <summary>
            /// 失败
            /// </summary>
            NET_SDK_CALLBACK_STATUS_FAILED,
            /// <summary>
            /// 异常
            /// </summary>
            NET_SDK_CALLBACK_STATUS_EXCEPTION,
            /// <summary>
            /// 语言不匹配
            /// </summary>
            NET_SDK_CALLBACK_STATUS_LANGUAGE_MISMATCH,
            /// <summary>
            /// 设备类型不匹配
            /// </summary>
            NET_SDK_CALLBACK_STATUS_DEV_TYPE_MISMATCH,
            /// <summary>
            /// 发送等待
            /// </summary>
            NET_DVR_CALLBACK_STATUS_SEND_WAIT
        }

        /// <summary>
        /// Sensor信息
        /// </summary>
        //Sensor信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SENSOR_PARAM
        {
            /// <summary>
            /// SensorType:0-CCD,1-CMOS
            /// </summary>
            public byte bySensorType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 31, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 水平宽度 精确到小数点后两位 *10000
            /// </summary>
            public float fHorWidth;
            /// <summary>
            /// 垂直宽度 精确到小数点后两位 *10000
            /// </summary>
            public float fVerWidth;
            /// <summary>
            /// zoom=1没变时的焦距 精确到小数点后两位 *100
            /// </summary>
            public float fFold;
        }

        /// <summary>
        /// 球机位置信息
        /// </summary>
        //球机位置信息
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PTZPOS_PARAM
        {
            /// <summary>
            /// 水平参数，精确到小数点后1位
            /// </summary>
            public float fPanPos;
            /// <summary>
            /// 垂直参数，精确到小数点后1位
            /// </summary>
            public float fTiltPos;
            /// <summary>
            /// 变倍参数，精确到小数点后1位
            /// </summary>
            public float fZoomPos;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 16, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// GIS信息上传
        /// </summary>
        //GIS信息上传
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_GIS_UPLOADINFO
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 前端设备
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 电子罗盘的方位信息；方位角[0.00°,360.00°)
            /// </summary>
            public float fAzimuth;
            /// <summary>
            /// 纬度类型，0-北纬，1-南纬
            /// </summary>
            public byte byLatitudeType;
            /// <summary>
            /// 经度类型，0-东度，1-西度
            /// </summary>
            public byte byLongitudeType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 纬度
            /// </summary>
            public NET_DVR_LLI_PARAM struLatitude;
            /// <summary>
            /// 经度
            /// </summary>
            public NET_DVR_LLI_PARAM struLongitude;
            /// <summary>
            /// 水平视场角，精确到小数点后面两位
            /// </summary>
            public float fHorizontalValue;
            /// <summary>
            /// 垂直视场角，精确到小数点后面两位
            /// </summary>
            public float fVerticalValue;
            /// <summary>
            /// 当前可视半径，精确到小数点后面两位
            /// </summary>
            public float fVisibleRadius;
            /// <summary>
            /// 最大可视半径，精确到小数点后面0位（预留处理）
            /// </summary>
            public float fMaxViewRadius;
            /// <summary>
            /// Sensor信息
            /// </summary>
            public NET_DVR_SENSOR_PARAM struSensorParam;
            /// <summary>
            /// ptz坐标
            /// </summary>
            public NET_DVR_PTZPOS_PARAM struPtzPos;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 256, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_TIME_V50
        {
            /// <summary>
            /// WORD 对应 C# 的 ushort
            /// </summary>
            public ushort wYear;
            /// <summary>
            /// BYTE 对应 C# 的 byte
            /// </summary>
            public byte byMonth;
            /// <summary>
            /// BYTE 对应 C# 的 byte
            /// </summary>
            public byte byDay;
            /// <summary>
            /// BYTE 对应 C# 的 byte
            /// </summary>
            public byte byHour;
            /// <summary>
            /// BYTE 对应 C# 的 byte
            /// </summary>
            public byte byMinute;
            /// <summary>
            /// BYTE 对应 C# 的 byte
            /// </summary>
            public byte bySecond;
            /// <summary>
            /// BYTE 对应 C# 的 byte
            /// </summary>
            public byte byISO8601;
            /// <summary>
            /// WORD 对应 C# 的 ushort
            /// </summary>
            public ushort wMillisecond;
            /// <summary>
            /// char 对应 C# 的 sbyte（有符号字节）
            /// </summary>
            public byte cTimeDifferenceH;
            /// <summary>
            /// char 对应 C# 的 sbyte（有符号字节）
            /// </summary>
            public byte cTimeDifferenceM;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FIND_LOG_COND
        {
            /// <summary>
            /// DWORD 对应 C# 的 uint
            /// </summary>
            public uint dwSelectMode;
            /// <summary>
            /// DWORD 对应 C# 的 uint
            /// </summary>
            public uint dwMainType;
            /// <summary>
            /// DWORD 对应 C# 的 uint
            /// </summary>
            public uint dwSubType;
            /// <summary>
            /// NET_DVR_TIME_V50 结构体
            /// </summary>
            public NET_DVR_TIME_V50 struStartTime;
            /// <summary>
            /// NET_DVR_TIME_V50 结构体
            /// </summary>
            public NET_DVR_TIME_V50 struEndTime;
            /// <summary>
            /// BOOL 对应 C# 的 bool
            /// </summary>
            public bool bOnlySmart;
            /// <summary>
            /// BYTE 数组，固定大小为 128
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
            public byte[] byRes;
        }
        public const int NET_SDK_MAX_FDID_LEN = 256;

        /// <summary>
        /// 导入人脸数据(人脸图片+图片附件信息)到人脸库的条件参数结构体。
        /// </summary>
        //导入人脸数据(人脸图片+图片附件信息)到人脸库的条件参数结构体。
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_FACELIB_COND
        {
            /// <summary>
            /// 结构大小
            /// </summary>
            public uint dwSize;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NET_SDK_MAX_FDID_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] szFDID;
            /// <summary>
            /// 设备并发处理：0- 不开启，1- 开始
            /// </summary>
            public byte byConcurrent;
            /// <summary>
            /// 是否覆盖式导入 0-否，1-是
            /// </summary>
            public byte byCover;
            /// <summary>
            /// FDID是否是自定义，0-不是，1-是；
            /// </summary>
            public byte byCustomFaceLibID;
            /// <summary>
            /// 上传原图保存模式，0-保存，1-不保存;
            /// </summary>
            public byte byPictureSaveMode;
            /// <summary>
            /// 交互操作口令
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byIdentityKey;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 60, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_SEND_PARAM_IN
        {
            public IntPtr pSendData;
            public uint dwSendDataLen;
            public NET_DVR_TIME_V30 struTime;
            public byte byPicType;
            /// <summary>
            /// 图片数据采用URL方式 0-二进制图片数据，1-图片数据走URL方式
            /// </summary>
            public byte byPicURL;
            public byte byUploadModeling;
            public byte byRes1;
            public uint dwPicMangeNo;
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = 32)]
            public string sPicName;
            public uint dwPicDisplayTime;
            public IntPtr pSendAppendData;
            public uint dwSendAppendDataLen;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 192, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        public enum HKUploadType
        {
            /// <summary>
            /// 导入人脸数据(人脸图片+图片附加信息)到人脸库
            /// </summary>
            IMPORT_DATA_TO_FACELIB = 39
        }
        public const int MAX_UPLOADFILE_URL_LEN = 240;

        /// <summary>
        /// 导入人脸图片数据到人脸库的结果参数结构体
        /// </summary>
        //导入人脸图片数据到人脸库的结果参数结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_UPLOAD_FILE_RET
        {
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_UPLOADFILE_URL_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] sUrl;
            /// <summary>
            /// 保留
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 260, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// GPS报警信息结构体
        /// </summary>
        //GPS报警信息结构体
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_GPSALARMINFO
        {
            /// <summary>
            /// 设备的ID串
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = NAME_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byDeviceID;
            /// <summary>
            /// GPS上传的时间
            /// </summary>
            public NET_DVR_TIME_EX struGpsTime;
            /// <summary>
            /// 经度
            /// </summary>
            public uint dwLongitude;
            /// <summary>
            /// 纬度
            /// </summary>
            public uint dwLatitude;
            /// <summary>
            /// 时区，用分钟数表示，+60代表东1区，+480代表东8区，-60代表西区，-480代表西8区，该字段和GPSTime构成一个完整的时间描述
            /// </summary>
            public int iTimeZone;
            /// <summary>
            /// 车辆方向=实际方向（以度为单位，正北方向为，顺时针方向计算）*100
            /// </summary>
            public uint dwDirection;
            /// <summary>
            /// 卫星数量
            /// </summary>
            public ushort wSatellites;
            /// <summary>
            /// 精度
            /// </summary>
            public ushort wPrecision;
            /// <summary>
            /// 高度:厘米，预留
            /// </summary>
            public uint dwHeight;
            /// <summary>
            /// GPS序号，GPS补传时要用到
            /// </summary>
            public uint dwGPSSeq;
            /// <summary>
            /// 速度，单位，km/h
            /// </summary>
            public ushort wSpeed;
            /// <summary>
            /// direction[0]:'E'or'W'(东经/西经), direction[1]:'N'or'S'(北纬/南纬)
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] sDirection;
            /// <summary>
            /// 定位模式(初值0)，1,自主定位,2,差分3,估算,4,数据无效，65,有效定位，78，无效定位
            /// </summary>
            public byte byLocateMode;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 热度图报警上传
        /// </summary>
        //热度图报警上传
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_HEATMAP_RESULT
        {
            public uint dwSize;
            /// <summary>
            /// 设备信息
            /// </summary>
            public NET_VCA_DEV_INFO struDevInfo;
            /// <summary>
            /// 开始时间
            /// </summary>
            public NET_DVR_TIME_EX struStartTime;
            /// <summary>
            /// 结束时间
            /// </summary>
            public NET_DVR_TIME_EX struEndTime;
            /// <summary>
            /// 最大热度值
            /// </summary>
            public uint dwMaxHeatMapValue;
            /// <summary>
            /// 最小热度值
            /// </summary>
            public uint dwMinHeatMapValue;
            /// <summary>
            /// (时间热度值)平均热度值
            /// </summary>
            public uint dwTimeHeatMapValue;
            /// <summary>
            /// 图片像素点行值
            /// </summary>
            public ushort wArrayLine;
            /// <summary>
            /// 图片像素点列值 （当行列值为0的时候，像素点值内存信息不存在）
            /// </summary>
            public ushort wArrayColumn;
            /// <summary>
            /// 热度图片像素点数据信息
            /// </summary>
            public IntPtr pBuffer;
            /// <summary>
            /// 检测场景号[1],球机当前支持1个场景, IPC默认是0
            /// </summary>
            public byte byDetSceneID;
            /// <summary>
            /// 断网续传标志位，0-不是重传数据，1-重传数据
            /// </summary>
            public byte byBrokenNetHttp;
            /// <summary>
            /// 与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
            /// </summary>
            public ushort wDevInfoIvmsChannelEx;
            /// <summary>
            /// 时差字段是否有效  0-时差无效， 1-时差有效
            /// </summary>
            public byte byTimeDiffFlag;
            /// <summary>
            /// 开始时间与UTC的时差（小时），-12 ... +14，+表示东区
            /// </summary>
            public byte cStartTimeDifferenceH;
            /// <summary>
            /// 开始时间与UTC的时差（分钟），-30, 30, 45，+表示东区
            /// </summary>
            public byte cStartTimeDifferenceM;
            /// <summary>
            /// 结束时间与UTC的时差（小时），-12 ... +14， +表示东区
            /// </summary>
            public byte cStopTimeDifferenceH;
            /// <summary>
            /// 结束时间与UTC的时差（分钟），-30, 30, 45，+表示东区
            /// </summary>
            public byte cStopTimeDifferenceM;
            /// <summary>
            /// 矩阵单元数据类型（矩阵信息中每个像素点数据的数据类型），1-byte，2-short,4-int
            /// </summary>
            public byte byArrayUnitType;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 停留时间总和，单位秒，按人员停留时间报警时上传
            /// </summary>
            public uint dwTotalTime;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 112, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// *******************************************************
        /// Function:	EXCEPYIONCALLBACK
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate void EXCEPYIONCALLBACK(uint dwType, int lUserID, int lHandle, IntPtr pUser);

        /// <summary>
        /// *******************************************************
        /// Function:	MESSCALLBACK
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate int MESSCALLBACK(int lCommand, string sDVRIP, string pBuf, uint dwBufLen);

        /// <summary>
        /// *******************************************************
        /// Function:	MESSCALLBACKEX
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate int MESSCALLBACKEX(int iCommand, int iUserID, string pBuf, uint dwBufLen);

        /// <summary>
        /// *******************************************************
        /// Function:	MESSCALLBACKNEW
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate int MESSCALLBACKNEW(int lCommand, string sDVRIP, string pBuf, uint dwBufLen, ushort dwLinkDVRPort);

        /// <summary>
        /// *******************************************************
        /// Function:	MESSAGECALLBACK
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate int MESSAGECALLBACK(int lCommand, System.IntPtr sDVRIP, System.IntPtr pBuf, uint dwBufLen, uint dwUser);

        /// <summary>
        /// *******************************************************
        /// Function:	MSGCallBack
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate void MSGCallBack(int lCommand, NET_DVR_ALARMER pAlarmer, IntPtr pAlarmInfo, uint dwBufLen, IntPtr pUser);

        public delegate bool MSGCallBack_V31(int lCommand, NET_DVR_ALARMER pAlarmer, IntPtr pAlarmInfo, uint dwBufLen, IntPtr pUser);

        /// <summary>
        /// *******************************************************
        /// Function:	REALDATACALLBACK
        /// Desc:		预览回调
        /// Input:	lRealHandle 当前的预览句柄
        /// dwDataType 数据类型
        /// pBuffer 存放数据的缓冲区指针
        /// dwBufSize 缓冲区大小
        /// pUser 用户数据
        /// Output:
        /// Return:	void
        /// ********************************************************
        /// </summary>
        public delegate void REALDATACALLBACK(Int32 lRealHandle, UInt32 dwDataType, IntPtr pBuffer, UInt32 dwBufSize, IntPtr pUser);

        /// <summary>
        /// *******************************************************
        /// Function:	DRAWFUN
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate void DRAWFUN(int lRealHandle, IntPtr hDc, uint dwUser);

        /// <summary>
        /// *******************************************************
        /// Function:	REALDATACALLBACK
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate void SETREALDATACALLBACK(int lRealHandle, uint dwDataType, IntPtr pBuffer, uint dwBufSize, uint dwUser);

        /// <summary>
        /// *******************************************************
        /// Function:	STDDATACALLBACK
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate void STDDATACALLBACK(int lRealHandle, uint dwDataType, byte pBuffer, uint dwBufSize, uint dwUser);

        /// <summary>
        /// *******************************************************
        /// Function:	PLAYDATACALLBACK
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate void PLAYDATACALLBACK(int lPlayHandle, uint dwDataType, IntPtr pBuffer, uint dwBufSize, uint dwUser);

        /// <summary>
        /// 语音对讲
        /// *******************************************************
        /// Function:	VOICEDATACALLBACK
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate void VOICEDATACALLBACK(int lVoiceComHandle, string pRecvDataBuffer, uint dwBufSize, byte byAudioFlag, uint dwUser);

        /// <summary>
        /// *******************************************************
        /// Function:	VOICEDATACALLBACKV30
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate void VOICEDATACALLBACKV30(int lVoiceComHandle, IntPtr pRecvDataBuffer, uint dwBufSize, byte byAudioFlag, System.IntPtr pUser);

        /// <summary>
        /// *******************************************************
        /// Function:	VOICEAUDIOSTART
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate void VOICEAUDIOSTART(string pRecvDataBuffer, uint dwBufSize, IntPtr pUser);

        /// <summary>
        /// 透明通道设置
        /// *******************************************************
        /// Function:	SERIALDATACALLBACK
        /// Desc:		(回调函数)
        /// Input:
        /// Output:
        /// Return:
        /// ********************************************************
        /// </summary>
        public delegate void SERIALDATACALLBACK(int lSerialHandle, string pRecvDataBuffer, uint dwBufSize, uint dwUser);
        /// <summary>
        /// 显示LOGO
        /// </summary>
        public const int NET_DVR_SHOWLOGO = 1;
        /// <summary>
        /// 隐藏LOGO
        /// </summary>
        public const int NET_DVR_HIDELOGO = 2;
        /// <summary>
        /// 显示通道放大某个窗口
        /// </summary>
        public const int DISP_CMD_ENLARGE_WINDOW = 1;
        /// <summary>
        /// 显示通道窗口还原
        /// </summary>
        public const int DISP_CMD_RENEW_WINDOW = 2;

        public delegate void fRemoteConfigCallback(int lCommand, IntPtr pUserData, IntPtr pAlarmInfo, uint dwBufLen, uint dwUser);

        [StructLayout(LayoutKind.Sequential)]
        public struct NET_DVR_DOOR_STATUS_PLAN
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 计划模板编号，为0表示取消关联，恢复默认状态（普通状态）
            /// </summary>
            public uint dwTemplateNo;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
            public byte[] byRes;
        }

        public delegate void RemoteConfigCallback(uint dwType, IntPtr lpBuffer, uint dwBufLen, IntPtr pUserData);

        /// <summary>
        /// 识别场景
        /// </summary>
        public enum VCA_RECOGNIZE_SCENE
        {
            /// <summary>
            /// 低速通过场景（收费站、小区门口、停车场）
            /// </summary>
            VCA_LOW_SPEED_SCENE = 0,
            /// <summary>
            /// 高速通过场景（卡口、高速公路、移动稽查)
            /// </summary>
            VCA_HIGH_SPEED_SCENE = 1,
            /// <summary>
            /// 移动摄像机应用）
            /// </summary>
            VCA_MOBILE_CAMERA_SCENE = 2
        }

        /// <summary>
        /// 识别结果标志
        /// </summary>
        public enum VCA_RECOGNIZE_RESULT
        {
            /// <summary>
            /// 识别失败
            /// </summary>
            VCA_RECOGNIZE_FAILURE = 0,
            /// <summary>
            /// 图像识别成功
            /// </summary>
            VCA_IMAGE_RECOGNIZE_SUCCESS,
            /// <summary>
            /// 视频识别更优结果
            /// </summary>
            VCA_VIDEO_RECOGNIZE_SUCCESS_OF_BEST_LICENSE,
            /// <summary>
            /// 视频识别到新的车牌
            /// </summary>
            VCA_VIDEO_RECOGNIZE_SUCCESS_OF_NEW_LICENSE,
            /// <summary>
            /// 视频识别车牌结束
            /// </summary>
            VCA_VIDEO_RECOGNIZE_FINISH_OF_CUR_LICENSE
        }

        /// <summary>
        /// 视频识别触发类型
        /// </summary>
        public enum VCA_TRIGGER_TYPE
        {
            /// <summary>
            /// 模块内部触发识别
            /// </summary>
            INTER_TRIGGER = 0,
            /// <summary>
            /// 外部物理信号触发：线圈、雷达、手动触发信号；
            /// </summary>
            EXTER_TRIGGER = 1
        }
        /// <summary>
        /// 最大汉字类别数量
        /// </summary>
        public const int MAX_CHINESE_CHAR_NUM = 64;

        /// <summary>
        /// 车牌可动态修改参数
        /// </summary>
        //车牌可动态修改参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_PLATE_PARAM
        {
            /// <summary>
            /// 搜索区域(归一化)
            /// </summary>
            public NET_VCA_RECT struSearchRect;
            /// <summary>
            /// 无效区域，在搜索区域内部 (归一化)
            /// </summary>
            public NET_VCA_RECT struInvalidateRect;
            /// <summary>
            /// 车牌最小宽度
            /// </summary>
            public ushort wMinPlateWidth;
            /// <summary>
            /// 触发持续帧数
            /// </summary>
            public ushort wTriggerDuration;
            /// <summary>
            /// 触发模式, VCA_TRIGGER_TYPE
            /// </summary>
            public byte byTriggerType;
            /// <summary>
            /// 灵敏度
            /// </summary>
            public byte bySensitivity;
            /// <summary>
            /// 保留，置0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 汉字优先级
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 64, ArraySubType = UnmanagedType.I1)]
            public byte[] byCharPriority;
        }

        /// <summary>
        /// wMinPlateWidth:该参数默认配置为80像素；该参数的配置对于车牌海康威视车牌识别说明文档
        /// 识别有影响，如果设置过大，那么如果场景中出现小车牌就会漏识别；如果场景中车牌宽度普遍较大，可以把该参数设置稍大，便于减少对虚假车牌的处理。在标清情况下建议设置为80， 在高清情况下建议设置为120
        /// wTriggerDuration － 外部触发信号持续帧数量，其含义是从触发信号开始识别的帧数量。该值在低速场景建议设置为50～100；高速场景建议设置为15～25；移动识别时如果也有外部触发，设置为15～25；具体可以根据现场情况进行配置
        /// 车牌识别参数子结构
        /// </summary>
        /*wMinPlateWidth:该参数默认配置为80像素；该参数的配置对于车牌海康威视车牌识别说明文档 
	    识别有影响，如果设置过大，那么如果场景中出现小车牌就会漏识别；如果场景中车牌宽度普遍较大，可以把该参数设置稍大，便于减少对虚假车牌的处理。在标清情况下建议设置为80， 在高清情况下建议设置为120
        wTriggerDuration － 外部触发信号持续帧数量，其含义是从触发信号开始识别的帧数量。该值在低速场景建议设置为50～100；高速场景建议设置为15～25；移动识别时如果也有外部触发，设置为15～25；具体可以根据现场情况进行配置
        */
        //车牌识别参数子结构
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_PLATEINFO
        {
            /// <summary>
            /// 识别场景(低速和高速)
            /// </summary>
            public VCA_RECOGNIZE_SCENE eRecogniseScene;
            /// <summary>
            /// 车牌可动态修改参数
            /// </summary>
            public NET_VCA_PLATE_PARAM struModifyParam;
        }

        /// <summary>
        /// 车牌识别配置参数
        /// </summary>
        //车牌识别配置参数
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_PLATECFG
        {
            public uint dwSize;
            /// <summary>
            /// 报警时图片处理方式 0-不处理 1-上传
            /// </summary>
            public byte byPicProType;
            /// <summary>
            /// 保留，设置为0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
            /// <summary>
            /// 图片规格结构
            /// </summary>
            public NET_DVR_JPEGPARA struPictureParam;
            /// <summary>
            /// 车牌信息
            /// </summary>
            public NET_VCA_PLATEINFO struPlateInfo;
            /// <summary>
            /// 布防时间
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_DAYS * MAX_TIMESEGMENT_2, ArraySubType = UnmanagedType.Struct)]
            public NET_DVR_SCHEDTIME[] struAlarmTime;
            /// <summary>
            /// 处理方式
            /// </summary>
            public NET_DVR_HANDLEEXCEPTION_V30 struHandleType;
            /// <summary>
            /// 报警触发的录象通道,为1表示触发该通道
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_CHANNUM_V30, ArraySubType = UnmanagedType.I1)]
            public byte[] byRelRecordChan;
        }

        /// <summary>
        /// 车牌识别结果子结构
        /// </summary>
        //车牌识别结果子结构
        [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct NET_VCA_PLATE_INFO
        {
            /// <summary>
            /// 识别结果标志
            /// </summary>
            public VCA_RECOGNIZE_RESULT eResultFlag;
            /// <summary>
            /// 车牌类型
            /// </summary>
            public VCA_PLATE_TYPE ePlateType;
            /// <summary>
            /// 车牌颜色
            /// </summary>
            public VCA_PLATE_COLOR ePlateColor;
            /// <summary>
            /// 车牌位置
            /// </summary>
            public NET_VCA_RECT struPlateRect;
            /// <summary>
            /// 保留，设置为0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRes;
            /// <summary>
            /// 车牌长度
            /// </summary>
            public uint dwLicenseLen;
            /// <summary>
            /// 车牌号码
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = MAX_LICENSE_LEN)]
            public string sLicense;
            /// <summary>
            /// 各个识别字符的置信度，如检测到车牌"浙A12345", 置信度为10,20,30,40,50,60,70，则表示"浙"字正确的可能性只有10%，"A"字的正确的可能性是20%
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValTStr, SizeConst = MAX_LICENSE_LEN)]
            public string sBelieve;
        }

        /// <summary>
        /// 车牌检测结果
        /// </summary>
        //车牌检测结果
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_PLATE_RESULT
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 相对时标
            /// </summary>
            public uint dwRelativeTime;
            /// <summary>
            /// 绝对时标
            /// </summary>
            public uint dwAbsTime;
            /// <summary>
            /// 车牌个数
            /// </summary>
            public byte byPlateNum;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes1;
            /// <summary>
            /// 车牌信息结构
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_PLATE_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_PLATE_INFO[] struPlateInfo;
            /// <summary>
            /// 返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据
            /// </summary>
            public uint dwPicDataLen;
            /// <summary>
            /// 保留，设置为0 图片的高宽
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRes2;
            /// <summary>
            /// 指向图片的指针
            /// </summary>
            public System.IntPtr pImage;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_LINE_SEGMENT
        {
            /// <summary>
            /// 表示高度线时，表示头部点
            /// </summary>
            public NET_VCA_POINT struStartPoint;
            /// <summary>
            /// 表示高度线时，表示脚部点
            /// </summary>
            public NET_VCA_POINT struEndPoint;
            /// <summary>
            /// 高度值，单位米
            /// </summary>
            public float fValue;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.I1)]
            public byte[] byRes;
        }

        /// <summary>
        /// 标定线链表
        /// </summary>
        //标定线链表
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_VCA_LINE_SEG_LIST
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 标定线条数
            /// </summary>
            public byte bySegNum;
            /// <summary>
            /// 保留，置0
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = System.Runtime.InteropServices.UnmanagedType.I1)]
            public byte[] byRes;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = MAX_SEGMENT_NUM, ArraySubType = UnmanagedType.Struct)]
            public NET_VCA_LINE_SEGMENT[] struSeg;
        }
        /// <summary>
        /// 2009-8-18 抓拍机
        /// </summary>
        public const int PLATE_INFO_LEN = 1024;
        public const int PLATE_NUM_LEN = 16;
        public const int FILE_NAME_LEN = 256;

        /// <summary>
        /// liscense plate result
        /// </summary>
        //liscense plate result
        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_PLATE_RET
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 车牌号
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PLATE_NUM_LEN, ArraySubType = UnmanagedType.I1)]
            public byte[] byPlateNum;
            /// <summary>
            /// 车类型
            /// </summary>
            public byte byVehicleType;
            /// <summary>
            /// 0-绿灯；1-红灯
            /// </summary>
            public byte byTrafficLight;
            /// <summary>
            /// 车牌颜色
            /// </summary>
            public byte byPlateColor;
            /// <summary>
            /// 触发车道号
            /// </summary>
            public byte byDriveChan;
            /// <summary>
            /// plate_172.6.113.64_20090724155526948_197170484
            /// 时间信息
            /// </summary>
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 32, ArraySubType = UnmanagedType.I1)]
            public byte[] byTimeInfo;
            /// <summary>
            /// 目前是17位，精确到ms:20090724155526948
            /// </summary>
            public byte byCarSpeed;
            /// <summary>
            /// cm/s高8位
            /// </summary>
            public byte byCarSpeedH;
            /// <summary>
            /// cm/s低8位
            /// </summary>
            public byte byCarSpeedL;
            public byte byRes;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = PLATE_INFO_LEN - 36, ArraySubType = UnmanagedType.I1)]
            public byte[] byInfo;
            public uint dwPicLen;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct NET_DVR_CCD_CFG
        {
            /// <summary>
            /// 结构长度
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 背光补偿0-off; 1-on
            /// </summary>
            public byte byBlc;
            /// <summary>
            /// blc类型0-自定义1-上；2-下；3-左；4-右；5-中；注：此项在blc为 on 时才起效
            /// </summary>
            public byte byBlcMode;
            /// <summary>
            /// 自动白平衡0-自动1; 1-自动2; 2-自动控制
            /// </summary>
            public byte byAwb;
            /// <summary>
            /// 自动增益0-关; 1-低; 2-中; 3-高
            /// </summary>
            public byte byAgc;
            /// <summary>
            /// 日夜转换；0 彩色；1黑白；2自动
            /// </summary>
            public byte byDayNight;
            /// <summary>
            /// 镜像0-关;1-左右;2-上下;3-中心
            /// </summary>
            public byte byMirror;
            /// <summary>
            /// 快门0-自动; 1-1/25; 2-1/50; 3-1/100; 4-1/250;5-1/500; 6-1/1k ;7-1/2k; 8-1/4k; 9-1/10k; 10-1/100k;
            /// </summary>
            public byte byShutter;
            /// <summary>
            /// IRCUT切换时间，5, 10, 15, 20, 25
            /// </summary>
            public byte byIrCutTime;
            /// <summary>
            /// 镜头类型0-电子光圈; 1-自动光圈
            /// </summary>
            public byte byLensType;
            /// <summary>
            /// 视频触发使能：1-支持；0-不支持。视频触发模式下视频快门速度按照byShutter速度，抓拍图片的快门速度按照byCapShutter速度，抓拍完成后会自动调节回视频模式
            /// </summary>
            public byte byEnVideoTrig;
            /// <summary>
            /// 抓拍时的快门速度，1-1/25; 2-1/50; 3-1/100; 4-1/250;5-1/500; 6-1/1k ;7-1/2k; 8-1/4k; 9-1/10k; 10-1/100k; 11-1/150; 12-1/200
            /// </summary>
            public byte byCapShutter;
            /// <summary>
            /// 1-支持识别；0-不支持识别
            /// </summary>
            public byte byEnRecognise;
        }

        [StructLayoutAttribute(LayoutKind.Sequential)]
        public struct tagCAMERAPARAMCFG
        {
            public uint dwSize;
            /// <summary>
            /// 0-50HZ; 1-60HZ
            /// </summary>
            public uint dwPowerLineFrequencyMode;
            /// <summary>
            /// 0手动白平衡; 1自动白平衡1（范围小）; 2 自动白平衡2（范围宽，2200K-15000K）;3自动控制3
            /// </summary>
            public uint dwWhiteBalanceMode;
            /// <summary>
            /// 手动白平衡时有效，手动白平衡 R增益
            /// </summary>
            public uint dwWhiteBalanceModeRGain;
            /// <summary>
            /// 手动白平衡时有效，手动白平衡 B增益
            /// </summary>
            public uint dwWhiteBalanceModeBGain;
            /// <summary>
            /// 0 手动曝光 1自动曝光
            /// </summary>
            public uint dwExposureMode;
            /// <summary>
            /// 0-USERSET, 1-自动x2，2-自动4，3-自动81/25, 4-1/50, 5-1/100, 6-1/250, 7-1/500, 8-1/750, 9-1/1000, 10-1/2000, 11-1/4000,12-1/10,000; 13-1/100,000
            /// </summary>
            public uint dwExposureSet;
            /// <summary>
            /// 自动自定义曝光时间
            /// </summary>
            public uint dwExposureUserSet;
            /// <summary>
            /// 手动曝光时间 范围（Manumal有效，微秒）
            /// </summary>
            public uint dwExposureTarget;
            /// <summary>
            /// 0 自动光圈 1手动光圈
            /// </summary>
            public uint dwIrisMode;
            /// <summary>
            /// 增益：0-100
            /// </summary>
            public uint dwGainLevel;
            /// <summary>
            /// 0-100
            /// </summary>
            public uint dwBrightnessLevel;
            /// <summary>
            /// 0-100
            /// </summary>
            public uint dwContrastLevel;
            /// <summary>
            /// 0-100
            /// </summary>
            public uint dwSharpnessLevel;
            /// <summary>
            /// 0-100
            /// </summary>
            public uint dwSaturationLevel;
            /// <summary>
            /// 0-100，（保留）
            /// </summary>
            public uint dwHueLevel;
            /// <summary>
            /// 0 dsibale  1 enable
            /// </summary>
            public uint dwGammaCorrectionEnabled;
            /// <summary>
            /// 0-100
            /// </summary>
            public uint dwGammaCorrectionLevel;
            /// <summary>
            /// 宽动态：0 dsibale  1 enable
            /// </summary>
            public uint dwWDREnabled;
            /// <summary>
            /// 0-F
            /// </summary>
            public uint dwWDRLevel1;
            /// <summary>
            /// 0-F
            /// </summary>
            public uint dwWDRLevel2;
            /// <summary>
            /// 0-100
            /// </summary>
            public uint dwWDRContrastLevel;
            /// <summary>
            /// 日夜切换：0 day,1 night,2 auto
            /// </summary>
            public uint dwDayNightFilterType;
            /// <summary>
            /// 0 dsibale  1 enable,(保留)
            /// </summary>
            public uint dwSwitchScheduleEnabled;
            /// <summary>
            /// 模式1(保留)
            /// </summary>
            public uint dwBeginTime;
            /// <summary>
            /// 0-100
            /// </summary>
            public uint dwEndTime;
            /// <summary>
            /// 模式2
            /// </summary>
            public uint dwDayToNightFilterLevel;
            /// <summary>
            /// 0-7
            /// </summary>
            public uint dwNightToDayFilterLevel;
            /// <summary>
            /// (60秒)
            /// </summary>
            public uint dwDayNightFilterTime;
            /// <summary>
            /// 背光补偿:0 USERSET 1 UP、2 DOWN、3 LEFT、4 RIGHT、5MIDDLE
            /// </summary>
            public uint dwBacklightMode;
            /// <summary>
            /// （X坐标1）
            /// </summary>
            public uint dwPositionX1;
            /// <summary>
            /// （Y坐标1）
            /// </summary>
            public uint dwPositionY1;
            /// <summary>
            /// （X坐标2）
            /// </summary>
            public uint dwPositionX2;
            /// <summary>
            /// （Y坐标2）
            /// </summary>
            public uint dwPositionY2;
            /// <summary>
            /// 0x0-0xF
            /// </summary>
            public uint dwBacklightLevel;
            /// <summary>
            /// 数字去噪：0 dsibale  1 enable
            /// </summary>
            public uint dwDigitalNoiseRemoveEnable;
            /// <summary>
            /// 0x0-0xF
            /// </summary>
            public uint dwDigitalNoiseRemoveLevel;
            /// <summary>
            /// 镜像：0 Left;1 Right,;2 Up;3Down
            /// </summary>
            public uint dwMirror;
            /// <summary>
            /// 数字缩放:0 dsibale  1 enable
            /// </summary>
            public uint dwDigitalZoom;
            /// <summary>
            /// 坏点检测,0 dsibale  1 enable
            /// </summary>
            public uint dwDeadPixelDetect;
            [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 20, ArraySubType = UnmanagedType.U4)]
            public uint[] dwRes;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct NET_DVR_ACS_CFG
        {
            /// <summary>
            /// 结构体大小
            /// </summary>
            public uint dwSize;
            /// <summary>
            /// 是否启用下行RS485通信备份功能，0-不启用，1-启用
            /// </summary>
            public byte byRS485Backup;
            /// <summary>
            /// 是否显示抓拍图片， 0-不显示，1-显示
            /// </summary>
            public byte byShowCapPic;
            /// <summary>
            /// 是否显示卡号，0-不显示，1-显示
            /// </summary>
            public byte byShowCardNo;
            /// <summary>
            /// 是否显示用户信息，0-不显示，1-显示
            /// </summary>
            public byte byShowUserInfo;
            /// <summary>
            /// 是否叠加用户信息，0-不叠加，1-叠加
            /// </summary>
            public byte byOverlayUserInfo;
            /// <summary>
            /// 是否启用语音提示，0-不启用，1-启用
            /// </summary>
            public byte byVoicePrompt;
            /// <summary>
            /// 联动抓拍是否上传图片，0-不上传，1-上传
            /// </summary>
            public byte byUploadCapPic;
            /// <summary>
            /// 是否保存抓拍图片，0-不保存，1-保存
            /// </summary>
            public byte bySaveCapPic;
            /// <summary>
            /// 是否允许按键输入卡号，0-不允许，1-允许
            /// </summary>
            public byte byInputCardNo;
            /// <summary>
            /// 是否启动wifi，0-不启动，1-启动
            /// </summary>
            public byte byEnableWifiDetect;
            /// <summary>
            /// 3G4G使能，0-不使能，1-使能
            /// </summary>
            public byte byEnable3G4G;
            /// <summary>
            /// 读卡器通信协议类型，0-私有协议（默认），1-OSDP协议
            /// </summary>
            public byte byProtocol;
            /// <summary>
            /// 保留字节
            /// </summary>
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 500)]
            public byte[] byRes;
        }
        /// <summary>
        /// IPC获取CCD参数配置
        /// </summary>
        public const int NET_DVR_GET_CCDPARAMCFG = 1067;
        /// <summary>
        /// IPC设置CCD参数配置
        /// </summary>
        public const int NET_DVR_SET_CCDPARAMCFG = 1068;
    
    }
}
